diff --git a/Makefile b/Makefile
index 39a99d7..ad71e7d 100644
--- a/Makefile
+++ b/Makefile
@@ -1,173 +1,176 @@
-K=kernel
-U=user
-
-OBJS = \
-  $K/entry.o \
-  $K/start.o \
-  $K/console.o \
-  $K/printf.o \
-  $K/uart.o \
-  $K/kalloc.o \
-  $K/spinlock.o \
-  $K/string.o \
-  $K/main.o \
-  $K/vm.o \
-  $K/proc.o \
-  $K/swtch.o \
-  $K/trampoline.o \
-  $K/trap.o \
-  $K/syscall.o \
-  $K/sysproc.o \
-  $K/bio.o \
-  $K/fs.o \
-  $K/log.o \
-  $K/sleeplock.o \
-  $K/file.o \
-  $K/pipe.o \
-  $K/exec.o \
-  $K/sysfile.o \
-  $K/kernelvec.o \
-  $K/plic.o \
-  $K/virtio_disk.o
-
-# riscv64-unknown-elf- or riscv64-linux-gnu-
-# perhaps in /opt/riscv/bin
-#TOOLPREFIX = 
-
-# Try to infer the correct TOOLPREFIX if not set
-ifndef TOOLPREFIX
-TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
-	then echo 'riscv64-unknown-elf-'; \
-	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
-	then echo 'riscv64-linux-gnu-'; \
-	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
-	then echo 'riscv64-unknown-linux-gnu-'; \
-	else echo "***" 1>&2; \
-	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
-	echo "***" 1>&2; exit 1; fi)
-endif
-
-QEMU = qemu-system-riscv64
-
-CC = $(TOOLPREFIX)gcc
-AS = $(TOOLPREFIX)gas
-LD = $(TOOLPREFIX)ld
-OBJCOPY = $(TOOLPREFIX)objcopy
-OBJDUMP = $(TOOLPREFIX)objdump
-
-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
-CFLAGS += -MD
-CFLAGS += -mcmodel=medany
-CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
-CFLAGS += -I.
-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
-
-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
-CFLAGS += -fno-pie -no-pie
-endif
-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
-CFLAGS += -fno-pie -nopie
-endif
-
-LDFLAGS = -z max-page-size=4096
-
-$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
-	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
-	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
-
-$U/initcode: $U/initcode.S
-	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
-	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
-	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
-
-tags: $(OBJS) _init
-	etags *.S *.c
-
-ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
-
-_%: %.o $(ULIB)
-	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
-	$(OBJDUMP) -S $@ > $*.asm
-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
-
-$U/usys.S : $U/usys.pl
-	perl $U/usys.pl > $U/usys.S
-
-$U/usys.o : $U/usys.S
-	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
-
-$U/_forktest: $U/forktest.o $(ULIB)
-	# forktest has less library code linked in - needs to be small
-	# in order to be able to max out the proc table.
-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
-	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
-
-mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
-	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
-
-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
-# that disk image changes after first build are persistent until clean.  More
-# details:
-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
-.PRECIOUS: %.o
-
-UPROGS=\
-	$U/_cat\
-	$U/_echo\
-	$U/_forktest\
-	$U/_grep\
-	$U/_init\
-	$U/_kill\
-	$U/_ln\
-	$U/_ls\
-	$U/_mkdir\
-	$U/_rm\
-	$U/_sh\
-	$U/_stressfs\
-	$U/_usertests\
-	$U/_grind\
-	$U/_wc\
-	$U/_zombie\
-
-fs.img: mkfs/mkfs README $(UPROGS)
-	mkfs/mkfs fs.img README $(UPROGS)
-
--include kernel/*.d user/*.d
-
-clean: 
-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
-	*/*.o */*.d */*.asm */*.sym \
-	$U/initcode $U/initcode.out $K/kernel fs.img \
-	mkfs/mkfs .gdbinit \
-        $U/usys.S \
-	$(UPROGS)
-
-# try to generate a unique GDB port
-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
-# QEMU's gdb stub command line changed in 0.11
-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
-	then echo "-gdb tcp::$(GDBPORT)"; \
-	else echo "-s -p $(GDBPORT)"; fi)
-ifndef CPUS
-CPUS := 3
-endif
-
-QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
-QEMUOPTS += -global virtio-mmio.force-legacy=false
-QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
-QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
-
-qemu: $K/kernel fs.img
-	$(QEMU) $(QEMUOPTS)
-
-.gdbinit: .gdbinit.tmpl-riscv
-	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
-
-qemu-gdb: $K/kernel .gdbinit fs.img
-	@echo "*** Now run 'gdb' in another window." 1>&2
-	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
-
+K=kernel
+U=user
+
+OBJS = \
+  $K/entry.o \
+  $K/start.o \
+  $K/console.o \
+  $K/printf.o \
+  $K/uart.o \
+  $K/kalloc.o \
+  $K/spinlock.o \
+  $K/string.o \
+  $K/main.o \
+  $K/vm.o \
+  $K/proc.o \
+  $K/swtch.o \
+  $K/trampoline.o \
+  $K/trap.o \
+  $K/syscall.o \
+  $K/sysproc.o \
+  $K/bio.o \
+  $K/fs.o \
+  $K/log.o \
+  $K/sleeplock.o \
+  $K/file.o \
+  $K/pipe.o \
+  $K/swap.o \
+  $K/exec.o \
+  $K/sysfile.o \
+  $K/kernelvec.o \
+  $K/plic.o \
+  $K/virtio_disk.o
+
+# riscv64-unknown-elf- or riscv64-linux-gnu-
+# perhaps in /opt/riscv/bin
+#TOOLPREFIX = 
+
+# Try to infer the correct TOOLPREFIX if not set
+ifndef TOOLPREFIX
+TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+	then echo 'riscv64-unknown-elf-'; \
+	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+	then echo 'riscv64-linux-gnu-'; \
+	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+	then echo 'riscv64-unknown-linux-gnu-'; \
+	else echo "***" 1>&2; \
+	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
+	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+	echo "***" 1>&2; exit 1; fi)
+endif
+
+QEMU = qemu-system-riscv64
+
+CC = $(TOOLPREFIX)gcc
+AS = $(TOOLPREFIX)gas
+LD = $(TOOLPREFIX)ld
+OBJCOPY = $(TOOLPREFIX)objcopy
+OBJDUMP = $(TOOLPREFIX)objdump
+
+CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
+CFLAGS += -MD
+CFLAGS += -mcmodel=medany
+CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
+CFLAGS += -I.
+CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+
+# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+CFLAGS += -fno-pie -no-pie
+endif
+ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+CFLAGS += -fno-pie -nopie
+endif
+
+LDFLAGS = -z max-page-size=4096
+
+$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
+	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
+	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
+	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
+
+$U/initcode: $U/initcode.S
+	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
+	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
+	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
+	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
+
+tags: $(OBJS) _init
+	etags *.S *.c
+
+ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
+
+_%: %.o $(ULIB)
+	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
+	$(OBJDUMP) -S $@ > $*.asm
+	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+
+$U/usys.S : $U/usys.pl
+	perl $U/usys.pl > $U/usys.S
+
+$U/usys.o : $U/usys.S
+	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
+
+$U/_forktest: $U/forktest.o $(ULIB)
+	# forktest has less library code linked in - needs to be small
+	# in order to be able to max out the proc table.
+	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
+	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
+
+mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
+	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
+
+# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+# that disk image changes after first build are persistent until clean.  More
+# details:
+# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+.PRECIOUS: %.o
+
+UPROGS=\
+	$U/_cat\
+	$U/_echo\
+	$U/_forktest\
+	$U/_grep\
+	$U/_init\
+	$U/_kill\
+	$U/_ln\
+	$U/_ls\
+	$U/_mkdir\
+	$U/_rm\
+	$U/_sh\
+	$U/_stressfs\
+	$U/_usertests\
+	$U/_grind\
+	$U/_wc\
+	$U/_zombie\
+	$U/_testlivepage\
+	$U/_testpagefork\
+
+fs.img: mkfs/mkfs README $(UPROGS)
+	mkfs/mkfs fs.img README $(UPROGS)
+
+-include kernel/*.d user/*.d
+
+clean: 
+	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+	*/*.o */*.d */*.asm */*.sym \
+	$U/initcode $U/initcode.out $K/kernel fs.img \
+	mkfs/mkfs .gdbinit \
+        $U/usys.S \
+	$(UPROGS)
+
+# try to generate a unique GDB port
+GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+# QEMU's gdb stub command line changed in 0.11
+QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+	then echo "-gdb tcp::$(GDBPORT)"; \
+	else echo "-s -p $(GDBPORT)"; fi)
+ifndef CPUS
+CPUS := 3
+endif
+
+QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
+QEMUOPTS += -global virtio-mmio.force-legacy=false
+QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
+QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
+
+qemu: $K/kernel fs.img
+	$(QEMU) $(QEMUOPTS)
+
+.gdbinit: .gdbinit.tmpl-riscv
+	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
+
+qemu-gdb: $K/kernel .gdbinit fs.img
+	@echo "*** Now run 'gdb' in another window." 1>&2
+	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
+
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..39ca9dd 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -1,189 +1,210 @@
-struct buf;
-struct context;
-struct file;
-struct inode;
-struct pipe;
-struct proc;
-struct spinlock;
-struct sleeplock;
-struct stat;
-struct superblock;
-
-// bio.c
-void            binit(void);
-struct buf*     bread(uint, uint);
-void            brelse(struct buf*);
-void            bwrite(struct buf*);
-void            bpin(struct buf*);
-void            bunpin(struct buf*);
-
-// console.c
-void            consoleinit(void);
-void            consoleintr(int);
-void            consputc(int);
-
-// exec.c
-int             exec(char*, char**);
-
-// file.c
-struct file*    filealloc(void);
-void            fileclose(struct file*);
-struct file*    filedup(struct file*);
-void            fileinit(void);
-int             fileread(struct file*, uint64, int n);
-int             filestat(struct file*, uint64 addr);
-int             filewrite(struct file*, uint64, int n);
-
-// fs.c
-void            fsinit(int);
-int             dirlink(struct inode*, char*, uint);
-struct inode*   dirlookup(struct inode*, char*, uint*);
-struct inode*   ialloc(uint, short);
-struct inode*   idup(struct inode*);
-void            iinit();
-void            ilock(struct inode*);
-void            iput(struct inode*);
-void            iunlock(struct inode*);
-void            iunlockput(struct inode*);
-void            iupdate(struct inode*);
-int             namecmp(const char*, const char*);
-struct inode*   namei(char*);
-struct inode*   nameiparent(char*, char*);
-int             readi(struct inode*, int, uint64, uint, uint);
-void            stati(struct inode*, struct stat*);
-int             writei(struct inode*, int, uint64, uint, uint);
-void            itrunc(struct inode*);
-
-// ramdisk.c
-void            ramdiskinit(void);
-void            ramdiskintr(void);
-void            ramdiskrw(struct buf*);
-
-// kalloc.c
-void*           kalloc(void);
-void            kfree(void *);
-void            kinit(void);
-
-// log.c
-void            initlog(int, struct superblock*);
-void            log_write(struct buf*);
-void            begin_op(void);
-void            end_op(void);
-
-// pipe.c
-int             pipealloc(struct file**, struct file**);
-void            pipeclose(struct pipe*, int);
-int             piperead(struct pipe*, uint64, int);
-int             pipewrite(struct pipe*, uint64, int);
-
-// printf.c
-void            printf(char*, ...);
-void            panic(char*) __attribute__((noreturn));
-void            printfinit(void);
-
-// proc.c
-int             cpuid(void);
-void            exit(int);
-int             fork(void);
-int             growproc(int);
-void            proc_mapstacks(pagetable_t);
-pagetable_t     proc_pagetable(struct proc *);
-void            proc_freepagetable(pagetable_t, uint64);
-int             kill(int);
-int             killed(struct proc*);
-void            setkilled(struct proc*);
-struct cpu*     mycpu(void);
-struct cpu*     getmycpu(void);
-struct proc*    myproc();
-void            procinit(void);
-void            scheduler(void) __attribute__((noreturn));
-void            sched(void);
-void            sleep(void*, struct spinlock*);
-void            userinit(void);
-int             wait(uint64);
-void            wakeup(void*);
-void            yield(void);
-int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
-int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
-void            procdump(void);
-
-// swtch.S
-void            swtch(struct context*, struct context*);
-
-// spinlock.c
-void            acquire(struct spinlock*);
-int             holding(struct spinlock*);
-void            initlock(struct spinlock*, char*);
-void            release(struct spinlock*);
-void            push_off(void);
-void            pop_off(void);
-
-// sleeplock.c
-void            acquiresleep(struct sleeplock*);
-void            releasesleep(struct sleeplock*);
-int             holdingsleep(struct sleeplock*);
-void            initsleeplock(struct sleeplock*, char*);
-
-// string.c
-int             memcmp(const void*, const void*, uint);
-void*           memmove(void*, const void*, uint);
-void*           memset(void*, int, uint);
-char*           safestrcpy(char*, const char*, int);
-int             strlen(const char*);
-int             strncmp(const char*, const char*, uint);
-char*           strncpy(char*, const char*, int);
-
-// syscall.c
-void            argint(int, int*);
-int             argstr(int, char*, int);
-void            argaddr(int, uint64 *);
-int             fetchstr(uint64, char*, int);
-int             fetchaddr(uint64, uint64*);
-void            syscall();
-
-// trap.c
-extern uint     ticks;
-void            trapinit(void);
-void            trapinithart(void);
-extern struct spinlock tickslock;
-void            usertrapret(void);
-
-// uart.c
-void            uartinit(void);
-void            uartintr(void);
-void            uartputc(int);
-void            uartputc_sync(int);
-int             uartgetc(void);
-
-// vm.c
-void            kvminit(void);
-void            kvminithart(void);
-void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
-int             mappages(pagetable_t, uint64, uint64, uint64, int);
-pagetable_t     uvmcreate(void);
-void            uvmfirst(pagetable_t, uchar *, uint);
-uint64          uvmalloc(pagetable_t, uint64, uint64, int);
-uint64          uvmdealloc(pagetable_t, uint64, uint64);
-int             uvmcopy(pagetable_t, pagetable_t, uint64);
-void            uvmfree(pagetable_t, uint64);
-void            uvmunmap(pagetable_t, uint64, uint64, int);
-void            uvmclear(pagetable_t, uint64);
-pte_t *         walk(pagetable_t, uint64, int);
-uint64          walkaddr(pagetable_t, uint64);
-int             copyout(pagetable_t, uint64, char *, uint64);
-int             copyin(pagetable_t, char *, uint64, uint64);
-int             copyinstr(pagetable_t, char *, uint64, uint64);
-
-// plic.c
-void            plicinit(void);
-void            plicinithart(void);
-int             plic_claim(void);
-void            plic_complete(int);
-
-// virtio_disk.c
-void            virtio_disk_init(void);
-void            virtio_disk_rw(struct buf *, int);
-void            virtio_disk_intr(void);
-
-// number of elements in fixed-size array
-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+struct buf;
+struct context;
+struct file;
+struct inode;
+struct pipe;
+struct proc;
+struct spinlock;
+struct sleeplock;
+struct stat;
+struct superblock;
+struct swap;
+struct user_page_alloc_flag;
+
+struct live;
+struct live_page_list;
+struct swapped_pages;
+
+// bio.c
+void            binit(void);
+struct buf*     bread(uint, uint);
+void            brelse(struct buf*);
+void            bwrite(struct buf*);
+void            bpin(struct buf*);
+void            bunpin(struct buf*);
+
+// console.c
+void            consoleinit(void);
+void            consoleintr(int);
+void            consputc(int);
+
+// exec.c
+int             exec(char*, char**);
+
+// file.c
+struct file*    filealloc(void);
+void            fileclose(struct file*);
+struct file*    filedup(struct file*);
+void            fileinit(void);
+int             fileread(struct file*, uint64, int n);
+int             filestat(struct file*, uint64 addr);
+int             filewrite(struct file*, uint64, int n);
+
+// fs.c
+void            fsinit(int);
+uint            balloc(uint dev);
+void            bfree(int dev, uint b);
+int             dirlink(struct inode*, char*, uint);
+struct inode*   dirlookup(struct inode*, char*, uint*);
+struct inode*   ialloc(uint, short);
+struct inode*   idup(struct inode*);
+void            iinit();
+void            ilock(struct inode*);
+void            iput(struct inode*);
+void            iunlock(struct inode*);
+void            iunlockput(struct inode*);
+void            iupdate(struct inode*);
+int             namecmp(const char*, const char*);
+struct inode*   namei(char*);
+struct inode*   nameiparent(char*, char*);
+int             readi(struct inode*, int, uint64, uint, uint);
+void            stati(struct inode*, struct stat*);
+int             writei(struct inode*, int, uint64, uint, uint);
+void            itrunc(struct inode*);
+
+// ramdisk.c
+void            ramdiskinit(void);
+void            ramdiskintr(void);
+void            ramdiskrw(struct buf*);
+
+// kalloc.c
+void*           kalloc(void);
+void            kfree(void *);
+void            kinit(void);
+
+// log.c
+void            initlog(int, struct superblock*);
+void            log_write(struct buf*);
+void            begin_op(void);
+void            end_op(void);
+
+// pipe.c
+int             pipealloc(struct file**, struct file**);
+void            pipeclose(struct pipe*, int);
+int             piperead(struct pipe*, uint64, int);
+int             pipewrite(struct pipe*, uint64, int);
+
+// printf.c
+void            printf(char*, ...);
+void            panic(char*) __attribute__((noreturn));
+void            printfinit(void);
+
+// proc.c
+int             cpuid(void);
+void            exit(int);
+int             fork(void);
+int             growproc(int);
+void            proc_mapstacks(pagetable_t);
+pagetable_t     proc_pagetable(struct proc *);
+void            proc_freepagetable(pagetable_t, uint64);
+int             kill(int);
+int             killed(struct proc*);
+void            setkilled(struct proc*);
+struct cpu*     mycpu(void);
+struct cpu*     getmycpu(void);
+struct proc*    myproc();
+void            procinit(void);
+void            scheduler(void) __attribute__((noreturn));
+void            sched(void);
+void            sleep(void*, struct spinlock*);
+void            userinit(void);
+int             wait(uint64);
+void            wakeup(void*);
+void            yield(void);
+int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
+int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
+void            procdump(void);
+
+// swap.c
+void            swapinit(void);
+void            swapfree(struct swap*);
+struct swap*    swapalloc(void);
+void            swapout(struct swap *dst_sp, char *src_pa);
+void            swapin(char *dst_pa, struct swap *src_sp);
+
+// swtch.S
+void            swtch(struct context*, struct context*);
+
+// spinlock.c
+void            acquire(struct spinlock*);
+int             holding(struct spinlock*);
+void            initlock(struct spinlock*, char*);
+void            release(struct spinlock*);
+void            push_off(void);
+void            pop_off(void);
+
+// sleeplock.c
+void            acquiresleep(struct sleeplock*);
+void            releasesleep(struct sleeplock*);
+int             holdingsleep(struct sleeplock*);
+void            initsleeplock(struct sleeplock*, char*);
+
+// string.c
+int             memcmp(const void*, const void*, uint);
+void*           memmove(void*, const void*, uint);
+void*           memset(void*, int, uint);
+char*           safestrcpy(char*, const char*, int);
+int             strlen(const char*);
+int             strncmp(const char*, const char*, uint);
+char*           strncpy(char*, const char*, int);
+
+// syscall.c
+void            argint(int, int*);
+int             argstr(int, char*, int);
+void            argaddr(int, uint64 *);
+int             fetchstr(uint64, char*, int);
+int             fetchaddr(uint64, uint64*);
+void            syscall();
+
+// trap.c
+extern uint     ticks;
+void            trapinit(void);
+void            trapinithart(void);
+extern struct spinlock tickslock;
+void            usertrapret(void);
+
+// uart.c
+void            uartinit(void);
+void            uartintr(void);
+void            uartputc(int);
+void            uartputc_sync(int);
+int             uartgetc(void);
+
+// vm.c
+void            kvminit(void);
+void            kvminithart(void);
+void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
+int             mappages(pagetable_t, uint64, uint64, uint64, int);
+pagetable_t     uvmcreate(void);
+void            uvmfirst(pagetable_t, uchar *, uint);
+uint64          uvmalloc(pagetable_t, uint64, uint64, int);
+uint64          uvmdealloc(pagetable_t, uint64, uint64);
+int             uvmcopy(pagetable_t, pagetable_t, uint64);
+void            uvmfree(pagetable_t, uint64);
+void            uvmunmap(pagetable_t, uint64, uint64, int);
+void            uvmclear(pagetable_t, uint64);
+pte_t *         walk(pagetable_t, uint64, int);
+uint64          walkaddr(pagetable_t, uint64);
+int             copyout(pagetable_t, uint64, char *, uint64);
+int             copyin(pagetable_t, char *, uint64, uint64);
+int             copyinstr(pagetable_t, char *, uint64, uint64);
+uint            swap_out_wrapper();
+struct live     remove_live_page(int);
+void            add_live_page(pagetable_t, uint64, uint64);
+int             list_lookup(uint64);
+void            print_live_list();
+void            print_live_count();
+
+// plic.c
+void            plicinit(void);
+void            plicinithart(void);
+int             plic_claim(void);
+void            plic_complete(int);
+
+// virtio_disk.c
+void            virtio_disk_init(void);
+void            virtio_disk_rw(struct buf *, int);
+void            virtio_disk_intr(void);
+
+// number of elements in fixed-size array
+#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/kernel/fs.c b/kernel/fs.c
index c6bab15..2d9b419 100644
--- a/kernel/fs.c
+++ b/kernel/fs.c
@@ -62,7 +62,7 @@ bzero(int dev, int bno)
 
 // Allocate a zeroed disk block.
 // returns 0 if out of disk space.
-static uint
+uint
 balloc(uint dev)
 {
   int b, bi, m;
@@ -88,7 +88,7 @@ balloc(uint dev)
 }
 
 // Free a disk block.
-static void
+void
 bfree(int dev, uint b)
 {
   struct buf *bp;
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..58d8d8f 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -1,82 +1,97 @@
-// Physical memory allocator, for user processes,
-// kernel stacks, page-table pages,
-// and pipe buffers. Allocates whole 4096-byte pages.
-
-#include "types.h"
-#include "param.h"
-#include "memlayout.h"
-#include "spinlock.h"
-#include "riscv.h"
-#include "defs.h"
-
-void freerange(void *pa_start, void *pa_end);
-
-extern char end[]; // first address after kernel.
-                   // defined by kernel.ld.
-
-struct run {
-  struct run *next;
-};
-
-struct {
-  struct spinlock lock;
-  struct run *freelist;
-} kmem;
-
-void
-kinit()
-{
-  initlock(&kmem.lock, "kmem");
-  freerange(end, (void*)PHYSTOP);
-}
-
-void
-freerange(void *pa_start, void *pa_end)
-{
-  char *p;
-  p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
-    kfree(p);
-}
-
-// Free the page of physical memory pointed at by pa,
-// which normally should have been returned by a
-// call to kalloc().  (The exception is when
-// initializing the allocator; see kinit above.)
-void
-kfree(void *pa)
-{
-  struct run *r;
-
-  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
-    panic("kfree");
-
-  // Fill with junk to catch dangling refs.
-  memset(pa, 1, PGSIZE);
-
-  r = (struct run*)pa;
-
-  acquire(&kmem.lock);
-  r->next = kmem.freelist;
-  kmem.freelist = r;
-  release(&kmem.lock);
-}
-
-// Allocate one 4096-byte page of physical memory.
-// Returns a pointer that the kernel can use.
-// Returns 0 if the memory cannot be allocated.
-void *
-kalloc(void)
-{
-  struct run *r;
-
-  acquire(&kmem.lock);
-  r = kmem.freelist;
-  if(r)
-    kmem.freelist = r->next;
-  release(&kmem.lock);
-
-  if(r)
-    memset((char*)r, 5, PGSIZE); // fill with junk
-  return (void*)r;
-}
+// Physical memory allocator, for user processes,
+// kernel stacks, page-table pages,
+// and pipe buffers. Allocates whole 4096-byte pages.
+
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "riscv.h"
+#include "defs.h"
+#include "swap.h"
+
+void freerange(void *pa_start, void *pa_end);
+
+extern char end[]; // first address after kernel.
+                   // defined by kernel.ld.
+
+extern struct live_page_list live_list;
+
+extern struct user_page_alloc_flag user_alloc_flag;
+
+struct run {
+  struct run *next;
+};
+
+struct {
+  struct spinlock lock;
+  struct run *freelist;
+} kmem;
+
+void init_live_pages() 
+{ 
+  initlock(&live_list.lock, "live_list");
+  live_list.size = 0; 
+}
+
+void
+kinit()
+{
+  init_live_pages();
+  initlock(&user_alloc_flag.lock, "user_alloc_flag");
+  initlock(&kmem.lock, "kmem");
+  swapinit();
+  freerange(end, (void*)PHYSTOP);
+}
+
+void
+freerange(void *pa_start, void *pa_end)
+{
+  char *p;
+  p = (char*)PGROUNDUP((uint64)pa_start);
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+    kfree(p);
+}
+
+// Free the page of physical memory pointed at by pa,
+// which normally should have been returned by a
+// call to kalloc().  (The exception is when
+// initializing the allocator; see kinit above.)
+void
+kfree(void *pa)
+{
+  struct run *r;
+
+  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+    panic("kfree");
+
+  // Fill with junk to catch dangling refs.
+  memset(pa, 1, PGSIZE);
+
+  r = (struct run*)pa;
+
+  acquire(&kmem.lock);
+  r->next = kmem.freelist;
+  kmem.freelist = r;
+  release(&kmem.lock);
+}
+
+// Allocate one 4096-byte page of physical memory.
+// Returns a pointer that the kernel can use.
+// Returns 0 if the memory cannot be allocated.
+void *
+kalloc(void)
+{
+  struct run *r;
+
+  acquire(&kmem.lock);
+  r = kmem.freelist;
+  if(r)
+    kmem.freelist = r->next;
+  release(&kmem.lock);
+
+  if(r) {
+    memset((char*)r, 5, PGSIZE); // fill with junk
+  }
+  return (void*)r;
+}
+
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..4400ea6 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -1,683 +1,697 @@
-#include "types.h"
-#include "param.h"
-#include "memlayout.h"
-#include "riscv.h"
-#include "spinlock.h"
-#include "proc.h"
-#include "defs.h"
-
-struct cpu cpus[NCPU];
-
-struct proc proc[NPROC];
-
-struct proc *initproc;
-
-int nextpid = 1;
-struct spinlock pid_lock;
-
-extern void forkret(void);
-static void freeproc(struct proc *p);
-
-extern char trampoline[]; // trampoline.S
-
-// helps ensure that wakeups of wait()ing
-// parents are not lost. helps obey the
-// memory model when using p->parent.
-// must be acquired before any p->lock.
-struct spinlock wait_lock;
-
-// Allocate a page for each process's kernel stack.
-// Map it high in memory, followed by an invalid
-// guard page.
-void
-proc_mapstacks(pagetable_t kpgtbl)
-{
-  struct proc *p;
-  
-  for(p = proc; p < &proc[NPROC]; p++) {
-    char *pa = kalloc();
-    if(pa == 0)
-      panic("kalloc");
-    uint64 va = KSTACK((int) (p - proc));
-    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
-  }
-}
-
-// initialize the proc table.
-void
-procinit(void)
-{
-  struct proc *p;
-  
-  initlock(&pid_lock, "nextpid");
-  initlock(&wait_lock, "wait_lock");
-  for(p = proc; p < &proc[NPROC]; p++) {
-      initlock(&p->lock, "proc");
-      p->state = UNUSED;
-      p->kstack = KSTACK((int) (p - proc));
-  }
-}
-
-// Must be called with interrupts disabled,
-// to prevent race with process being moved
-// to a different CPU.
-int
-cpuid()
-{
-  int id = r_tp();
-  return id;
-}
-
-// Return this CPU's cpu struct.
-// Interrupts must be disabled.
-struct cpu*
-mycpu(void)
-{
-  int id = cpuid();
-  struct cpu *c = &cpus[id];
-  return c;
-}
-
-// Return the current struct proc *, or zero if none.
-struct proc*
-myproc(void)
-{
-  push_off();
-  struct cpu *c = mycpu();
-  struct proc *p = c->proc;
-  pop_off();
-  return p;
-}
-
-int
-allocpid()
-{
-  int pid;
-  
-  acquire(&pid_lock);
-  pid = nextpid;
-  nextpid = nextpid + 1;
-  release(&pid_lock);
-
-  return pid;
-}
-
-// Look in the process table for an UNUSED proc.
-// If found, initialize state required to run in the kernel,
-// and return with p->lock held.
-// If there are no free procs, or a memory allocation fails, return 0.
-static struct proc*
-allocproc(void)
-{
-  struct proc *p;
-
-  for(p = proc; p < &proc[NPROC]; p++) {
-    acquire(&p->lock);
-    if(p->state == UNUSED) {
-      goto found;
-    } else {
-      release(&p->lock);
-    }
-  }
-  return 0;
-
-found:
-  p->pid = allocpid();
-  p->state = USED;
-
-  // Allocate a trapframe page.
-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
-    freeproc(p);
-    release(&p->lock);
-    return 0;
-  }
-
-  // An empty user page table.
-  p->pagetable = proc_pagetable(p);
-  if(p->pagetable == 0){
-    freeproc(p);
-    release(&p->lock);
-    return 0;
-  }
-
-  // Set up new context to start executing at forkret,
-  // which returns to user space.
-  memset(&p->context, 0, sizeof(p->context));
-  p->context.ra = (uint64)forkret;
-  p->context.sp = p->kstack + PGSIZE;
-
-  return p;
-}
-
-// free a proc structure and the data hanging from it,
-// including user pages.
-// p->lock must be held.
-static void
-freeproc(struct proc *p)
-{
-  if(p->trapframe)
-    kfree((void*)p->trapframe);
-  p->trapframe = 0;
-  if(p->pagetable)
-    proc_freepagetable(p->pagetable, p->sz);
-  p->pagetable = 0;
-  p->sz = 0;
-  p->pid = 0;
-  p->parent = 0;
-  p->name[0] = 0;
-  p->chan = 0;
-  p->killed = 0;
-  p->xstate = 0;
-  p->state = UNUSED;
-}
-
-// Create a user page table for a given process, with no user memory,
-// but with trampoline and trapframe pages.
-pagetable_t
-proc_pagetable(struct proc *p)
-{
-  pagetable_t pagetable;
-
-  // An empty page table.
-  pagetable = uvmcreate();
-  if(pagetable == 0)
-    return 0;
-
-  // map the trampoline code (for system call return)
-  // at the highest user virtual address.
-  // only the supervisor uses it, on the way
-  // to/from user space, so not PTE_U.
-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
-              (uint64)trampoline, PTE_R | PTE_X) < 0){
-    uvmfree(pagetable, 0);
-    return 0;
-  }
-
-  // map the trapframe page just below the trampoline page, for
-  // trampoline.S.
-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
-    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
-    uvmfree(pagetable, 0);
-    return 0;
-  }
-
-  return pagetable;
-}
-
-// Free a process's page table, and free the
-// physical memory it refers to.
-void
-proc_freepagetable(pagetable_t pagetable, uint64 sz)
-{
-  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
-  uvmunmap(pagetable, TRAPFRAME, 1, 0);
-  uvmfree(pagetable, sz);
-}
-
-// a user program that calls exec("/init")
-// assembled from ../user/initcode.S
-// od -t xC ../user/initcode
-uchar initcode[] = {
-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
-  0x00, 0x00, 0x00, 0x00
-};
-
-// Set up first user process.
-void
-userinit(void)
-{
-  struct proc *p;
-
-  p = allocproc();
-  initproc = p;
-  
-  // allocate one user page and copy initcode's instructions
-  // and data into it.
-  uvmfirst(p->pagetable, initcode, sizeof(initcode));
-  p->sz = PGSIZE;
-
-  // prepare for the very first "return" from kernel to user.
-  p->trapframe->epc = 0;      // user program counter
-  p->trapframe->sp = PGSIZE;  // user stack pointer
-
-  safestrcpy(p->name, "initcode", sizeof(p->name));
-  p->cwd = namei("/");
-
-  p->state = RUNNABLE;
-
-  release(&p->lock);
-}
-
-// Grow or shrink user memory by n bytes.
-// Return 0 on success, -1 on failure.
-int
-growproc(int n)
-{
-  uint64 sz;
-  struct proc *p = myproc();
-
-  sz = p->sz;
-  if(n > 0){
-    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
-      return -1;
-    }
-  } else if(n < 0){
-    sz = uvmdealloc(p->pagetable, sz, sz + n);
-  }
-  p->sz = sz;
-  return 0;
-}
-
-// Create a new process, copying the parent.
-// Sets up child kernel stack to return as if from fork() system call.
-int
-fork(void)
-{
-  int i, pid;
-  struct proc *np;
-  struct proc *p = myproc();
-
-  // Allocate process.
-  if((np = allocproc()) == 0){
-    return -1;
-  }
-
-  // Copy user memory from parent to child.
-  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
-    freeproc(np);
-    release(&np->lock);
-    return -1;
-  }
-  np->sz = p->sz;
-
-  // copy saved user registers.
-  *(np->trapframe) = *(p->trapframe);
-
-  // Cause fork to return 0 in the child.
-  np->trapframe->a0 = 0;
-
-  // increment reference counts on open file descriptors.
-  for(i = 0; i < NOFILE; i++)
-    if(p->ofile[i])
-      np->ofile[i] = filedup(p->ofile[i]);
-  np->cwd = idup(p->cwd);
-
-  safestrcpy(np->name, p->name, sizeof(p->name));
-
-  pid = np->pid;
-
-  release(&np->lock);
-
-  acquire(&wait_lock);
-  np->parent = p;
-  release(&wait_lock);
-
-  acquire(&np->lock);
-  np->state = RUNNABLE;
-  release(&np->lock);
-
-  return pid;
-}
-
-// Pass p's abandoned children to init.
-// Caller must hold wait_lock.
-void
-reparent(struct proc *p)
-{
-  struct proc *pp;
-
-  for(pp = proc; pp < &proc[NPROC]; pp++){
-    if(pp->parent == p){
-      pp->parent = initproc;
-      wakeup(initproc);
-    }
-  }
-}
-
-// Exit the current process.  Does not return.
-// An exited process remains in the zombie state
-// until its parent calls wait().
-void
-exit(int status)
-{
-  struct proc *p = myproc();
-
-  if(p == initproc)
-    panic("init exiting");
-
-  // Close all open files.
-  for(int fd = 0; fd < NOFILE; fd++){
-    if(p->ofile[fd]){
-      struct file *f = p->ofile[fd];
-      fileclose(f);
-      p->ofile[fd] = 0;
-    }
-  }
-
-  begin_op();
-  iput(p->cwd);
-  end_op();
-  p->cwd = 0;
-
-  acquire(&wait_lock);
-
-  // Give any children to init.
-  reparent(p);
-
-  // Parent might be sleeping in wait().
-  wakeup(p->parent);
-  
-  acquire(&p->lock);
-
-  p->xstate = status;
-  p->state = ZOMBIE;
-
-  release(&wait_lock);
-
-  // Jump into the scheduler, never to return.
-  sched();
-  panic("zombie exit");
-}
-
-// Wait for a child process to exit and return its pid.
-// Return -1 if this process has no children.
-int
-wait(uint64 addr)
-{
-  struct proc *pp;
-  int havekids, pid;
-  struct proc *p = myproc();
-
-  acquire(&wait_lock);
-
-  for(;;){
-    // Scan through table looking for exited children.
-    havekids = 0;
-    for(pp = proc; pp < &proc[NPROC]; pp++){
-      if(pp->parent == p){
-        // make sure the child isn't still in exit() or swtch().
-        acquire(&pp->lock);
-
-        havekids = 1;
-        if(pp->state == ZOMBIE){
-          // Found one.
-          pid = pp->pid;
-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
-                                  sizeof(pp->xstate)) < 0) {
-            release(&pp->lock);
-            release(&wait_lock);
-            return -1;
-          }
-          freeproc(pp);
-          release(&pp->lock);
-          release(&wait_lock);
-          return pid;
-        }
-        release(&pp->lock);
-      }
-    }
-
-    // No point waiting if we don't have any children.
-    if(!havekids || killed(p)){
-      release(&wait_lock);
-      return -1;
-    }
-    
-    // Wait for a child to exit.
-    sleep(p, &wait_lock);  //DOC: wait-sleep
-  }
-}
-
-// Per-CPU process scheduler.
-// Each CPU calls scheduler() after setting itself up.
-// Scheduler never returns.  It loops, doing:
-//  - choose a process to run.
-//  - swtch to start running that process.
-//  - eventually that process transfers control
-//    via swtch back to the scheduler.
-void
-scheduler(void)
-{
-  struct proc *p;
-  struct cpu *c = mycpu();
-  
-  c->proc = 0;
-  for(;;){
-    // Avoid deadlock by ensuring that devices can interrupt.
-    intr_on();
-
-    for(p = proc; p < &proc[NPROC]; p++) {
-      acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
-      }
-      release(&p->lock);
-    }
-  }
-}
-
-// Switch to scheduler.  Must hold only p->lock
-// and have changed proc->state. Saves and restores
-// intena because intena is a property of this
-// kernel thread, not this CPU. It should
-// be proc->intena and proc->noff, but that would
-// break in the few places where a lock is held but
-// there's no process.
-void
-sched(void)
-{
-  int intena;
-  struct proc *p = myproc();
-
-  if(!holding(&p->lock))
-    panic("sched p->lock");
-  if(mycpu()->noff != 1)
-    panic("sched locks");
-  if(p->state == RUNNING)
-    panic("sched running");
-  if(intr_get())
-    panic("sched interruptible");
-
-  intena = mycpu()->intena;
-  swtch(&p->context, &mycpu()->context);
-  mycpu()->intena = intena;
-}
-
-// Give up the CPU for one scheduling round.
-void
-yield(void)
-{
-  struct proc *p = myproc();
-  acquire(&p->lock);
-  p->state = RUNNABLE;
-  sched();
-  release(&p->lock);
-}
-
-// A fork child's very first scheduling by scheduler()
-// will swtch to forkret.
-void
-forkret(void)
-{
-  static int first = 1;
-
-  // Still holding p->lock from scheduler.
-  release(&myproc()->lock);
-
-  if (first) {
-    // File system initialization must be run in the context of a
-    // regular process (e.g., because it calls sleep), and thus cannot
-    // be run from main().
-    first = 0;
-    fsinit(ROOTDEV);
-  }
-
-  usertrapret();
-}
-
-// Atomically release lock and sleep on chan.
-// Reacquires lock when awakened.
-void
-sleep(void *chan, struct spinlock *lk)
-{
-  struct proc *p = myproc();
-  
-  // Must acquire p->lock in order to
-  // change p->state and then call sched.
-  // Once we hold p->lock, we can be
-  // guaranteed that we won't miss any wakeup
-  // (wakeup locks p->lock),
-  // so it's okay to release lk.
-
-  acquire(&p->lock);  //DOC: sleeplock1
-  release(lk);
-
-  // Go to sleep.
-  p->chan = chan;
-  p->state = SLEEPING;
-
-  sched();
-
-  // Tidy up.
-  p->chan = 0;
-
-  // Reacquire original lock.
-  release(&p->lock);
-  acquire(lk);
-}
-
-// Wake up all processes sleeping on chan.
-// Must be called without any p->lock.
-void
-wakeup(void *chan)
-{
-  struct proc *p;
-
-  for(p = proc; p < &proc[NPROC]; p++) {
-    if(p != myproc()){
-      acquire(&p->lock);
-      if(p->state == SLEEPING && p->chan == chan) {
-        p->state = RUNNABLE;
-      }
-      release(&p->lock);
-    }
-  }
-}
-
-// Kill the process with the given pid.
-// The victim won't exit until it tries to return
-// to user space (see usertrap() in trap.c).
-int
-kill(int pid)
-{
-  struct proc *p;
-
-  for(p = proc; p < &proc[NPROC]; p++){
-    acquire(&p->lock);
-    if(p->pid == pid){
-      p->killed = 1;
-      if(p->state == SLEEPING){
-        // Wake process from sleep().
-        p->state = RUNNABLE;
-      }
-      release(&p->lock);
-      return 0;
-    }
-    release(&p->lock);
-  }
-  return -1;
-}
-
-void
-setkilled(struct proc *p)
-{
-  acquire(&p->lock);
-  p->killed = 1;
-  release(&p->lock);
-}
-
-int
-killed(struct proc *p)
-{
-  int k;
-  
-  acquire(&p->lock);
-  k = p->killed;
-  release(&p->lock);
-  return k;
-}
-
-// Copy to either a user address, or kernel address,
-// depending on usr_dst.
-// Returns 0 on success, -1 on error.
-int
-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
-{
-  struct proc *p = myproc();
-  if(user_dst){
-    return copyout(p->pagetable, dst, src, len);
-  } else {
-    memmove((char *)dst, src, len);
-    return 0;
-  }
-}
-
-// Copy from either a user address, or kernel address,
-// depending on usr_src.
-// Returns 0 on success, -1 on error.
-int
-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
-{
-  struct proc *p = myproc();
-  if(user_src){
-    return copyin(p->pagetable, dst, src, len);
-  } else {
-    memmove(dst, (char*)src, len);
-    return 0;
-  }
-}
-
-// Print a process listing to console.  For debugging.
-// Runs when user types ^P on console.
-// No lock to avoid wedging a stuck machine further.
-void
-procdump(void)
-{
-  static char *states[] = {
-  [UNUSED]    "unused",
-  [USED]      "used",
-  [SLEEPING]  "sleep ",
-  [RUNNABLE]  "runble",
-  [RUNNING]   "run   ",
-  [ZOMBIE]    "zombie"
-  };
-  struct proc *p;
-  char *state;
-
-  printf("\n");
-  for(p = proc; p < &proc[NPROC]; p++){
-    if(p->state == UNUSED)
-      continue;
-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
-      state = states[p->state];
-    else
-      state = "???";
-    printf("%d %s %s", p->pid, state, p->name);
-    printf("\n");
-  }
-}
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "riscv.h"
+#include "swap.h"
+#include "proc.h"
+#include "defs.h"
+
+struct user_page_alloc_flag user_alloc_flag;
+
+struct cpu cpus[NCPU];
+
+struct proc proc[NPROC];
+
+struct proc *initproc;
+
+int nextpid = 1;
+struct spinlock pid_lock;
+
+extern void forkret(void);
+static void freeproc(struct proc *p);
+
+extern char trampoline[]; // trampoline.S
+
+// helps ensure that wakeups of wait()ing
+// parents are not lost. helps obey the
+// memory model when using p->parent.
+// must be acquired before any p->lock.
+struct spinlock wait_lock;
+
+// Allocate a page for each process's kernel stack.
+// Map it high in memory, followed by an invalid
+// guard page.
+void
+proc_mapstacks(pagetable_t kpgtbl)
+{
+  struct proc *p;
+  
+  for(p = proc; p < &proc[NPROC]; p++) {
+    char *pa = kalloc();
+    if(pa == 0)
+      panic("kalloc");
+    uint64 va = KSTACK((int) (p - proc));
+    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+  }
+}
+
+// initialize the proc table.
+void
+procinit(void)
+{
+  struct proc *p;
+  
+  initlock(&pid_lock, "nextpid");
+  initlock(&wait_lock, "wait_lock");
+  for(p = proc; p < &proc[NPROC]; p++) {
+      initlock(&p->lock, "proc");
+      p->state = UNUSED;
+      p->kstack = KSTACK((int) (p - proc));
+  }
+}
+
+// Must be called with interrupts disabled,
+// to prevent race with process being moved
+// to a different CPU.
+int
+cpuid()
+{
+  int id = r_tp();
+  return id;
+}
+
+// Return this CPU's cpu struct.
+// Interrupts must be disabled.
+struct cpu*
+mycpu(void)
+{
+  int id = cpuid();
+  struct cpu *c = &cpus[id];
+  return c;
+}
+
+// Return the current struct proc *, or zero if none.
+struct proc*
+myproc(void)
+{
+  push_off();
+  struct cpu *c = mycpu();
+  struct proc *p = c->proc;
+  pop_off();
+  return p;
+}
+
+int
+allocpid()
+{
+  int pid;
+  
+  acquire(&pid_lock);
+  pid = nextpid;
+  nextpid = nextpid + 1;
+  release(&pid_lock);
+
+  return pid;
+}
+
+// Look in the process table for an UNUSED proc.
+// If found, initialize state required to run in the kernel,
+// and return with p->lock held.
+// If there are no free procs, or a memory allocation fails, return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    acquire(&p->lock);
+    if(p->state == UNUSED) {
+      goto found;
+    } else {
+      release(&p->lock);
+    }
+  }
+  return 0;
+
+found:
+  p->pid = allocpid();
+  p->state = USED;
+
+  // Allocate a trapframe page.
+  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // An empty user page table.
+  p->pagetable = proc_pagetable(p);
+  if(p->pagetable == 0){
+    freeproc(p);
+    release(&p->lock);
+    return 0;
+  }
+
+  // Set up new context to start executing at forkret,
+  // which returns to user space.
+  memset(&p->context, 0, sizeof(p->context));
+  p->context.ra = (uint64)forkret;
+  p->context.sp = p->kstack + PGSIZE;
+
+  return p;
+}
+
+// free a proc structure and the data hanging from it,
+// including user pages.
+// p->lock must be held.
+static void
+freeproc(struct proc *p)
+{
+  if(p->trapframe)
+    kfree((void*)p->trapframe);
+  p->trapframe = 0;
+  if(p->pagetable)
+    proc_freepagetable(p->pagetable, p->sz);
+  p->pagetable = 0;
+  p->sz = 0;
+  p->pid = 0;
+  p->parent = 0;
+  p->name[0] = 0;
+  p->chan = 0;
+  p->killed = 0;
+  p->xstate = 0;
+  p->state = UNUSED;
+}
+
+// Create a user page table for a given process, with no user memory,
+// but with trampoline and trapframe pages.
+pagetable_t
+proc_pagetable(struct proc *p)
+{
+  pagetable_t pagetable;
+
+  // An empty page table.
+  pagetable = uvmcreate();
+  if(pagetable == 0)
+    return 0;
+
+  // map the trampoline code (for system call return)
+  // at the highest user virtual address.
+  // only the supervisor uses it, on the way
+  // to/from user space, so not PTE_U.
+  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
+              (uint64)trampoline, PTE_R | PTE_X) < 0){
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
+  // map the trapframe page just below the trampoline page, for
+  // trampoline.S.
+  if(mappages(pagetable, TRAPFRAME, PGSIZE,
+              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+    uvmfree(pagetable, 0);
+    return 0;
+  }
+
+  return pagetable;
+}
+
+// Free a process's page table, and free the
+// physical memory it refers to.
+void
+proc_freepagetable(pagetable_t pagetable, uint64 sz)
+{
+  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  uvmfree(pagetable, sz);
+}
+
+// a user program that calls exec("/init")
+// assembled from ../user/initcode.S
+// od -t xC ../user/initcode
+uchar initcode[] = {
+  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
+  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
+  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
+  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
+  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
+  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00
+};
+
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+
+  p = allocproc();
+  initproc = p;
+  
+  // allocate one user page and copy initcode's instructions
+  // and data into it.
+  uvmfirst(p->pagetable, initcode, sizeof(initcode));
+  p->sz = PGSIZE;
+
+  // prepare for the very first "return" from kernel to user.
+  p->trapframe->epc = 0;      // user program counter
+  p->trapframe->sp = PGSIZE;  // user stack pointer
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+
+  release(&p->lock);
+}
+
+// Grow or shrink user memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint64 sz;
+  struct proc *p = myproc();
+
+  sz = p->sz;
+  
+  if(n > 0){
+    acquire(&user_alloc_flag.lock);
+    user_alloc_flag.flag = 1;
+    release(&user_alloc_flag.lock);
+    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+      return -1;
+    }
+  } else if(n < 0){
+    sz = uvmdealloc(p->pagetable, sz, sz + n);
+  }
+  p->sz = sz;
+  return 0;
+}
+
+// Create a new process, copying the parent.
+// Sets up child kernel stack to return as if from fork() system call.
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
+
+  // Copy user memory from parent to child.
+    release(&np->lock);
+  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+    freeproc(np);
+    return -1;
+  }
+  acquire(&np->lock);
+  np->sz = p->sz;
+
+  // copy saved user registers.
+  *(np->trapframe) = *(p->trapframe);
+
+  // Cause fork to return 0 in the child.
+  np->trapframe->a0 = 0;
+
+  // increment reference counts on open file descriptors.
+  for(i = 0; i < NOFILE; i++)
+    if(p->ofile[i])
+      np->ofile[i] = filedup(p->ofile[i]);
+  np->cwd = idup(p->cwd);
+
+  safestrcpy(np->name, p->name, sizeof(p->name));
+
+  pid = np->pid;
+
+  release(&np->lock);
+
+  acquire(&wait_lock);
+  np->parent = p;
+  release(&wait_lock);
+
+  acquire(&np->lock);
+  np->state = RUNNABLE;
+  release(&np->lock);
+
+  return pid;
+}
+
+// Pass p's abandoned children to init.
+// Caller must hold wait_lock.
+void
+reparent(struct proc *p)
+{
+  struct proc *pp;
+
+  for(pp = proc; pp < &proc[NPROC]; pp++){
+    if(pp->parent == p){
+      pp->parent = initproc;
+      wakeup(initproc);
+    }
+  }
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait().
+void
+exit(int status)
+{
+  struct proc *p = myproc();
+
+  if(p == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(int fd = 0; fd < NOFILE; fd++){
+    if(p->ofile[fd]){
+      struct file *f = p->ofile[fd];
+      fileclose(f);
+      p->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(p->cwd);
+  end_op();
+  p->cwd = 0;
+
+  acquire(&wait_lock);
+  // Give any children to init.
+  reparent(p);
+
+  // Parent might be sleeping in wait().
+  wakeup(p->parent);
+  
+  acquire(&p->lock);
+
+  p->xstate = status;
+  p->state = ZOMBIE;
+
+  release(&wait_lock);
+
+  // Jump into the scheduler, never to return.
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(uint64 addr)
+{
+  struct proc *pp;
+  int havekids, pid;
+  struct proc *p = myproc();
+
+  acquire(&wait_lock);
+
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+      if(pp->parent == p){
+        // make sure the child isn't still in exit() or swtch().
+        acquire(&pp->lock);
+
+        havekids = 1;
+        if(pp->state == ZOMBIE){
+          // Found one.
+          pid = pp->pid;
+          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+                                  sizeof(pp->xstate)) < 0) {
+            release(&pp->lock);
+            release(&wait_lock);
+
+            return -1;
+          }
+          // freeproc(pp);
+          release(&pp->lock);
+          release(&wait_lock);
+
+          /* crazy stuff*/
+          //printf("freeproc starting\n");
+          freeproc(pp);
+          //printf("freeproc ended\n");
+          
+          return pid;
+        }
+        release(&pp->lock);
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || killed(p)){
+      release(&wait_lock);
+      return -1;
+    }
+    
+    // Wait for a child to exit.
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+  }
+}
+
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run.
+//  - swtch to start running that process.
+//  - eventually that process transfers control
+//    via swtch back to the scheduler.
+void
+scheduler(void)
+{
+  struct proc *p;
+  struct cpu *c = mycpu();
+  
+  c->proc = 0;
+  for(;;){
+    // Avoid deadlock by ensuring that devices can interrupt.
+    intr_on();
+
+    for(p = proc; p < &proc[NPROC]; p++) {
+      acquire(&p->lock);
+      if(p->state == RUNNABLE) {
+        // Switch to chosen process.  It is the process's job
+        // to release its lock and then reacquire it
+        // before jumping back to us.
+        p->state = RUNNING;
+        c->proc = p;
+        swtch(&c->context, &p->context);
+
+        // Process is done running for now.
+        // It should have changed its p->state before coming back.
+        c->proc = 0;
+      }
+      release(&p->lock);
+    }
+  }
+}
+
+// Switch to scheduler.  Must hold only p->lock
+// and have changed proc->state. Saves and restores
+// intena because intena is a property of this
+// kernel thread, not this CPU. It should
+// be proc->intena and proc->noff, but that would
+// break in the few places where a lock is held but
+// there's no process.
+void
+sched(void)
+{
+  int intena;
+  struct proc *p = myproc();
+
+  if(!holding(&p->lock))
+    panic("sched p->lock");
+  if(mycpu()->noff != 1)
+    panic("sched locks");
+  if(p->state == RUNNING)
+    panic("sched running");
+  if(intr_get())
+    panic("sched interruptible");
+
+  intena = mycpu()->intena;
+  swtch(&p->context, &mycpu()->context);
+  mycpu()->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  struct proc *p = myproc();
+  acquire(&p->lock);
+  p->state = RUNNABLE;
+  sched();
+  release(&p->lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch to forkret.
+void
+forkret(void)
+{
+  static int first = 1;
+
+  // Still holding p->lock from scheduler.
+  release(&myproc()->lock);
+
+  if (first) {
+    // File system initialization must be run in the context of a
+    // regular process (e.g., because it calls sleep), and thus cannot
+    // be run from main().
+    first = 0;
+    fsinit(ROOTDEV);
+  }
+
+  usertrapret();
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  struct proc *p = myproc();
+  
+  // Must acquire p->lock in order to
+  // change p->state and then call sched.
+  // Once we hold p->lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup locks p->lock),
+  // so it's okay to release lk.
+
+  acquire(&p->lock);  //DOC: sleeplock1
+  release(lk);
+
+  // Go to sleep.
+  p->chan = chan;
+  p->state = SLEEPING;
+
+  sched();
+
+  // Tidy up.
+  p->chan = 0;
+
+  // Reacquire original lock.
+  release(&p->lock);
+  acquire(lk);
+}
+
+// Wake up all processes sleeping on chan.
+// Must be called without any p->lock.
+void
+wakeup(void *chan)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++) {
+    if(p != myproc()){
+      // printf("lock process %d\n", p->pid);
+      acquire(&p->lock);
+      if(p->state == SLEEPING && p->chan == chan) {
+        p->state = RUNNABLE;
+      }
+      release(&p->lock);
+    }
+  }
+}
+
+// Kill the process with the given pid.
+// The victim won't exit until it tries to return
+// to user space (see usertrap() in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  for(p = proc; p < &proc[NPROC]; p++){
+    acquire(&p->lock);
+    if(p->pid == pid){
+      p->killed = 1;
+      if(p->state == SLEEPING){
+        // Wake process from sleep().
+        p->state = RUNNABLE;
+      }
+      release(&p->lock);
+      return 0;
+    }
+    release(&p->lock);
+  }
+  return -1;
+}
+
+void
+setkilled(struct proc *p)
+{
+  acquire(&p->lock);
+  p->killed = 1;
+  release(&p->lock);
+}
+
+int
+killed(struct proc *p)
+{
+  int k;
+  
+  acquire(&p->lock);
+  k = p->killed;
+  release(&p->lock);
+  return k;
+}
+
+// Copy to either a user address, or kernel address,
+// depending on usr_dst.
+// Returns 0 on success, -1 on error.
+int
+either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+{
+  struct proc *p = myproc();
+  if(user_dst){
+    return copyout(p->pagetable, dst, src, len);
+  } else {
+    memmove((char *)dst, src, len);
+    return 0;
+  }
+}
+
+// Copy from either a user address, or kernel address,
+// depending on usr_src.
+// Returns 0 on success, -1 on error.
+int
+either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+{
+  struct proc *p = myproc();
+  if(user_src){
+    return copyin(p->pagetable, dst, src, len);
+  } else {
+    memmove(dst, (char*)src, len);
+    return 0;
+  }
+}
+
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [USED]      "used",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  struct proc *p;
+  char *state;
+
+  printf("\n");
+  for(p = proc; p < &proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    printf("%d %s %s", p->pid, state, p->name);
+    printf("\n");
+  }
+}
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..636bc4b 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -1,363 +1,368 @@
-#ifndef __ASSEMBLER__
-
-// which hart (core) is this?
-static inline uint64
-r_mhartid()
-{
-  uint64 x;
-  asm volatile("csrr %0, mhartid" : "=r" (x) );
-  return x;
-}
-
-// Machine Status Register, mstatus
-
-#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
-#define MSTATUS_MPP_M (3L << 11)
-#define MSTATUS_MPP_S (1L << 11)
-#define MSTATUS_MPP_U (0L << 11)
-#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
-
-static inline uint64
-r_mstatus()
-{
-  uint64 x;
-  asm volatile("csrr %0, mstatus" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_mstatus(uint64 x)
-{
-  asm volatile("csrw mstatus, %0" : : "r" (x));
-}
-
-// machine exception program counter, holds the
-// instruction address to which a return from
-// exception will go.
-static inline void 
-w_mepc(uint64 x)
-{
-  asm volatile("csrw mepc, %0" : : "r" (x));
-}
-
-// Supervisor Status Register, sstatus
-
-#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
-#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
-#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
-#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
-#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
-
-static inline uint64
-r_sstatus()
-{
-  uint64 x;
-  asm volatile("csrr %0, sstatus" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_sstatus(uint64 x)
-{
-  asm volatile("csrw sstatus, %0" : : "r" (x));
-}
-
-// Supervisor Interrupt Pending
-static inline uint64
-r_sip()
-{
-  uint64 x;
-  asm volatile("csrr %0, sip" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_sip(uint64 x)
-{
-  asm volatile("csrw sip, %0" : : "r" (x));
-}
-
-// Supervisor Interrupt Enable
-#define SIE_SEIE (1L << 9) // external
-#define SIE_STIE (1L << 5) // timer
-#define SIE_SSIE (1L << 1) // software
-static inline uint64
-r_sie()
-{
-  uint64 x;
-  asm volatile("csrr %0, sie" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_sie(uint64 x)
-{
-  asm volatile("csrw sie, %0" : : "r" (x));
-}
-
-// Machine-mode Interrupt Enable
-#define MIE_MEIE (1L << 11) // external
-#define MIE_MTIE (1L << 7)  // timer
-#define MIE_MSIE (1L << 3)  // software
-static inline uint64
-r_mie()
-{
-  uint64 x;
-  asm volatile("csrr %0, mie" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_mie(uint64 x)
-{
-  asm volatile("csrw mie, %0" : : "r" (x));
-}
-
-// supervisor exception program counter, holds the
-// instruction address to which a return from
-// exception will go.
-static inline void 
-w_sepc(uint64 x)
-{
-  asm volatile("csrw sepc, %0" : : "r" (x));
-}
-
-static inline uint64
-r_sepc()
-{
-  uint64 x;
-  asm volatile("csrr %0, sepc" : "=r" (x) );
-  return x;
-}
-
-// Machine Exception Delegation
-static inline uint64
-r_medeleg()
-{
-  uint64 x;
-  asm volatile("csrr %0, medeleg" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_medeleg(uint64 x)
-{
-  asm volatile("csrw medeleg, %0" : : "r" (x));
-}
-
-// Machine Interrupt Delegation
-static inline uint64
-r_mideleg()
-{
-  uint64 x;
-  asm volatile("csrr %0, mideleg" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_mideleg(uint64 x)
-{
-  asm volatile("csrw mideleg, %0" : : "r" (x));
-}
-
-// Supervisor Trap-Vector Base Address
-// low two bits are mode.
-static inline void 
-w_stvec(uint64 x)
-{
-  asm volatile("csrw stvec, %0" : : "r" (x));
-}
-
-static inline uint64
-r_stvec()
-{
-  uint64 x;
-  asm volatile("csrr %0, stvec" : "=r" (x) );
-  return x;
-}
-
-// Machine-mode interrupt vector
-static inline void 
-w_mtvec(uint64 x)
-{
-  asm volatile("csrw mtvec, %0" : : "r" (x));
-}
-
-// Physical Memory Protection
-static inline void
-w_pmpcfg0(uint64 x)
-{
-  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
-}
-
-static inline void
-w_pmpaddr0(uint64 x)
-{
-  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
-}
-
-// use riscv's sv39 page table scheme.
-#define SATP_SV39 (8L << 60)
-
-#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
-
-// supervisor address translation and protection;
-// holds the address of the page table.
-static inline void 
-w_satp(uint64 x)
-{
-  asm volatile("csrw satp, %0" : : "r" (x));
-}
-
-static inline uint64
-r_satp()
-{
-  uint64 x;
-  asm volatile("csrr %0, satp" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_mscratch(uint64 x)
-{
-  asm volatile("csrw mscratch, %0" : : "r" (x));
-}
-
-// Supervisor Trap Cause
-static inline uint64
-r_scause()
-{
-  uint64 x;
-  asm volatile("csrr %0, scause" : "=r" (x) );
-  return x;
-}
-
-// Supervisor Trap Value
-static inline uint64
-r_stval()
-{
-  uint64 x;
-  asm volatile("csrr %0, stval" : "=r" (x) );
-  return x;
-}
-
-// Machine-mode Counter-Enable
-static inline void 
-w_mcounteren(uint64 x)
-{
-  asm volatile("csrw mcounteren, %0" : : "r" (x));
-}
-
-static inline uint64
-r_mcounteren()
-{
-  uint64 x;
-  asm volatile("csrr %0, mcounteren" : "=r" (x) );
-  return x;
-}
-
-// machine-mode cycle counter
-static inline uint64
-r_time()
-{
-  uint64 x;
-  asm volatile("csrr %0, time" : "=r" (x) );
-  return x;
-}
-
-// enable device interrupts
-static inline void
-intr_on()
-{
-  w_sstatus(r_sstatus() | SSTATUS_SIE);
-}
-
-// disable device interrupts
-static inline void
-intr_off()
-{
-  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
-}
-
-// are device interrupts enabled?
-static inline int
-intr_get()
-{
-  uint64 x = r_sstatus();
-  return (x & SSTATUS_SIE) != 0;
-}
-
-static inline uint64
-r_sp()
-{
-  uint64 x;
-  asm volatile("mv %0, sp" : "=r" (x) );
-  return x;
-}
-
-// read and write tp, the thread pointer, which xv6 uses to hold
-// this core's hartid (core number), the index into cpus[].
-static inline uint64
-r_tp()
-{
-  uint64 x;
-  asm volatile("mv %0, tp" : "=r" (x) );
-  return x;
-}
-
-static inline void 
-w_tp(uint64 x)
-{
-  asm volatile("mv tp, %0" : : "r" (x));
-}
-
-static inline uint64
-r_ra()
-{
-  uint64 x;
-  asm volatile("mv %0, ra" : "=r" (x) );
-  return x;
-}
-
-// flush the TLB.
-static inline void
-sfence_vma()
-{
-  // the zero, zero means flush all TLB entries.
-  asm volatile("sfence.vma zero, zero");
-}
-
-typedef uint64 pte_t;
-typedef uint64 *pagetable_t; // 512 PTEs
-
-#endif // __ASSEMBLER__
-
-#define PGSIZE 4096 // bytes per page
-#define PGSHIFT 12  // bits of offset within a page
-
-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
-
-#define PTE_V (1L << 0) // valid
-#define PTE_R (1L << 1)
-#define PTE_W (1L << 2)
-#define PTE_X (1L << 3)
-#define PTE_U (1L << 4) // user can access
-
-// shift a physical address to the right place for a PTE.
-#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
-
-#define PTE2PA(pte) (((pte) >> 10) << 12)
-
-#define PTE_FLAGS(pte) ((pte) & 0x3FF)
-
-// extract the three 9-bit page table indices from a virtual address.
-#define PXMASK          0x1FF // 9 bits
-#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
-#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
-
-// one beyond the highest possible virtual address.
-// MAXVA is actually one bit less than the max allowed by
-// Sv39, to avoid having to sign-extend virtual addresses
-// that have the high bit set.
-#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
+#ifndef __ASSEMBLER__
+
+// which hart (core) is this?
+static inline uint64
+r_mhartid()
+{
+  uint64 x;
+  asm volatile("csrr %0, mhartid" : "=r" (x) );
+  return x;
+}
+
+// Machine Status Register, mstatus
+
+#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
+#define MSTATUS_MPP_M (3L << 11)
+#define MSTATUS_MPP_S (1L << 11)
+#define MSTATUS_MPP_U (0L << 11)
+#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
+
+static inline uint64
+r_mstatus()
+{
+  uint64 x;
+  asm volatile("csrr %0, mstatus" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_mstatus(uint64 x)
+{
+  asm volatile("csrw mstatus, %0" : : "r" (x));
+}
+
+// machine exception program counter, holds the
+// instruction address to which a return from
+// exception will go.
+static inline void 
+w_mepc(uint64 x)
+{
+  asm volatile("csrw mepc, %0" : : "r" (x));
+}
+
+// Supervisor Status Register, sstatus
+
+#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
+#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
+#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
+#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
+#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
+
+static inline uint64
+r_sstatus()
+{
+  uint64 x;
+  asm volatile("csrr %0, sstatus" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_sstatus(uint64 x)
+{
+  asm volatile("csrw sstatus, %0" : : "r" (x));
+}
+
+// Supervisor Interrupt Pending
+static inline uint64
+r_sip()
+{
+  uint64 x;
+  asm volatile("csrr %0, sip" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_sip(uint64 x)
+{
+  asm volatile("csrw sip, %0" : : "r" (x));
+}
+
+// Supervisor Interrupt Enable
+#define SIE_SEIE (1L << 9) // external
+#define SIE_STIE (1L << 5) // timer
+#define SIE_SSIE (1L << 1) // software
+static inline uint64
+r_sie()
+{
+  uint64 x;
+  asm volatile("csrr %0, sie" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_sie(uint64 x)
+{
+  asm volatile("csrw sie, %0" : : "r" (x));
+}
+
+// Machine-mode Interrupt Enable
+#define MIE_MEIE (1L << 11) // external
+#define MIE_MTIE (1L << 7)  // timer
+#define MIE_MSIE (1L << 3)  // software
+static inline uint64
+r_mie()
+{
+  uint64 x;
+  asm volatile("csrr %0, mie" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_mie(uint64 x)
+{
+  asm volatile("csrw mie, %0" : : "r" (x));
+}
+
+// supervisor exception program counter, holds the
+// instruction address to which a return from
+// exception will go.
+static inline void 
+w_sepc(uint64 x)
+{
+  asm volatile("csrw sepc, %0" : : "r" (x));
+}
+
+static inline uint64
+r_sepc()
+{
+  uint64 x;
+  asm volatile("csrr %0, sepc" : "=r" (x) );
+  return x;
+}
+
+// Machine Exception Delegation
+static inline uint64
+r_medeleg()
+{
+  uint64 x;
+  asm volatile("csrr %0, medeleg" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_medeleg(uint64 x)
+{
+  asm volatile("csrw medeleg, %0" : : "r" (x));
+}
+
+// Machine Interrupt Delegation
+static inline uint64
+r_mideleg()
+{
+  uint64 x;
+  asm volatile("csrr %0, mideleg" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_mideleg(uint64 x)
+{
+  asm volatile("csrw mideleg, %0" : : "r" (x));
+}
+
+// Supervisor Trap-Vector Base Address
+// low two bits are mode.
+static inline void 
+w_stvec(uint64 x)
+{
+  asm volatile("csrw stvec, %0" : : "r" (x));
+}
+
+static inline uint64
+r_stvec()
+{
+  uint64 x;
+  asm volatile("csrr %0, stvec" : "=r" (x) );
+  return x;
+}
+
+// Machine-mode interrupt vector
+static inline void 
+w_mtvec(uint64 x)
+{
+  asm volatile("csrw mtvec, %0" : : "r" (x));
+}
+
+// Physical Memory Protection
+static inline void
+w_pmpcfg0(uint64 x)
+{
+  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
+}
+
+static inline void
+w_pmpaddr0(uint64 x)
+{
+  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
+}
+
+// use riscv's sv39 page table scheme.
+#define SATP_SV39 (8L << 60)
+
+#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
+
+// supervisor address translation and protection;
+// holds the address of the page table.
+static inline void 
+w_satp(uint64 x)
+{
+  asm volatile("csrw satp, %0" : : "r" (x));
+}
+
+static inline uint64
+r_satp()
+{
+  uint64 x;
+  asm volatile("csrr %0, satp" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_mscratch(uint64 x)
+{
+  asm volatile("csrw mscratch, %0" : : "r" (x));
+}
+
+// Supervisor Trap Cause
+static inline uint64
+r_scause()
+{
+  uint64 x;
+  asm volatile("csrr %0, scause" : "=r" (x) );
+  return x;
+}
+
+// Supervisor Trap Value
+static inline uint64
+r_stval()
+{
+  uint64 x;
+  asm volatile("csrr %0, stval" : "=r" (x) );
+  return x;
+}
+
+// Machine-mode Counter-Enable
+static inline void 
+w_mcounteren(uint64 x)
+{
+  asm volatile("csrw mcounteren, %0" : : "r" (x));
+}
+
+static inline uint64
+r_mcounteren()
+{
+  uint64 x;
+  asm volatile("csrr %0, mcounteren" : "=r" (x) );
+  return x;
+}
+
+// machine-mode cycle counter
+static inline uint64
+r_time()
+{
+  uint64 x;
+  asm volatile("csrr %0, time" : "=r" (x) );
+  return x;
+}
+
+// enable device interrupts
+static inline void
+intr_on()
+{
+  w_sstatus(r_sstatus() | SSTATUS_SIE);
+}
+
+// disable device interrupts
+static inline void
+intr_off()
+{
+  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+}
+
+// are device interrupts enabled?
+static inline int
+intr_get()
+{
+  uint64 x = r_sstatus();
+  return (x & SSTATUS_SIE) != 0;
+}
+
+static inline uint64
+r_sp()
+{
+  uint64 x;
+  asm volatile("mv %0, sp" : "=r" (x) );
+  return x;
+}
+
+// read and write tp, the thread pointer, which xv6 uses to hold
+// this core's hartid (core number), the index into cpus[].
+static inline uint64
+r_tp()
+{
+  uint64 x;
+  asm volatile("mv %0, tp" : "=r" (x) );
+  return x;
+}
+
+static inline void 
+w_tp(uint64 x)
+{
+  asm volatile("mv tp, %0" : : "r" (x));
+}
+
+static inline uint64
+r_ra()
+{
+  uint64 x;
+  asm volatile("mv %0, ra" : "=r" (x) );
+  return x;
+}
+
+// flush the TLB.
+static inline void
+sfence_vma()
+{
+  // the zero, zero means flush all TLB entries.
+  asm volatile("sfence.vma zero, zero");
+}
+
+typedef uint64 pte_t;
+typedef uint64 *pagetable_t; // 512 PTEs
+
+#endif // __ASSEMBLER__
+
+#define PGSIZE 4096 // bytes per page
+#define PGSHIFT 12  // bits of offset within a page
+
+#define MAXPHYPAGES 50
+
+#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+
+#define PTE_V (1L << 0) // valid
+#define PTE_R (1L << 1)
+#define PTE_W (1L << 2)
+#define PTE_X (1L << 3)
+#define PTE_U (1L << 4) // user can access
+
+#define PTE_COW (1L << 8)
+#define PTE_SWAP (1L << 9)
+
+// shift a physical address to the right place for a PTE.
+#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
+
+#define PTE2PA(pte) (((pte) >> 10) << 12)
+
+#define PTE_FLAGS(pte) ((pte) & 0x3FF)
+
+// extract the three 9-bit page table indices from a virtual address.
+#define PXMASK          0x1FF // 9 bits
+#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
+#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
+
+// one beyond the highest possible virtual address.
+// MAXVA is actually one bit less than the max allowed by
+// Sv39, to avoid having to sign-extend virtual addresses
+// that have the high bit set.
+#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
diff --git a/kernel/swap.c b/kernel/swap.c
new file mode 100644
index 0000000..2122326
--- /dev/null
+++ b/kernel/swap.c
@@ -0,0 +1,155 @@
+#include "types.h"
+#include "riscv.h"
+#include "fs.h"
+#include "swap.h"
+#include "defs.h"
+#include "param.h"
+#include "proc.h"
+// #include "sleeplock.h"
+#include "buf.h"
+
+#define NBLOCKPERPAGE (PGSIZE / BSIZE)
+
+struct swapped_vpn {
+  uint64 vpn;
+};
+
+struct swap {
+  uint blocknos[NBLOCKPERPAGE];
+};
+
+struct swapped_pages {
+  struct swap swapped_block;
+  struct live page_info;
+  struct swapped_pages *next;
+};
+
+struct run {
+  struct run *next;
+};
+
+struct {
+  struct spinlock lock;
+  struct run *freelist;
+} swapmem;
+
+// Initialize swapmem
+void
+swapinit(void)
+{
+  initlock(&swapmem.lock, "swapmem");
+  swapmem.freelist = 0;
+}
+
+// Allocate one swap struct.
+// Returns a pointer to the swap struct.
+// Returns 0 if the memory cannot be allocated.
+struct swap *
+swapalloc(void)
+{
+  struct run *r;
+  struct swap *s;
+
+  acquire(&swapmem.lock);
+  r = swapmem.freelist;
+  if(!r){
+    release(&swapmem.lock);
+    char *mem = kalloc();
+    char *mem_end = mem + PGSIZE;
+    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
+      r = (struct run*)mem;
+
+      acquire(&swapmem.lock);
+      r->next = swapmem.freelist;
+      swapmem.freelist = r;
+      release(&swapmem.lock);
+    }
+    acquire(&swapmem.lock);
+    r = swapmem.freelist;
+  }
+  swapmem.freelist = r->next;
+  release(&swapmem.lock);
+  
+  s = (struct swap*)r;
+  if(s)
+    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
+  
+  return s;
+}
+
+// Free the swap struct pointed by s, and the blocks
+// contained in s, which normally should have been returned
+// by a call to swapalloc() and swapout().
+void
+swapfree(struct swap *s)
+{
+  // printf("inside swapfree\n");
+  uint *blockno;
+  struct run *r;
+
+  if(!s)
+    panic("swapfree");
+  
+  begin_op();
+  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
+    if(*blockno)
+      bfree(ROOTDEV, *blockno);
+  }
+  end_op();
+
+  r = (struct run*)s;
+
+  acquire(&swapmem.lock);
+  r->next = swapmem.freelist;
+  swapmem.freelist = r;
+  release(&swapmem.lock);
+  // printf("exiting swapfree\n");
+}
+
+// Swap out a given physical page src_pa to disk.
+// The metadata for retriving src_pa will be saved
+// to dst_pa which normally should have been returned
+// by a call to swapalloc().
+void
+swapout(struct swap *dst_sp, char *src_pa)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  begin_op();
+  // printf("crossed begin op\n");
+  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
+    // printf("before balloc %d\n", myproc()->pid);
+    *blockno = balloc(ROOTDEV);
+    if(*blockno == 0)
+      panic("swapout");
+    // printf("before bread\n");
+    bp = bread(ROOTDEV, *blockno);
+    // printf("before memmove\n");
+    memmove(bp->data, src_pa, BSIZE);
+    // printf("before log\n");
+    log_write(bp);
+    // printf("after log\n");
+    brelse(bp);
+    
+  }
+  end_op();
+}
+
+// Swap in a page into dst_pa from disk using src_sp.
+// src_sp should normally be updated with metadata
+// for retriving the page by a call to swapout().
+void
+swapin(char *dst_pa, struct swap *src_sp)
+{
+  uint *blockno;
+  struct buf *bp;
+  
+  if(!dst_pa)
+    panic("swapin");
+  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
+    bp = bread(ROOTDEV, *blockno);
+    memmove(dst_pa, bp->data, BSIZE);
+    brelse(bp);
+  }
+}
diff --git a/kernel/swap.h b/kernel/swap.h
new file mode 100644
index 0000000..3d5e666
--- /dev/null
+++ b/kernel/swap.h
@@ -0,0 +1,25 @@
+#ifndef _swap_h_
+#define _swap_h_
+
+#include "types.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "defs.h"
+
+struct user_page_alloc_flag {
+  struct spinlock lock;
+  int flag;
+};
+struct live{
+  uint64 vpn;
+  uint64 pa;
+  pagetable_t pagetable;
+};
+
+struct live_page_list {
+  int size;
+  struct spinlock lock;
+  struct live elem[MAXPHYPAGES];
+};
+
+#endif
\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..b6f69dd 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_livepagestat(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +127,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_livepagestat] sys_livepagestat,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..14cddfb 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_livepagestat 22
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..1a83800 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -89,3 +89,10 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_livepagestat(void)
+{
+  print_live_count();
+  return 0;
+}
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..9c4d4cf 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -1,221 +1,262 @@
-#include "types.h"
-#include "param.h"
-#include "memlayout.h"
-#include "riscv.h"
-#include "spinlock.h"
-#include "proc.h"
-#include "defs.h"
-
-struct spinlock tickslock;
-uint ticks;
-
-extern char trampoline[], uservec[], userret[];
-
-// in kernelvec.S, calls kerneltrap().
-void kernelvec();
-
-extern int devintr();
-
-void
-trapinit(void)
-{
-  initlock(&tickslock, "time");
-}
-
-// set up to take exceptions and traps while in the kernel.
-void
-trapinithart(void)
-{
-  w_stvec((uint64)kernelvec);
-}
-
-//
-// handle an interrupt, exception, or system call from user space.
-// called from trampoline.S
-//
-void
-usertrap(void)
-{
-  int which_dev = 0;
-
-  if((r_sstatus() & SSTATUS_SPP) != 0)
-    panic("usertrap: not from user mode");
-
-  // send interrupts and exceptions to kerneltrap(),
-  // since we're now in the kernel.
-  w_stvec((uint64)kernelvec);
-
-  struct proc *p = myproc();
-  
-  // save user program counter.
-  p->trapframe->epc = r_sepc();
-  
-  if(r_scause() == 8){
-    // system call
-
-    if(killed(p))
-      exit(-1);
-
-    // sepc points to the ecall instruction,
-    // but we want to return to the next instruction.
-    p->trapframe->epc += 4;
-
-    // an interrupt will change sepc, scause, and sstatus,
-    // so enable only now that we're done with those registers.
-    intr_on();
-
-    syscall();
-  } else if((which_dev = devintr()) != 0){
-    // ok
-  } else {
-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
-    setkilled(p);
-  }
-
-  if(killed(p))
-    exit(-1);
-
-  // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2)
-    yield();
-
-  usertrapret();
-}
-
-//
-// return to user space
-//
-void
-usertrapret(void)
-{
-  struct proc *p = myproc();
-
-  // we're about to switch the destination of traps from
-  // kerneltrap() to usertrap(), so turn off interrupts until
-  // we're back in user space, where usertrap() is correct.
-  intr_off();
-
-  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
-  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
-  w_stvec(trampoline_uservec);
-
-  // set up trapframe values that uservec will need when
-  // the process next traps into the kernel.
-  p->trapframe->kernel_satp = r_satp();         // kernel page table
-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
-  p->trapframe->kernel_trap = (uint64)usertrap;
-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
-
-  // set up the registers that trampoline.S's sret will use
-  // to get to user space.
-  
-  // set S Previous Privilege mode to User.
-  unsigned long x = r_sstatus();
-  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
-  x |= SSTATUS_SPIE; // enable interrupts in user mode
-  w_sstatus(x);
-
-  // set S Exception Program Counter to the saved user pc.
-  w_sepc(p->trapframe->epc);
-
-  // tell trampoline.S the user page table to switch to.
-  uint64 satp = MAKE_SATP(p->pagetable);
-
-  // jump to userret in trampoline.S at the top of memory, which 
-  // switches to the user page table, restores user registers,
-  // and switches to user mode with sret.
-  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
-  ((void (*)(uint64))trampoline_userret)(satp);
-}
-
-// interrupts and exceptions from kernel code go here via kernelvec,
-// on whatever the current kernel stack is.
-void 
-kerneltrap()
-{
-  int which_dev = 0;
-  uint64 sepc = r_sepc();
-  uint64 sstatus = r_sstatus();
-  uint64 scause = r_scause();
-  
-  if((sstatus & SSTATUS_SPP) == 0)
-    panic("kerneltrap: not from supervisor mode");
-  if(intr_get() != 0)
-    panic("kerneltrap: interrupts enabled");
-
-  if((which_dev = devintr()) == 0){
-    printf("scause %p\n", scause);
-    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
-    panic("kerneltrap");
-  }
-
-  // give up the CPU if this is a timer interrupt.
-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
-    yield();
-
-  // the yield() may have caused some traps to occur,
-  // so restore trap registers for use by kernelvec.S's sepc instruction.
-  w_sepc(sepc);
-  w_sstatus(sstatus);
-}
-
-void
-clockintr()
-{
-  acquire(&tickslock);
-  ticks++;
-  wakeup(&ticks);
-  release(&tickslock);
-}
-
-// check if it's an external interrupt or software interrupt,
-// and handle it.
-// returns 2 if timer interrupt,
-// 1 if other device,
-// 0 if not recognized.
-int
-devintr()
-{
-  uint64 scause = r_scause();
-
-  if((scause & 0x8000000000000000L) &&
-     (scause & 0xff) == 9){
-    // this is a supervisor external interrupt, via PLIC.
-
-    // irq indicates which device interrupted.
-    int irq = plic_claim();
-
-    if(irq == UART0_IRQ){
-      uartintr();
-    } else if(irq == VIRTIO0_IRQ){
-      virtio_disk_intr();
-    } else if(irq){
-      printf("unexpected interrupt irq=%d\n", irq);
-    }
-
-    // the PLIC allows each device to raise at most one
-    // interrupt at a time; tell the PLIC the device is
-    // now allowed to interrupt again.
-    if(irq)
-      plic_complete(irq);
-
-    return 1;
-  } else if(scause == 0x8000000000000001L){
-    // software interrupt from a machine-mode timer interrupt,
-    // forwarded by timervec in kernelvec.S.
-
-    if(cpuid() == 0){
-      clockintr();
-    }
-    
-    // acknowledge the software interrupt by clearing
-    // the SSIP bit in sip.
-    w_sip(r_sip() & ~2);
-
-    return 2;
-  } else {
-    return 0;
-  }
-}
-
+#include "types.h"
+#include "param.h"
+#include "memlayout.h"
+#include "riscv.h"
+#include "swap.h"
+#include "proc.h"
+#include "defs.h"
+
+struct spinlock tickslock;
+uint ticks;
+
+extern struct live_page_list live_list;
+
+extern char trampoline[], uservec[], userret[];
+
+// in kernelvec.S, calls kerneltrap().
+void kernelvec();
+
+extern int devintr();
+
+void
+trapinit(void)
+{
+  initlock(&tickslock, "time");
+}
+
+// set up to take exceptions and traps while in the kernel.
+void
+trapinithart(void)
+{
+  w_stvec((uint64)kernelvec);
+}
+
+//
+// handle an interrupt, exception, or system call from user space.
+// called from trampoline.S
+//
+void
+usertrap(void)
+{
+  int which_dev = 0;
+
+  if((r_sstatus() & SSTATUS_SPP) != 0)
+    panic("usertrap: not from user mode");
+
+  // send interrupts and exceptions to kerneltrap(),
+  // since we're now in the kernel.
+  w_stvec((uint64)kernelvec);
+
+  struct proc *p = myproc();
+  
+  // save user program counter.
+  p->trapframe->epc = r_sepc();
+  
+  if(r_scause() == 8){
+    // system call
+
+    if(killed(p))
+      exit(-1);
+
+    // sepc points to the ecall instruction,
+    // but we want to return to the next instruction.
+    p->trapframe->epc += 4;
+
+    // an interrupt will change sepc, scause, and sstatus,
+    // so enable only now that we're done with those registers.
+    intr_on();
+
+    syscall();
+  } else if (r_scause() == 15 || r_scause() == 13) {
+      // printf("yessir got it for %d\n", r_stval());
+      struct proc *p = myproc();
+      uint flags;
+      uint64 va = PGROUNDDOWN(r_stval());
+      uint64 toSwap;
+      pte_t *pte;
+      char *mem;
+
+      if((pte = walk(p->pagetable, va, 0)) == 0) {
+        printf("No such page\n");
+        return ;
+      }
+      flags = PTE_FLAGS(*pte);
+      if(flags & PTE_SWAP) {
+        flags &= (~PTE_SWAP);
+        flags |= (PTE_V);
+        toSwap = (*pte >> 10);
+        if (swap_out_wrapper() == 0) {
+          panic("in trap, swap out error\n");
+        }
+        if((mem = kalloc()) == 0) {
+          panic("in trap, memory allocation error\n");
+        }
+        // swap address unmapping
+        uvmunmap(p->pagetable, va, 1, 0);
+
+        // printf("uvmcopy: before releasing %d\n", p->pid);
+        // release(&p->lock);
+        // printf("uvmcopy: after releasing %d\n", p->pid);
+        swapin(mem, (struct swap *)toSwap);
+        // acquire(&p->lock);
+
+        if((mappages(p->pagetable, va, PGSIZE, (uint64)mem, flags)) != 0) {
+          panic("in trap, mapping failed\n");
+        }
+        swapfree((struct swap *)toSwap);
+        // printf("Exiting Trap\n");
+      }
+  } else if((which_dev = devintr()) != 0){
+     // ok
+  } else {
+    // printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+    // printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+    setkilled(p);
+  }
+
+  if(killed(p))
+    exit(-1);
+
+  // give up the CPU if this is a timer interrupt.
+  if(which_dev == 2)
+    yield();
+
+  usertrapret();
+}
+
+//
+// return to user space
+//
+void
+usertrapret(void)
+{
+  struct proc *p = myproc();
+
+  // we're about to switch the destination of traps from
+  // kerneltrap() to usertrap(), so turn off interrupts until
+  // we're back in user space, where usertrap() is correct.
+  intr_off();
+
+  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
+  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
+  w_stvec(trampoline_uservec);
+
+  // set up trapframe values that uservec will need when
+  // the process next traps into the kernel.
+  p->trapframe->kernel_satp = r_satp();         // kernel page table
+  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
+  p->trapframe->kernel_trap = (uint64)usertrap;
+  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+
+  // set up the registers that trampoline.S's sret will use
+  // to get to user space.
+  
+  // set S Previous Privilege mode to User.
+  unsigned long x = r_sstatus();
+  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+  x |= SSTATUS_SPIE; // enable interrupts in user mode
+  w_sstatus(x);
+
+  // set S Exception Program Counter to the saved user pc.
+  w_sepc(p->trapframe->epc);
+
+  // tell trampoline.S the user page table to switch to.
+  uint64 satp = MAKE_SATP(p->pagetable);
+
+  // jump to userret in trampoline.S at the top of memory, which 
+  // switches to the user page table, restores user registers,
+  // and switches to user mode with sret.
+  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
+  ((void (*)(uint64))trampoline_userret)(satp);
+}
+
+// interrupts and exceptions from kernel code go here via kernelvec,
+// on whatever the current kernel stack is.
+void 
+kerneltrap()
+{
+  int which_dev = 0;
+  uint64 sepc = r_sepc();
+  uint64 sstatus = r_sstatus();
+  uint64 scause = r_scause();
+  
+  if((sstatus & SSTATUS_SPP) == 0)
+    panic("kerneltrap: not from supervisor mode");
+  if(intr_get() != 0)
+    panic("kerneltrap: interrupts enabled");
+
+  if((which_dev = devintr()) == 0){
+    printf("scause %p\n", scause);
+    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
+    panic("kerneltrap");
+  }
+
+  // give up the CPU if this is a timer interrupt.
+  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+    yield();
+
+  // the yield() may have caused some traps to occur,
+  // so restore trap registers for use by kernelvec.S's sepc instruction.
+  w_sepc(sepc);
+  w_sstatus(sstatus);
+}
+
+void
+clockintr()
+{
+  acquire(&tickslock);
+  ticks++;
+  wakeup(&ticks);
+  release(&tickslock);
+}
+
+// check if it's an external interrupt or software interrupt,
+// and handle it.
+// returns 2 if timer interrupt,
+// 1 if other device,
+// 0 if not recognized.
+int
+devintr()
+{
+  uint64 scause = r_scause();
+
+  if((scause & 0x8000000000000000L) &&
+     (scause & 0xff) == 9){
+    // this is a supervisor external interrupt, via PLIC.
+
+    // irq indicates which device interrupted.
+    int irq = plic_claim();
+
+    if(irq == UART0_IRQ){
+      uartintr();
+    } else if(irq == VIRTIO0_IRQ){
+      virtio_disk_intr();
+    } else if(irq){
+      printf("unexpected interrupt irq=%d\n", irq);
+    }
+
+    // the PLIC allows each device to raise at most one
+    // interrupt at a time; tell the PLIC the device is
+    // now allowed to interrupt again.
+    if(irq)
+      plic_complete(irq);
+
+    return 1;
+  } else if(scause == 0x8000000000000001L){
+    // software interrupt from a machine-mode timer interrupt,
+    // forwarded by timervec in kernelvec.S.
+
+    if(cpuid() == 0){
+      clockintr();
+    }
+    
+    // acknowledge the software interrupt by clearing
+    // the SSIP bit in sip.
+    w_sip(r_sip() & ~2);
+
+    return 2;
+  } else {
+    return 0;
+  }
+}
+
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..9f3afe7 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -1,439 +1,664 @@
-#include "param.h"
-#include "types.h"
-#include "memlayout.h"
-#include "elf.h"
-#include "riscv.h"
-#include "defs.h"
-#include "fs.h"
-
-/*
- * the kernel's page table.
- */
-pagetable_t kernel_pagetable;
-
-extern char etext[];  // kernel.ld sets this to end of kernel code.
-
-extern char trampoline[]; // trampoline.S
-
-// Make a direct-map page table for the kernel.
-pagetable_t
-kvmmake(void)
-{
-  pagetable_t kpgtbl;
-
-  kpgtbl = (pagetable_t) kalloc();
-  memset(kpgtbl, 0, PGSIZE);
-
-  // uart registers
-  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
-
-  // virtio mmio disk interface
-  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
-
-  // PLIC
-  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
-
-  // map kernel text executable and read-only.
-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
-
-  // map kernel data and the physical RAM we'll make use of.
-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
-
-  // map the trampoline for trap entry/exit to
-  // the highest virtual address in the kernel.
-  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
-
-  // allocate and map a kernel stack for each process.
-  proc_mapstacks(kpgtbl);
-  
-  return kpgtbl;
-}
-
-// Initialize the one kernel_pagetable
-void
-kvminit(void)
-{
-  kernel_pagetable = kvmmake();
-}
-
-// Switch h/w page table register to the kernel's page table,
-// and enable paging.
-void
-kvminithart()
-{
-  // wait for any previous writes to the page table memory to finish.
-  sfence_vma();
-
-  w_satp(MAKE_SATP(kernel_pagetable));
-
-  // flush stale entries from the TLB.
-  sfence_vma();
-}
-
-// Return the address of the PTE in page table pagetable
-// that corresponds to virtual address va.  If alloc!=0,
-// create any required page-table pages.
-//
-// The risc-v Sv39 scheme has three levels of page-table
-// pages. A page-table page contains 512 64-bit PTEs.
-// A 64-bit virtual address is split into five fields:
-//   39..63 -- must be zero.
-//   30..38 -- 9 bits of level-2 index.
-//   21..29 -- 9 bits of level-1 index.
-//   12..20 -- 9 bits of level-0 index.
-//    0..11 -- 12 bits of byte offset within the page.
-pte_t *
-walk(pagetable_t pagetable, uint64 va, int alloc)
-{
-  if(va >= MAXVA)
-    panic("walk");
-
-  for(int level = 2; level > 0; level--) {
-    pte_t *pte = &pagetable[PX(level, va)];
-    if(*pte & PTE_V) {
-      pagetable = (pagetable_t)PTE2PA(*pte);
-    } else {
-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
-        return 0;
-      memset(pagetable, 0, PGSIZE);
-      *pte = PA2PTE(pagetable) | PTE_V;
-    }
-  }
-  return &pagetable[PX(0, va)];
-}
-
-// Look up a virtual address, return the physical address,
-// or 0 if not mapped.
-// Can only be used to look up user pages.
-uint64
-walkaddr(pagetable_t pagetable, uint64 va)
-{
-  pte_t *pte;
-  uint64 pa;
-
-  if(va >= MAXVA)
-    return 0;
-
-  pte = walk(pagetable, va, 0);
-  if(pte == 0)
-    return 0;
-  if((*pte & PTE_V) == 0)
-    return 0;
-  if((*pte & PTE_U) == 0)
-    return 0;
-  pa = PTE2PA(*pte);
-  return pa;
-}
-
-// add a mapping to the kernel page table.
-// only used when booting.
-// does not flush TLB or enable paging.
-void
-kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
-{
-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
-    panic("kvmmap");
-}
-
-// Create PTEs for virtual addresses starting at va that refer to
-// physical addresses starting at pa. va and size might not
-// be page-aligned. Returns 0 on success, -1 if walk() couldn't
-// allocate a needed page-table page.
-int
-mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
-{
-  uint64 a, last;
-  pte_t *pte;
-
-  if(size == 0)
-    panic("mappages: size");
-  
-  a = PGROUNDDOWN(va);
-  last = PGROUNDDOWN(va + size - 1);
-  for(;;){
-    if((pte = walk(pagetable, a, 1)) == 0)
-      return -1;
-    if(*pte & PTE_V)
-      panic("mappages: remap");
-    *pte = PA2PTE(pa) | perm | PTE_V;
-    if(a == last)
-      break;
-    a += PGSIZE;
-    pa += PGSIZE;
-  }
-  return 0;
-}
-
-// Remove npages of mappings starting from va. va must be
-// page-aligned. The mappings must exist.
-// Optionally free the physical memory.
-void
-uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
-{
-  uint64 a;
-  pte_t *pte;
-
-  if((va % PGSIZE) != 0)
-    panic("uvmunmap: not aligned");
-
-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
-    if((pte = walk(pagetable, a, 0)) == 0)
-      panic("uvmunmap: walk");
-    if((*pte & PTE_V) == 0)
-      panic("uvmunmap: not mapped");
-    if(PTE_FLAGS(*pte) == PTE_V)
-      panic("uvmunmap: not a leaf");
-    if(do_free){
-      uint64 pa = PTE2PA(*pte);
-      kfree((void*)pa);
-    }
-    *pte = 0;
-  }
-}
-
-// create an empty user page table.
-// returns 0 if out of memory.
-pagetable_t
-uvmcreate()
-{
-  pagetable_t pagetable;
-  pagetable = (pagetable_t) kalloc();
-  if(pagetable == 0)
-    return 0;
-  memset(pagetable, 0, PGSIZE);
-  return pagetable;
-}
-
-// Load the user initcode into address 0 of pagetable,
-// for the very first process.
-// sz must be less than a page.
-void
-uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
-{
-  char *mem;
-
-  if(sz >= PGSIZE)
-    panic("uvmfirst: more than a page");
-  mem = kalloc();
-  memset(mem, 0, PGSIZE);
-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
-  memmove(mem, src, sz);
-}
-
-// Allocate PTEs and physical memory to grow process from oldsz to
-// newsz, which need not be page aligned.  Returns new size or 0 on error.
-uint64
-uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
-{
-  char *mem;
-  uint64 a;
-
-  if(newsz < oldsz)
-    return oldsz;
-
-  oldsz = PGROUNDUP(oldsz);
-  for(a = oldsz; a < newsz; a += PGSIZE){
-    mem = kalloc();
-    if(mem == 0){
-      uvmdealloc(pagetable, a, oldsz);
-      return 0;
-    }
-    memset(mem, 0, PGSIZE);
-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
-      kfree(mem);
-      uvmdealloc(pagetable, a, oldsz);
-      return 0;
-    }
-  }
-  return newsz;
-}
-
-// Deallocate user pages to bring the process size from oldsz to
-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
-// need to be less than oldsz.  oldsz can be larger than the actual
-// process size.  Returns the new process size.
-uint64
-uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
-{
-  if(newsz >= oldsz)
-    return oldsz;
-
-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
-    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
-    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
-  }
-
-  return newsz;
-}
-
-// Recursively free page-table pages.
-// All leaf mappings must already have been removed.
-void
-freewalk(pagetable_t pagetable)
-{
-  // there are 2^9 = 512 PTEs in a page table.
-  for(int i = 0; i < 512; i++){
-    pte_t pte = pagetable[i];
-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
-      // this PTE points to a lower-level page table.
-      uint64 child = PTE2PA(pte);
-      freewalk((pagetable_t)child);
-      pagetable[i] = 0;
-    } else if(pte & PTE_V){
-      panic("freewalk: leaf");
-    }
-  }
-  kfree((void*)pagetable);
-}
-
-// Free user memory pages,
-// then free page-table pages.
-void
-uvmfree(pagetable_t pagetable, uint64 sz)
-{
-  if(sz > 0)
-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
-  freewalk(pagetable);
-}
-
-// Given a parent process's page table, copy
-// its memory into a child's page table.
-// Copies both the page table and the
-// physical memory.
-// returns 0 on success, -1 on failure.
-// frees any allocated pages on failure.
-int
-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
-{
-  pte_t *pte;
-  uint64 pa, i;
-  uint flags;
-  char *mem;
-
-  for(i = 0; i < sz; i += PGSIZE){
-    if((pte = walk(old, i, 0)) == 0)
-      panic("uvmcopy: pte should exist");
-    if((*pte & PTE_V) == 0)
-      panic("uvmcopy: page not present");
-    pa = PTE2PA(*pte);
-    flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
-      goto err;
-    }
-  }
-  return 0;
-
- err:
-  uvmunmap(new, 0, i / PGSIZE, 1);
-  return -1;
-}
-
-// mark a PTE invalid for user access.
-// used by exec for the user stack guard page.
-void
-uvmclear(pagetable_t pagetable, uint64 va)
-{
-  pte_t *pte;
-  
-  pte = walk(pagetable, va, 0);
-  if(pte == 0)
-    panic("uvmclear");
-  *pte &= ~PTE_U;
-}
-
-// Copy from kernel to user.
-// Copy len bytes from src to virtual address dstva in a given page table.
-// Return 0 on success, -1 on error.
-int
-copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
-{
-  uint64 n, va0, pa0;
-
-  while(len > 0){
-    va0 = PGROUNDDOWN(dstva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (dstva - va0);
-    if(n > len)
-      n = len;
-    memmove((void *)(pa0 + (dstva - va0)), src, n);
-
-    len -= n;
-    src += n;
-    dstva = va0 + PGSIZE;
-  }
-  return 0;
-}
-
-// Copy from user to kernel.
-// Copy len bytes to dst from virtual address srcva in a given page table.
-// Return 0 on success, -1 on error.
-int
-copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
-{
-  uint64 n, va0, pa0;
-
-  while(len > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > len)
-      n = len;
-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
-
-    len -= n;
-    dst += n;
-    srcva = va0 + PGSIZE;
-  }
-  return 0;
-}
-
-// Copy a null-terminated string from user to kernel.
-// Copy bytes to dst from virtual address srcva in a given page table,
-// until a '\0', or max.
-// Return 0 on success, -1 on error.
-int
-copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
-{
-  uint64 n, va0, pa0;
-  int got_null = 0;
-
-  while(got_null == 0 && max > 0){
-    va0 = PGROUNDDOWN(srcva);
-    pa0 = walkaddr(pagetable, va0);
-    if(pa0 == 0)
-      return -1;
-    n = PGSIZE - (srcva - va0);
-    if(n > max)
-      n = max;
-
-    char *p = (char *) (pa0 + (srcva - va0));
-    while(n > 0){
-      if(*p == '\0'){
-        *dst = '\0';
-        got_null = 1;
-        break;
-      } else {
-        *dst = *p;
-      }
-      --n;
-      --max;
-      p++;
-      dst++;
-    }
-
-    srcva = va0 + PGSIZE;
-  }
-  if(got_null){
-    return 0;
-  } else {
-    return -1;
-  }
-}
+#include "param.h"
+#include "types.h"
+#include "memlayout.h"
+#include "elf.h"
+#include "riscv.h"
+#include "defs.h"
+#include "fs.h"
+
+#include "swap.h"
+#include "proc.h"
+
+extern struct user_page_alloc_flag user_alloc_flag;
+
+struct live_page_list live_list;
+struct swapped_pages *swapped_list;
+
+void print_live_count() {
+  acquire(&live_list.lock);
+  printf("Live Pages: %d\n", live_list.size);
+  release(&live_list.lock);
+}
+
+
+/*
+ * the kernel's page table.
+ */
+pagetable_t kernel_pagetable;
+
+
+extern char etext[];  // kernel.ld sets this to end of kernel code.
+
+extern char trampoline[]; // trampoline.S
+
+// Make a direct-map page table for the kernel.
+pagetable_t
+kvmmake(void)
+{
+  pagetable_t kpgtbl;
+
+  kpgtbl = (pagetable_t) kalloc();
+  memset(kpgtbl, 0, PGSIZE);
+
+  // uart registers
+  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+
+  // virtio mmio disk interface
+  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+
+  // PLIC
+  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+
+  // map kernel text executable and read-only.
+  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+
+  // map kernel data and the physical RAM we'll make use of.
+  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+
+  // map the trampoline for trap entry/exit to
+  // the highest virtual address in the kernel.
+  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+
+  // allocate and map a kernel stack for each process.
+  proc_mapstacks(kpgtbl);
+  
+  return kpgtbl;
+}
+
+// Initialize the one kernel_pagetable
+void
+kvminit(void)
+{
+  kernel_pagetable = kvmmake();
+}
+
+// Switch h/w page table register to the kernel's page table,
+// and enable paging.
+void
+kvminithart()
+{
+  // wait for any previous writes to the page table memory to finish.
+  sfence_vma();
+
+  w_satp(MAKE_SATP(kernel_pagetable));
+
+  // flush stale entries from the TLB.
+  sfence_vma();
+}
+
+// Return the address of the PTE in page table pagetable
+// that corresponds to virtual address va.  If alloc!=0,
+// create any required page-table pages.
+//
+// The risc-v Sv39 scheme has three levels of page-table
+// pages. A page-table page contains 512 64-bit PTEs.
+// A 64-bit virtual address is split into five fields:
+//   39..63 -- must be zero.
+//   30..38 -- 9 bits of level-2 index.
+//   21..29 -- 9 bits of level-1 index.
+//   12..20 -- 9 bits of level-0 index.
+//    0..11 -- 12 bits of byte offset within the page.
+pte_t *
+walk(pagetable_t pagetable, uint64 va, int alloc)
+{
+  if(va >= MAXVA)
+    panic("walk");
+
+  for(int level = 2; level > 0; level--) {
+    // sfence_vma();
+    pte_t *pte = &pagetable[PX(level, va)];
+    // printf("pte: %d\n", PTE_FLAGS(*pte));
+    if ((*pte & PTE_SWAP)) {
+      // printf("Yessir found page %d\n", (int)*pte & 0x3ff);
+      return pte;
+    }
+    // printf("passed swap check in walk\n");
+    if(*pte & PTE_V) {
+      // printf("matched valid bit\n");
+      pagetable = (pagetable_t)PTE2PA(*pte);
+    } else {
+      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+        return 0;
+      memset(pagetable, 0, PGSIZE);
+      *pte = PA2PTE(pagetable) | PTE_V;
+    }
+  }
+  return &pagetable[PX(0, va)];
+}
+
+// Look up a virtual address, return the physical address,
+// or 0 if not mapped.
+// Can only be used to look up user pages.
+uint64
+walkaddr(pagetable_t pagetable, uint64 va)
+{
+  pte_t *pte;
+  uint64 pa;
+
+  if(va >= MAXVA)
+    return 0;
+
+  pte = walk(pagetable, va, 0);
+  if(pte == 0)
+    return 0;
+  if((*pte & PTE_V) == 0)
+    return 0;
+  if((*pte & PTE_U) == 0)
+    return 0;
+  pa = PTE2PA(*pte);
+  return pa;
+}
+
+void
+print_live_list() {
+  printf("va\tpagetable\n");
+  printf("--\t---------\n");
+
+  acquire(&live_list.lock);
+  for(int i=0; i < live_list.size; i++) {
+    printf("%d\t%p\n", live_list.elem[i].vpn, live_list.elem[i].pagetable);
+  }
+  release(&live_list.lock);
+}
+
+// add a mapping to the kernel page table.
+// only used when booting.
+// does not flush TLB or enable paging.
+void
+kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
+{
+  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+    panic("kvmmap");
+}
+
+// Create PTEs for virtual addresses starting at va that refer to
+// physical addresses starting at pa. va and size might not
+// be page-aligned. Returns 0 on success, -1 if walk() couldn't
+// allocate a needed page-table page.
+int
+mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+{
+  uint64 a, last;
+  pte_t *pte;
+
+  if(size == 0)
+    panic("mappages: size");
+  
+  a = PGROUNDDOWN(va);
+  last = PGROUNDDOWN(va + size - 1);
+  for(;;){
+    if((pte = walk(pagetable, a, 1)) == 0) {
+      // printf("lengra\n");
+      return -1;
+    }
+    if(*pte & PTE_V)
+      panic("mappages: remap");
+    *pte = PA2PTE(pa) | perm | PTE_V;
+    if(a == last)
+      break;
+    a += PGSIZE;
+    pa += PGSIZE;
+  }
+  return 0;
+}
+
+// Remove npages of mappings starting from va. va must be
+// page-aligned. The mappings must exist.
+// Optionally free the physical memory.
+void
+uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+{
+  // printf("entering uvmunmap\n");
+  uint64 a;
+  pte_t *pte;
+
+  if((va % PGSIZE) != 0)
+    panic("uvmunmap: not aligned");
+
+  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+    if((pte = walk(pagetable, a, 0)) == 0)
+      panic("uvmunmap: walk");
+    // if(((*pte & PTE_V) == 0))
+    //   panic("uvmunmap: not mapped");
+    if (((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0)
+        panic("uvmunmap: not mapped");
+    if (PTE_FLAGS(*pte) == PTE_V)
+      panic("uvmunmap: not a leaf");
+    if(do_free){
+      if (*pte & PTE_SWAP) {
+        // printf("inside uvmunmap->swap\n");
+        // pte contains swap address
+        struct swap *swapAddress = (struct swap *)((*pte) >> 10);
+        swapfree(swapAddress);
+        // printf("swap free done\n");
+      } else {
+        uint64 pa = PTE2PA(*pte);
+
+        // acquire(&live_list.lock);
+        // printf("trying to look_up %d\n", (unsigned int) pa);
+        int idx = list_lookup(pa);
+
+        if (idx >= 0) {
+          // printf("removing live page\n");
+          remove_live_page(idx);
+        }
+        // release(&live_list.lock);
+        kfree((void*)pa);
+      }
+    }
+    *pte = 0;
+  }
+  // printf("Exiting uvmunmap\n");
+  // printf("after deallocation: ");
+  // print_live_count();
+}
+
+// create an empty user page table.
+// returns 0 if out of memory.
+pagetable_t
+uvmcreate()
+{
+  pagetable_t pagetable;
+  pagetable = (pagetable_t) kalloc();
+  if(pagetable == 0)
+    return 0;
+  memset(pagetable, 0, PGSIZE);
+  return pagetable;
+}
+
+// Load the user initcode into address 0 of pagetable,
+// for the very first process.
+// sz must be less than a page.
+void
+uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+{
+  char *mem;
+
+  if(sz >= PGSIZE)
+    panic("uvmfirst: more than a page");
+  mem = kalloc();
+  memset(mem, 0, PGSIZE);
+  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+  memmove(mem, src, sz);
+}
+
+void
+add_live_page(pagetable_t pagetable, uint64 va, uint64 pa) {
+  acquire(&live_list.lock);
+  if(live_list.size >= 50) {
+    panic ("Live page full\n");
+  }
+  live_list.elem[live_list.size].pagetable = pagetable;
+  live_list.elem[live_list.size].vpn = va;
+  live_list.elem[live_list.size].pa = pa;
+  live_list.size++;
+  release(&live_list.lock);
+}
+
+int
+list_lookup(uint64 pa) {
+  acquire(&live_list.lock);
+  for (int i = 0; i < live_list.size; i++) {
+      if (pa == live_list.elem[i].pa) {
+        release(&live_list.lock);
+        return i;
+      }
+  }
+
+  release(&live_list.lock);
+  return -1;
+}
+
+struct live
+remove_live_page(int idx) {
+  acquire(&live_list.lock);
+  if(live_list.size <= idx) {
+    panic ("Empty live_list\n");
+  }
+  struct live temp = live_list.elem[idx];
+  for(int i = idx; i < live_list.size-1; i++) {
+    live_list.elem[i] = live_list.elem[i+1];
+  }
+  live_list.size--;
+
+  release(&live_list.lock);
+  return temp;
+}
+
+
+
+// returns 0 if not successful
+uint
+swap_out_wrapper() {
+  // printf("Entering swap_out_wrapper\n");
+  pte_t *pte;
+  uint64 pa;
+  uint flags;
+
+  acquire(&live_list.lock);
+  if (live_list.size >= 50) {
+    release(&live_list.lock);
+    struct live live_to_remove = remove_live_page(0);
+    acquire(&live_list.lock);
+
+    pagetable_t pagetable = live_to_remove.pagetable;
+    uint64 va = live_to_remove.vpn;
+    pa = live_to_remove.pa;
+    // printf("actually swapping out\n");
+    // allocate a swap
+    struct swap* toSwap;
+    if((toSwap = swapalloc()) == 0) {
+      printf("Memory Full\n");
+      release(&live_list.lock);
+      return 0;
+    } 
+
+    release(&live_list.lock);
+    swapout(toSwap, (char *)pa);
+    acquire(&live_list.lock);
+
+    // get a live page to swap out
+    if((pte = walk(pagetable, va, 0)) == 0) {
+      printf("Unable to walk\n");
+      release(&live_list.lock);
+      return 0;
+    }
+    flags = PTE_FLAGS(*pte);
+    flags |= PTE_SWAP; 
+    flags &= (~PTE_V);
+    
+    kfree((void *)PGROUNDDOWN(pa));    
+    *pte = ((uint64)toSwap << 10) | flags;
+  }
+
+  release(&live_list.lock);
+  return 1;
+}
+
+// Allocate PTEs and physical memory to grow process from oldsz to
+// newsz, which need not be page aligned.  Returns new size or 0 on error.
+uint64
+uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
+{
+  char *mem;
+  uint64 a;
+  // printf("Entering uvmalloc\n");
+  if(newsz < oldsz)
+    return oldsz;
+
+  oldsz = PGROUNDUP(oldsz);
+  for(a = oldsz; a < newsz; a += PGSIZE) {
+    mem = kalloc();
+    if(mem == 0){
+      goto err;
+    }
+    memset(mem, 0, PGSIZE);
+    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+      kfree(mem);
+      uvmdealloc(pagetable, a, oldsz);
+      return 0;
+    }
+    // only swap the non executables. 
+    acquire(&user_alloc_flag.lock);
+    if(user_alloc_flag.flag == 1) {
+      release(&user_alloc_flag.lock);
+      if (swap_out_wrapper() == 0)
+        goto err;
+    
+      add_live_page(pagetable, a, (uint64)mem);
+    } else {
+      release(&user_alloc_flag.lock);
+    }
+  }
+
+  acquire(&user_alloc_flag.lock);
+  user_alloc_flag.flag = 0;
+  release(&user_alloc_flag.lock);
+  return newsz;
+
+  err:
+    uvmdealloc(pagetable, a, oldsz);
+    acquire(&user_alloc_flag.lock);
+    user_alloc_flag.flag = 0;
+    release(&user_alloc_flag.lock);
+    return 0;
+}
+
+// Deallocate user pages to bring the process size from oldsz to
+// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+// need to be less than oldsz.  oldsz can be larger than the actual
+// process size.  Returns the new process size.
+uint64
+uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+{
+  if(newsz >= oldsz)
+    return oldsz;
+
+  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+  }
+
+  return newsz;
+}
+
+// Recursively free page-table pages.
+// All leaf mappings must already have been removed.
+void
+freewalk(pagetable_t pagetable)
+{
+  // there are 2^9 = 512 PTEs in a page table.
+  for(int i = 0; i < 512; i++){
+    pte_t pte = pagetable[i];
+    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+      // this PTE points to a lower-level page table.
+      uint64 child = PTE2PA(pte);
+      freewalk((pagetable_t)child);
+      pagetable[i] = 0;
+    } else if(pte & PTE_V){
+      panic("freewalk: leaf");
+    }
+  }
+  kfree((void*)pagetable);
+}
+
+// Free user memory pages,
+// then free page-table pages.
+void
+uvmfree(pagetable_t pagetable, uint64 sz)
+{
+  if(sz > 0)
+    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+  freewalk(pagetable);
+}
+
+// Given a parent process's page table, copy
+// its memory into a child's page table.
+// Copies both the page table and the
+// physical memory.
+// returns 0 on success, -1 on failure.
+// frees any allocated pages on failure.
+int
+uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+{
+  pte_t *pte;
+  uint64 pa, i;
+  uint flags;
+  char *mem;
+
+  for(i = 0; i < sz; i += PGSIZE){
+    if((pte = walk(old, i, 0)) == 0){
+      panic("uvmcopy: pte should exist");
+    }
+    // not valid and not swapped
+    if(((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0){
+      panic("uvmcopy: page not present");
+    }
+    //either valid or swapped
+    pa = PTE2PA(*pte);
+    flags = PTE_FLAGS(*pte);
+    if(flags & PTE_SWAP) {
+      // swapped memory for parent
+      if(swap_out_wrapper() == 0) {
+        goto err;
+      }
+
+      // printf("swapout finished\n");
+      char *mem2;
+      struct swap* toSwap = (struct swap*)(*pte >> 10);
+      flags &= (~PTE_SWAP);
+      flags |= (PTE_V);
+
+      if ((mem2 = kalloc()) == 0) {
+        goto err;
+      }
+
+      swapin((char *)mem2, toSwap);
+      add_live_page(old, i, (uint64)mem2);
+
+      if(mappages(old, i, PGSIZE, (uint64)mem2, flags) != 0){
+        kfree(mem2);
+        goto err;
+      }
+      pa = (uint64)mem2;
+      swapfree(toSwap);
+    }
+    // all parent pages are either live or not swappable
+    // for child, memory alloc
+    if((mem = kalloc()) == 0){
+      goto err;
+    }
+    memmove(mem, (char*)pa, PGSIZE);
+    
+    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+      kfree(mem);
+      goto err;
+    }
+
+    int parent_livepage_idx = list_lookup(pa);
+    
+    if (parent_livepage_idx == -1) {
+      // not live page. so directly map
+    } else {
+      // parent is a live page. So,
+      // child should be kept in live
+      if (swap_out_wrapper() == 0){
+        goto err;
+      }
+
+      add_live_page(new, i, (uint64)mem);
+    }
+  }
+
+  return 0;
+
+ err:
+  uvmunmap(new, 0, i / PGSIZE, 1);
+  return -1;
+}
+
+// mark a PTE invalid for user access.
+// used by exec for the user stack guard page.
+void
+uvmclear(pagetable_t pagetable, uint64 va)
+{
+  pte_t *pte;
+  
+  pte = walk(pagetable, va, 0);
+  if(pte == 0)
+    panic("uvmclear");
+  *pte &= ~PTE_U;
+}
+
+// Copy from kernel to user.
+// Copy len bytes from src to virtual address dstva in a given page table.
+// Return 0 on success, -1 on error.
+int
+copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+{
+  uint64 n, va0, pa0;
+
+  while(len > 0){
+    va0 = PGROUNDDOWN(dstva);
+    pa0 = walkaddr(pagetable, va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (dstva - va0);
+    if(n > len)
+      n = len;
+    memmove((void *)(pa0 + (dstva - va0)), src, n);
+
+    len -= n;
+    src += n;
+    dstva = va0 + PGSIZE;
+  }
+  return 0;
+}
+
+// Copy from user to kernel.
+// Copy len bytes to dst from virtual address srcva in a given page table.
+// Return 0 on success, -1 on error.
+int
+copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
+{
+  uint64 n, va0, pa0;
+
+  while(len > 0){
+    va0 = PGROUNDDOWN(srcva);
+    pa0 = walkaddr(pagetable, va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (srcva - va0);
+    if(n > len)
+      n = len;
+    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+
+    len -= n;
+    dst += n;
+    srcva = va0 + PGSIZE;
+  }
+  return 0;
+}
+
+// Copy a null-terminated string from user to kernel.
+// Copy bytes to dst from virtual address srcva in a given page table,
+// until a '\0', or max.
+// Return 0 on success, -1 on error.
+int
+copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+{
+  uint64 n, va0, pa0;
+  int got_null = 0;
+
+  while(got_null == 0 && max > 0){
+    va0 = PGROUNDDOWN(srcva);
+    pa0 = walkaddr(pagetable, va0);
+    if(pa0 == 0)
+      return -1;
+    n = PGSIZE - (srcva - va0);
+    if(n > max)
+      n = max;
+
+    char *p = (char *) (pa0 + (srcva - va0));
+    while(n > 0){
+      if(*p == '\0'){
+        *dst = '\0';
+        got_null = 1;
+        break;
+      } else {
+        *dst = *p;
+      }
+      --n;
+      --max;
+      p++;
+      dst++;
+    }
+
+    srcva = va0 + PGSIZE;
+  }
+  if(got_null){
+    return 0;
+  } else {
+    return -1;
+  }
+}
diff --git a/paging.patch b/paging.patch
new file mode 100644
index 0000000..a2935f8
--- /dev/null
+++ b/paging.patch
@@ -0,0 +1,4914 @@
+diff --git a/Makefile b/Makefile
+index 39a99d7..00df97e 100644
+--- a/Makefile
++++ b/Makefile
+@@ -1,173 +1,175 @@
+-K=kernel
+-U=user
+-
+-OBJS = \
+-  $K/entry.o \
+-  $K/start.o \
+-  $K/console.o \
+-  $K/printf.o \
+-  $K/uart.o \
+-  $K/kalloc.o \
+-  $K/spinlock.o \
+-  $K/string.o \
+-  $K/main.o \
+-  $K/vm.o \
+-  $K/proc.o \
+-  $K/swtch.o \
+-  $K/trampoline.o \
+-  $K/trap.o \
+-  $K/syscall.o \
+-  $K/sysproc.o \
+-  $K/bio.o \
+-  $K/fs.o \
+-  $K/log.o \
+-  $K/sleeplock.o \
+-  $K/file.o \
+-  $K/pipe.o \
+-  $K/exec.o \
+-  $K/sysfile.o \
+-  $K/kernelvec.o \
+-  $K/plic.o \
+-  $K/virtio_disk.o
+-
+-# riscv64-unknown-elf- or riscv64-linux-gnu-
+-# perhaps in /opt/riscv/bin
+-#TOOLPREFIX = 
+-
+-# Try to infer the correct TOOLPREFIX if not set
+-ifndef TOOLPREFIX
+-TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-unknown-elf-'; \
+-	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-linux-gnu-'; \
+-	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-unknown-linux-gnu-'; \
+-	else echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
+-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+-	echo "***" 1>&2; exit 1; fi)
+-endif
+-
+-QEMU = qemu-system-riscv64
+-
+-CC = $(TOOLPREFIX)gcc
+-AS = $(TOOLPREFIX)gas
+-LD = $(TOOLPREFIX)ld
+-OBJCOPY = $(TOOLPREFIX)objcopy
+-OBJDUMP = $(TOOLPREFIX)objdump
+-
+-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
+-CFLAGS += -MD
+-CFLAGS += -mcmodel=medany
+-CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
+-CFLAGS += -I.
+-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+-
+-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+-CFLAGS += -fno-pie -no-pie
+-endif
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+-CFLAGS += -fno-pie -nopie
+-endif
+-
+-LDFLAGS = -z max-page-size=4096
+-
+-$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
+-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
+-	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
+-	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
+-
+-$U/initcode: $U/initcode.S
+-	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
+-	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
+-	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
+-
+-tags: $(OBJS) _init
+-	etags *.S *.c
+-
+-ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
+-
+-_%: %.o $(ULIB)
+-	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
+-	$(OBJDUMP) -S $@ > $*.asm
+-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+-
+-$U/usys.S : $U/usys.pl
+-	perl $U/usys.pl > $U/usys.S
+-
+-$U/usys.o : $U/usys.S
+-	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
+-
+-$U/_forktest: $U/forktest.o $(ULIB)
+-	# forktest has less library code linked in - needs to be small
+-	# in order to be able to max out the proc table.
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
+-	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
+-
+-mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
+-	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
+-
+-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+-# that disk image changes after first build are persistent until clean.  More
+-# details:
+-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+-.PRECIOUS: %.o
+-
+-UPROGS=\
+-	$U/_cat\
+-	$U/_echo\
+-	$U/_forktest\
+-	$U/_grep\
+-	$U/_init\
+-	$U/_kill\
+-	$U/_ln\
+-	$U/_ls\
+-	$U/_mkdir\
+-	$U/_rm\
+-	$U/_sh\
+-	$U/_stressfs\
+-	$U/_usertests\
+-	$U/_grind\
+-	$U/_wc\
+-	$U/_zombie\
+-
+-fs.img: mkfs/mkfs README $(UPROGS)
+-	mkfs/mkfs fs.img README $(UPROGS)
+-
+--include kernel/*.d user/*.d
+-
+-clean: 
+-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+-	*/*.o */*.d */*.asm */*.sym \
+-	$U/initcode $U/initcode.out $K/kernel fs.img \
+-	mkfs/mkfs .gdbinit \
+-        $U/usys.S \
+-	$(UPROGS)
+-
+-# try to generate a unique GDB port
+-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+-# QEMU's gdb stub command line changed in 0.11
+-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+-	then echo "-gdb tcp::$(GDBPORT)"; \
+-	else echo "-s -p $(GDBPORT)"; fi)
+-ifndef CPUS
+-CPUS := 3
+-endif
+-
+-QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
+-QEMUOPTS += -global virtio-mmio.force-legacy=false
+-QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
+-QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
+-
+-qemu: $K/kernel fs.img
+-	$(QEMU) $(QEMUOPTS)
+-
+-.gdbinit: .gdbinit.tmpl-riscv
+-	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
+-
+-qemu-gdb: $K/kernel .gdbinit fs.img
+-	@echo "*** Now run 'gdb' in another window." 1>&2
+-	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
+-
++K=kernel
++U=user
++
++OBJS = \
++  $K/entry.o \
++  $K/start.o \
++  $K/console.o \
++  $K/printf.o \
++  $K/uart.o \
++  $K/kalloc.o \
++  $K/spinlock.o \
++  $K/string.o \
++  $K/main.o \
++  $K/vm.o \
++  $K/proc.o \
++  $K/swtch.o \
++  $K/trampoline.o \
++  $K/trap.o \
++  $K/syscall.o \
++  $K/sysproc.o \
++  $K/bio.o \
++  $K/fs.o \
++  $K/log.o \
++  $K/sleeplock.o \
++  $K/file.o \
++  $K/pipe.o \
++  $K/swap.o \
++  $K/exec.o \
++  $K/sysfile.o \
++  $K/kernelvec.o \
++  $K/plic.o \
++  $K/virtio_disk.o
++
++# riscv64-unknown-elf- or riscv64-linux-gnu-
++# perhaps in /opt/riscv/bin
++#TOOLPREFIX = 
++
++# Try to infer the correct TOOLPREFIX if not set
++ifndef TOOLPREFIX
++TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-unknown-elf-'; \
++	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-linux-gnu-'; \
++	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-unknown-linux-gnu-'; \
++	else echo "***" 1>&2; \
++	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
++	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
++	echo "***" 1>&2; exit 1; fi)
++endif
++
++QEMU = qemu-system-riscv64
++
++CC = $(TOOLPREFIX)gcc
++AS = $(TOOLPREFIX)gas
++LD = $(TOOLPREFIX)ld
++OBJCOPY = $(TOOLPREFIX)objcopy
++OBJDUMP = $(TOOLPREFIX)objdump
++
++CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
++CFLAGS += -MD
++CFLAGS += -mcmodel=medany
++CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
++CFLAGS += -I.
++CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++
++# Disable PIE when possible (for Ubuntu 16.10 toolchain)
++ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
++CFLAGS += -fno-pie -no-pie
++endif
++ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
++CFLAGS += -fno-pie -nopie
++endif
++
++LDFLAGS = -z max-page-size=4096
++
++$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
++	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
++	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
++	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
++
++$U/initcode: $U/initcode.S
++	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
++	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
++	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
++	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
++
++tags: $(OBJS) _init
++	etags *.S *.c
++
++ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
++
++_%: %.o $(ULIB)
++	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
++	$(OBJDUMP) -S $@ > $*.asm
++	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
++
++$U/usys.S : $U/usys.pl
++	perl $U/usys.pl > $U/usys.S
++
++$U/usys.o : $U/usys.S
++	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
++
++$U/_forktest: $U/forktest.o $(ULIB)
++	# forktest has less library code linked in - needs to be small
++	# in order to be able to max out the proc table.
++	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
++	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
++
++mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
++	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
++
++# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
++# that disk image changes after first build are persistent until clean.  More
++# details:
++# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
++.PRECIOUS: %.o
++
++UPROGS=\
++	$U/_cat\
++	$U/_echo\
++	$U/_forktest\
++	$U/_grep\
++	$U/_init\
++	$U/_kill\
++	$U/_ln\
++	$U/_ls\
++	$U/_mkdir\
++	$U/_rm\
++	$U/_sh\
++	$U/_stressfs\
++	$U/_usertests\
++	$U/_grind\
++	$U/_wc\
++	$U/_zombie\
++	$U/_usertest\
++
++fs.img: mkfs/mkfs README $(UPROGS)
++	mkfs/mkfs fs.img README $(UPROGS)
++
++-include kernel/*.d user/*.d
++
++clean: 
++	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
++	*/*.o */*.d */*.asm */*.sym \
++	$U/initcode $U/initcode.out $K/kernel fs.img \
++	mkfs/mkfs .gdbinit \
++        $U/usys.S \
++	$(UPROGS)
++
++# try to generate a unique GDB port
++GDBPORT = $(shell expr `id -u` % 5000 + 25000)
++# QEMU's gdb stub command line changed in 0.11
++QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
++	then echo "-gdb tcp::$(GDBPORT)"; \
++	else echo "-s -p $(GDBPORT)"; fi)
++ifndef CPUS
++CPUS := 1
++endif
++
++QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
++QEMUOPTS += -global virtio-mmio.force-legacy=false
++QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
++QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
++
++qemu: $K/kernel fs.img
++	$(QEMU) $(QEMUOPTS)
++
++.gdbinit: .gdbinit.tmpl-riscv
++	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
++
++qemu-gdb: $K/kernel .gdbinit fs.img
++	@echo "*** Now run 'gdb' in another window." 1>&2
++	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
++
+diff --git a/kernel/defs.h b/kernel/defs.h
+index a3c962b..84e9983 100644
+--- a/kernel/defs.h
++++ b/kernel/defs.h
+@@ -1,189 +1,208 @@
+-struct buf;
+-struct context;
+-struct file;
+-struct inode;
+-struct pipe;
+-struct proc;
+-struct spinlock;
+-struct sleeplock;
+-struct stat;
+-struct superblock;
+-
+-// bio.c
+-void            binit(void);
+-struct buf*     bread(uint, uint);
+-void            brelse(struct buf*);
+-void            bwrite(struct buf*);
+-void            bpin(struct buf*);
+-void            bunpin(struct buf*);
+-
+-// console.c
+-void            consoleinit(void);
+-void            consoleintr(int);
+-void            consputc(int);
+-
+-// exec.c
+-int             exec(char*, char**);
+-
+-// file.c
+-struct file*    filealloc(void);
+-void            fileclose(struct file*);
+-struct file*    filedup(struct file*);
+-void            fileinit(void);
+-int             fileread(struct file*, uint64, int n);
+-int             filestat(struct file*, uint64 addr);
+-int             filewrite(struct file*, uint64, int n);
+-
+-// fs.c
+-void            fsinit(int);
+-int             dirlink(struct inode*, char*, uint);
+-struct inode*   dirlookup(struct inode*, char*, uint*);
+-struct inode*   ialloc(uint, short);
+-struct inode*   idup(struct inode*);
+-void            iinit();
+-void            ilock(struct inode*);
+-void            iput(struct inode*);
+-void            iunlock(struct inode*);
+-void            iunlockput(struct inode*);
+-void            iupdate(struct inode*);
+-int             namecmp(const char*, const char*);
+-struct inode*   namei(char*);
+-struct inode*   nameiparent(char*, char*);
+-int             readi(struct inode*, int, uint64, uint, uint);
+-void            stati(struct inode*, struct stat*);
+-int             writei(struct inode*, int, uint64, uint, uint);
+-void            itrunc(struct inode*);
+-
+-// ramdisk.c
+-void            ramdiskinit(void);
+-void            ramdiskintr(void);
+-void            ramdiskrw(struct buf*);
+-
+-// kalloc.c
+-void*           kalloc(void);
+-void            kfree(void *);
+-void            kinit(void);
+-
+-// log.c
+-void            initlog(int, struct superblock*);
+-void            log_write(struct buf*);
+-void            begin_op(void);
+-void            end_op(void);
+-
+-// pipe.c
+-int             pipealloc(struct file**, struct file**);
+-void            pipeclose(struct pipe*, int);
+-int             piperead(struct pipe*, uint64, int);
+-int             pipewrite(struct pipe*, uint64, int);
+-
+-// printf.c
+-void            printf(char*, ...);
+-void            panic(char*) __attribute__((noreturn));
+-void            printfinit(void);
+-
+-// proc.c
+-int             cpuid(void);
+-void            exit(int);
+-int             fork(void);
+-int             growproc(int);
+-void            proc_mapstacks(pagetable_t);
+-pagetable_t     proc_pagetable(struct proc *);
+-void            proc_freepagetable(pagetable_t, uint64);
+-int             kill(int);
+-int             killed(struct proc*);
+-void            setkilled(struct proc*);
+-struct cpu*     mycpu(void);
+-struct cpu*     getmycpu(void);
+-struct proc*    myproc();
+-void            procinit(void);
+-void            scheduler(void) __attribute__((noreturn));
+-void            sched(void);
+-void            sleep(void*, struct spinlock*);
+-void            userinit(void);
+-int             wait(uint64);
+-void            wakeup(void*);
+-void            yield(void);
+-int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
+-int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
+-void            procdump(void);
+-
+-// swtch.S
+-void            swtch(struct context*, struct context*);
+-
+-// spinlock.c
+-void            acquire(struct spinlock*);
+-int             holding(struct spinlock*);
+-void            initlock(struct spinlock*, char*);
+-void            release(struct spinlock*);
+-void            push_off(void);
+-void            pop_off(void);
+-
+-// sleeplock.c
+-void            acquiresleep(struct sleeplock*);
+-void            releasesleep(struct sleeplock*);
+-int             holdingsleep(struct sleeplock*);
+-void            initsleeplock(struct sleeplock*, char*);
+-
+-// string.c
+-int             memcmp(const void*, const void*, uint);
+-void*           memmove(void*, const void*, uint);
+-void*           memset(void*, int, uint);
+-char*           safestrcpy(char*, const char*, int);
+-int             strlen(const char*);
+-int             strncmp(const char*, const char*, uint);
+-char*           strncpy(char*, const char*, int);
+-
+-// syscall.c
+-void            argint(int, int*);
+-int             argstr(int, char*, int);
+-void            argaddr(int, uint64 *);
+-int             fetchstr(uint64, char*, int);
+-int             fetchaddr(uint64, uint64*);
+-void            syscall();
+-
+-// trap.c
+-extern uint     ticks;
+-void            trapinit(void);
+-void            trapinithart(void);
+-extern struct spinlock tickslock;
+-void            usertrapret(void);
+-
+-// uart.c
+-void            uartinit(void);
+-void            uartintr(void);
+-void            uartputc(int);
+-void            uartputc_sync(int);
+-int             uartgetc(void);
+-
+-// vm.c
+-void            kvminit(void);
+-void            kvminithart(void);
+-void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
+-int             mappages(pagetable_t, uint64, uint64, uint64, int);
+-pagetable_t     uvmcreate(void);
+-void            uvmfirst(pagetable_t, uchar *, uint);
+-uint64          uvmalloc(pagetable_t, uint64, uint64, int);
+-uint64          uvmdealloc(pagetable_t, uint64, uint64);
+-int             uvmcopy(pagetable_t, pagetable_t, uint64);
+-void            uvmfree(pagetable_t, uint64);
+-void            uvmunmap(pagetable_t, uint64, uint64, int);
+-void            uvmclear(pagetable_t, uint64);
+-pte_t *         walk(pagetable_t, uint64, int);
+-uint64          walkaddr(pagetable_t, uint64);
+-int             copyout(pagetable_t, uint64, char *, uint64);
+-int             copyin(pagetable_t, char *, uint64, uint64);
+-int             copyinstr(pagetable_t, char *, uint64, uint64);
+-
+-// plic.c
+-void            plicinit(void);
+-void            plicinithart(void);
+-int             plic_claim(void);
+-void            plic_complete(int);
+-
+-// virtio_disk.c
+-void            virtio_disk_init(void);
+-void            virtio_disk_rw(struct buf *, int);
+-void            virtio_disk_intr(void);
+-
+-// number of elements in fixed-size array
+-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
++struct buf;
++struct context;
++struct file;
++struct inode;
++struct pipe;
++struct proc;
++struct spinlock;
++struct sleeplock;
++struct stat;
++struct superblock;
++struct swap;
++
++struct live;
++struct live_page_list;
++struct swapped_pages;
++
++// bio.c
++void            binit(void);
++struct buf*     bread(uint, uint);
++void            brelse(struct buf*);
++void            bwrite(struct buf*);
++void            bpin(struct buf*);
++void            bunpin(struct buf*);
++
++// console.c
++void            consoleinit(void);
++void            consoleintr(int);
++void            consputc(int);
++
++// exec.c
++int             exec(char*, char**);
++
++// file.c
++struct file*    filealloc(void);
++void            fileclose(struct file*);
++struct file*    filedup(struct file*);
++void            fileinit(void);
++int             fileread(struct file*, uint64, int n);
++int             filestat(struct file*, uint64 addr);
++int             filewrite(struct file*, uint64, int n);
++
++// fs.c
++void            fsinit(int);
++uint            balloc(uint dev);
++void            bfree(int dev, uint b);
++int             dirlink(struct inode*, char*, uint);
++struct inode*   dirlookup(struct inode*, char*, uint*);
++struct inode*   ialloc(uint, short);
++struct inode*   idup(struct inode*);
++void            iinit();
++void            ilock(struct inode*);
++void            iput(struct inode*);
++void            iunlock(struct inode*);
++void            iunlockput(struct inode*);
++void            iupdate(struct inode*);
++int             namecmp(const char*, const char*);
++struct inode*   namei(char*);
++struct inode*   nameiparent(char*, char*);
++int             readi(struct inode*, int, uint64, uint, uint);
++void            stati(struct inode*, struct stat*);
++int             writei(struct inode*, int, uint64, uint, uint);
++void            itrunc(struct inode*);
++
++// ramdisk.c
++void            ramdiskinit(void);
++void            ramdiskintr(void);
++void            ramdiskrw(struct buf*);
++
++// kalloc.c
++void*           kalloc(void);
++void            kfree(void *);
++void            kinit(void);
++
++// log.c
++void            initlog(int, struct superblock*);
++void            log_write(struct buf*);
++void            begin_op(void);
++void            end_op(void);
++
++// pipe.c
++int             pipealloc(struct file**, struct file**);
++void            pipeclose(struct pipe*, int);
++int             piperead(struct pipe*, uint64, int);
++int             pipewrite(struct pipe*, uint64, int);
++
++// printf.c
++void            printf(char*, ...);
++void            panic(char*) __attribute__((noreturn));
++void            printfinit(void);
++
++// proc.c
++int             cpuid(void);
++void            exit(int);
++int             fork(void);
++int             growproc(int);
++void            proc_mapstacks(pagetable_t);
++pagetable_t     proc_pagetable(struct proc *);
++void            proc_freepagetable(pagetable_t, uint64);
++int             kill(int);
++int             killed(struct proc*);
++void            setkilled(struct proc*);
++struct cpu*     mycpu(void);
++struct cpu*     getmycpu(void);
++struct proc*    myproc();
++void            procinit(void);
++void            scheduler(void) __attribute__((noreturn));
++void            sched(void);
++void            sleep(void*, struct spinlock*);
++void            userinit(void);
++int             wait(uint64);
++void            wakeup(void*);
++void            yield(void);
++int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
++int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
++void            procdump(void);
++
++// swap.c
++void            swapinit(void);
++void            swapfree(struct swap*);
++struct swap*    swapalloc(void);
++void            swapout(struct swap *dst_sp, char *src_pa);
++void            swapin(char *dst_pa, struct swap *src_sp);
++
++// swtch.S
++void            swtch(struct context*, struct context*);
++
++// spinlock.c
++void            acquire(struct spinlock*);
++int             holding(struct spinlock*);
++void            initlock(struct spinlock*, char*);
++void            release(struct spinlock*);
++void            push_off(void);
++void            pop_off(void);
++
++// sleeplock.c
++void            acquiresleep(struct sleeplock*);
++void            releasesleep(struct sleeplock*);
++int             holdingsleep(struct sleeplock*);
++void            initsleeplock(struct sleeplock*, char*);
++
++// string.c
++int             memcmp(const void*, const void*, uint);
++void*           memmove(void*, const void*, uint);
++void*           memset(void*, int, uint);
++char*           safestrcpy(char*, const char*, int);
++int             strlen(const char*);
++int             strncmp(const char*, const char*, uint);
++char*           strncpy(char*, const char*, int);
++
++// syscall.c
++void            argint(int, int*);
++int             argstr(int, char*, int);
++void            argaddr(int, uint64 *);
++int             fetchstr(uint64, char*, int);
++int             fetchaddr(uint64, uint64*);
++void            syscall();
++
++// trap.c
++extern uint     ticks;
++void            trapinit(void);
++void            trapinithart(void);
++extern struct spinlock tickslock;
++void            usertrapret(void);
++
++// uart.c
++void            uartinit(void);
++void            uartintr(void);
++void            uartputc(int);
++void            uartputc_sync(int);
++int             uartgetc(void);
++
++// vm.c
++void            kvminit(void);
++void            kvminithart(void);
++void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
++int             mappages(pagetable_t, uint64, uint64, uint64, int);
++pagetable_t     uvmcreate(void);
++void            uvmfirst(pagetable_t, uchar *, uint);
++uint64          uvmalloc(pagetable_t, uint64, uint64, int);
++uint64          uvmdealloc(pagetable_t, uint64, uint64);
++int             uvmcopy(pagetable_t, pagetable_t, uint64);
++void            uvmfree(pagetable_t, uint64);
++void            uvmunmap(pagetable_t, uint64, uint64, int);
++void            uvmclear(pagetable_t, uint64);
++pte_t *         walk(pagetable_t, uint64, int);
++uint64          walkaddr(pagetable_t, uint64);
++int             copyout(pagetable_t, uint64, char *, uint64);
++int             copyin(pagetable_t, char *, uint64, uint64);
++int             copyinstr(pagetable_t, char *, uint64, uint64);
++uint            swap_out_wrapper();
++struct live     remove_live_page(int);
++void            add_live_page(pagetable_t, uint64, uint64);
++int             list_lookup(uint64);
++void            print_live_list();
++
++// plic.c
++void            plicinit(void);
++void            plicinithart(void);
++int             plic_claim(void);
++void            plic_complete(int);
++
++// virtio_disk.c
++void            virtio_disk_init(void);
++void            virtio_disk_rw(struct buf *, int);
++void            virtio_disk_intr(void);
++
++// number of elements in fixed-size array
++#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+diff --git a/kernel/fs.c b/kernel/fs.c
+index c6bab15..2d9b419 100644
+--- a/kernel/fs.c
++++ b/kernel/fs.c
+@@ -62,7 +62,7 @@ bzero(int dev, int bno)
+ 
+ // Allocate a zeroed disk block.
+ // returns 0 if out of disk space.
+-static uint
++uint
+ balloc(uint dev)
+ {
+   int b, bi, m;
+@@ -88,7 +88,7 @@ balloc(uint dev)
+ }
+ 
+ // Free a disk block.
+-static void
++void
+ bfree(int dev, uint b)
+ {
+   struct buf *bp;
+diff --git a/kernel/kalloc.c b/kernel/kalloc.c
+index 0699e7e..e1d2340 100644
+--- a/kernel/kalloc.c
++++ b/kernel/kalloc.c
+@@ -1,82 +1,104 @@
+-// Physical memory allocator, for user processes,
+-// kernel stacks, page-table pages,
+-// and pipe buffers. Allocates whole 4096-byte pages.
+-
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "spinlock.h"
+-#include "riscv.h"
+-#include "defs.h"
+-
+-void freerange(void *pa_start, void *pa_end);
+-
+-extern char end[]; // first address after kernel.
+-                   // defined by kernel.ld.
+-
+-struct run {
+-  struct run *next;
+-};
+-
+-struct {
+-  struct spinlock lock;
+-  struct run *freelist;
+-} kmem;
+-
+-void
+-kinit()
+-{
+-  initlock(&kmem.lock, "kmem");
+-  freerange(end, (void*)PHYSTOP);
+-}
+-
+-void
+-freerange(void *pa_start, void *pa_end)
+-{
+-  char *p;
+-  p = (char*)PGROUNDUP((uint64)pa_start);
+-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+-    kfree(p);
+-}
+-
+-// Free the page of physical memory pointed at by pa,
+-// which normally should have been returned by a
+-// call to kalloc().  (The exception is when
+-// initializing the allocator; see kinit above.)
+-void
+-kfree(void *pa)
+-{
+-  struct run *r;
+-
+-  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+-    panic("kfree");
+-
+-  // Fill with junk to catch dangling refs.
+-  memset(pa, 1, PGSIZE);
+-
+-  r = (struct run*)pa;
+-
+-  acquire(&kmem.lock);
+-  r->next = kmem.freelist;
+-  kmem.freelist = r;
+-  release(&kmem.lock);
+-}
+-
+-// Allocate one 4096-byte page of physical memory.
+-// Returns a pointer that the kernel can use.
+-// Returns 0 if the memory cannot be allocated.
+-void *
+-kalloc(void)
+-{
+-  struct run *r;
+-
+-  acquire(&kmem.lock);
+-  r = kmem.freelist;
+-  if(r)
+-    kmem.freelist = r->next;
+-  release(&kmem.lock);
+-
+-  if(r)
+-    memset((char*)r, 5, PGSIZE); // fill with junk
+-  return (void*)r;
+-}
++// Physical memory allocator, for user processes,
++// kernel stacks, page-table pages,
++// and pipe buffers. Allocates whole 4096-byte pages.
++
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "defs.h"
++#include "swap.h"
++
++void freerange(void *pa_start, void *pa_end);
++
++extern char end[]; // first address after kernel.
++                   // defined by kernel.ld.
++
++extern struct live_page_list live_list;
++
++struct run {
++  struct run *next;
++};
++
++struct {
++  struct spinlock lock;
++  struct run *freelist;
++} kmem;
++
++// void init_live_pages();
++
++void
++kinit()
++{
++  initlock(&kmem.lock, "kmem");
++  // init_live_pages();
++  initlock(&live_list.lock, "live_list");
++  swapinit();
++  freerange(end, (void*)PHYSTOP);
++}
++
++// void 
++// init_live_pages() {
++//   acquiresleep(&live_list.lock);
++//   for(int i=0;i<MAXPHYPAGES;i++) {
++//     live_list.valid[i] = 0;
++//     // live_list.next_index[i] = -1;
++//   }
++//   live_list.head = 0;
++//   live_list.tail = 0;
++//   live_list.size = 0;
++//   releasesleep(&live_list.lock);
++// }
++
++void
++freerange(void *pa_start, void *pa_end)
++{
++  char *p;
++  p = (char*)PGROUNDUP((uint64)pa_start);
++  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
++    kfree(p);
++}
++
++// Free the page of physical memory pointed at by pa,
++// which normally should have been returned by a
++// call to kalloc().  (The exception is when
++// initializing the allocator; see kinit above.)
++void
++kfree(void *pa)
++{
++  struct run *r;
++
++  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
++    panic("kfree");
++
++  // Fill with junk to catch dangling refs.
++  memset(pa, 1, PGSIZE);
++
++  r = (struct run*)pa;
++
++  acquire(&kmem.lock);
++  r->next = kmem.freelist;
++  kmem.freelist = r;
++  release(&kmem.lock);
++}
++
++// Allocate one 4096-byte page of physical memory.
++// Returns a pointer that the kernel can use.
++// Returns 0 if the memory cannot be allocated.
++void *
++kalloc(void)
++{
++  struct run *r;
++
++  acquire(&kmem.lock);
++  r = kmem.freelist;
++  if(r)
++    kmem.freelist = r->next;
++  release(&kmem.lock);
++
++  if(r) {
++    memset((char*)r, 5, PGSIZE); // fill with junk
++  }
++  return (void*)r;
++}
++
+diff --git a/kernel/proc.c b/kernel/proc.c
+index 959b778..e156d8a 100644
+--- a/kernel/proc.c
++++ b/kernel/proc.c
+@@ -1,683 +1,696 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "riscv.h"
+-#include "spinlock.h"
+-#include "proc.h"
+-#include "defs.h"
+-
+-struct cpu cpus[NCPU];
+-
+-struct proc proc[NPROC];
+-
+-struct proc *initproc;
+-
+-int nextpid = 1;
+-struct spinlock pid_lock;
+-
+-extern void forkret(void);
+-static void freeproc(struct proc *p);
+-
+-extern char trampoline[]; // trampoline.S
+-
+-// helps ensure that wakeups of wait()ing
+-// parents are not lost. helps obey the
+-// memory model when using p->parent.
+-// must be acquired before any p->lock.
+-struct spinlock wait_lock;
+-
+-// Allocate a page for each process's kernel stack.
+-// Map it high in memory, followed by an invalid
+-// guard page.
+-void
+-proc_mapstacks(pagetable_t kpgtbl)
+-{
+-  struct proc *p;
+-  
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    char *pa = kalloc();
+-    if(pa == 0)
+-      panic("kalloc");
+-    uint64 va = KSTACK((int) (p - proc));
+-    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+-  }
+-}
+-
+-// initialize the proc table.
+-void
+-procinit(void)
+-{
+-  struct proc *p;
+-  
+-  initlock(&pid_lock, "nextpid");
+-  initlock(&wait_lock, "wait_lock");
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-      initlock(&p->lock, "proc");
+-      p->state = UNUSED;
+-      p->kstack = KSTACK((int) (p - proc));
+-  }
+-}
+-
+-// Must be called with interrupts disabled,
+-// to prevent race with process being moved
+-// to a different CPU.
+-int
+-cpuid()
+-{
+-  int id = r_tp();
+-  return id;
+-}
+-
+-// Return this CPU's cpu struct.
+-// Interrupts must be disabled.
+-struct cpu*
+-mycpu(void)
+-{
+-  int id = cpuid();
+-  struct cpu *c = &cpus[id];
+-  return c;
+-}
+-
+-// Return the current struct proc *, or zero if none.
+-struct proc*
+-myproc(void)
+-{
+-  push_off();
+-  struct cpu *c = mycpu();
+-  struct proc *p = c->proc;
+-  pop_off();
+-  return p;
+-}
+-
+-int
+-allocpid()
+-{
+-  int pid;
+-  
+-  acquire(&pid_lock);
+-  pid = nextpid;
+-  nextpid = nextpid + 1;
+-  release(&pid_lock);
+-
+-  return pid;
+-}
+-
+-// Look in the process table for an UNUSED proc.
+-// If found, initialize state required to run in the kernel,
+-// and return with p->lock held.
+-// If there are no free procs, or a memory allocation fails, return 0.
+-static struct proc*
+-allocproc(void)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    acquire(&p->lock);
+-    if(p->state == UNUSED) {
+-      goto found;
+-    } else {
+-      release(&p->lock);
+-    }
+-  }
+-  return 0;
+-
+-found:
+-  p->pid = allocpid();
+-  p->state = USED;
+-
+-  // Allocate a trapframe page.
+-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+-    freeproc(p);
+-    release(&p->lock);
+-    return 0;
+-  }
+-
+-  // An empty user page table.
+-  p->pagetable = proc_pagetable(p);
+-  if(p->pagetable == 0){
+-    freeproc(p);
+-    release(&p->lock);
+-    return 0;
+-  }
+-
+-  // Set up new context to start executing at forkret,
+-  // which returns to user space.
+-  memset(&p->context, 0, sizeof(p->context));
+-  p->context.ra = (uint64)forkret;
+-  p->context.sp = p->kstack + PGSIZE;
+-
+-  return p;
+-}
+-
+-// free a proc structure and the data hanging from it,
+-// including user pages.
+-// p->lock must be held.
+-static void
+-freeproc(struct proc *p)
+-{
+-  if(p->trapframe)
+-    kfree((void*)p->trapframe);
+-  p->trapframe = 0;
+-  if(p->pagetable)
+-    proc_freepagetable(p->pagetable, p->sz);
+-  p->pagetable = 0;
+-  p->sz = 0;
+-  p->pid = 0;
+-  p->parent = 0;
+-  p->name[0] = 0;
+-  p->chan = 0;
+-  p->killed = 0;
+-  p->xstate = 0;
+-  p->state = UNUSED;
+-}
+-
+-// Create a user page table for a given process, with no user memory,
+-// but with trampoline and trapframe pages.
+-pagetable_t
+-proc_pagetable(struct proc *p)
+-{
+-  pagetable_t pagetable;
+-
+-  // An empty page table.
+-  pagetable = uvmcreate();
+-  if(pagetable == 0)
+-    return 0;
+-
+-  // map the trampoline code (for system call return)
+-  // at the highest user virtual address.
+-  // only the supervisor uses it, on the way
+-  // to/from user space, so not PTE_U.
+-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
+-              (uint64)trampoline, PTE_R | PTE_X) < 0){
+-    uvmfree(pagetable, 0);
+-    return 0;
+-  }
+-
+-  // map the trapframe page just below the trampoline page, for
+-  // trampoline.S.
+-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
+-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+-    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+-    uvmfree(pagetable, 0);
+-    return 0;
+-  }
+-
+-  return pagetable;
+-}
+-
+-// Free a process's page table, and free the
+-// physical memory it refers to.
+-void
+-proc_freepagetable(pagetable_t pagetable, uint64 sz)
+-{
+-  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+-  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+-  uvmfree(pagetable, sz);
+-}
+-
+-// a user program that calls exec("/init")
+-// assembled from ../user/initcode.S
+-// od -t xC ../user/initcode
+-uchar initcode[] = {
+-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
+-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
+-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
+-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
+-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
+-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
+-  0x00, 0x00, 0x00, 0x00
+-};
+-
+-// Set up first user process.
+-void
+-userinit(void)
+-{
+-  struct proc *p;
+-
+-  p = allocproc();
+-  initproc = p;
+-  
+-  // allocate one user page and copy initcode's instructions
+-  // and data into it.
+-  uvmfirst(p->pagetable, initcode, sizeof(initcode));
+-  p->sz = PGSIZE;
+-
+-  // prepare for the very first "return" from kernel to user.
+-  p->trapframe->epc = 0;      // user program counter
+-  p->trapframe->sp = PGSIZE;  // user stack pointer
+-
+-  safestrcpy(p->name, "initcode", sizeof(p->name));
+-  p->cwd = namei("/");
+-
+-  p->state = RUNNABLE;
+-
+-  release(&p->lock);
+-}
+-
+-// Grow or shrink user memory by n bytes.
+-// Return 0 on success, -1 on failure.
+-int
+-growproc(int n)
+-{
+-  uint64 sz;
+-  struct proc *p = myproc();
+-
+-  sz = p->sz;
+-  if(n > 0){
+-    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+-      return -1;
+-    }
+-  } else if(n < 0){
+-    sz = uvmdealloc(p->pagetable, sz, sz + n);
+-  }
+-  p->sz = sz;
+-  return 0;
+-}
+-
+-// Create a new process, copying the parent.
+-// Sets up child kernel stack to return as if from fork() system call.
+-int
+-fork(void)
+-{
+-  int i, pid;
+-  struct proc *np;
+-  struct proc *p = myproc();
+-
+-  // Allocate process.
+-  if((np = allocproc()) == 0){
+-    return -1;
+-  }
+-
+-  // Copy user memory from parent to child.
+-  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+-    freeproc(np);
+-    release(&np->lock);
+-    return -1;
+-  }
+-  np->sz = p->sz;
+-
+-  // copy saved user registers.
+-  *(np->trapframe) = *(p->trapframe);
+-
+-  // Cause fork to return 0 in the child.
+-  np->trapframe->a0 = 0;
+-
+-  // increment reference counts on open file descriptors.
+-  for(i = 0; i < NOFILE; i++)
+-    if(p->ofile[i])
+-      np->ofile[i] = filedup(p->ofile[i]);
+-  np->cwd = idup(p->cwd);
+-
+-  safestrcpy(np->name, p->name, sizeof(p->name));
+-
+-  pid = np->pid;
+-
+-  release(&np->lock);
+-
+-  acquire(&wait_lock);
+-  np->parent = p;
+-  release(&wait_lock);
+-
+-  acquire(&np->lock);
+-  np->state = RUNNABLE;
+-  release(&np->lock);
+-
+-  return pid;
+-}
+-
+-// Pass p's abandoned children to init.
+-// Caller must hold wait_lock.
+-void
+-reparent(struct proc *p)
+-{
+-  struct proc *pp;
+-
+-  for(pp = proc; pp < &proc[NPROC]; pp++){
+-    if(pp->parent == p){
+-      pp->parent = initproc;
+-      wakeup(initproc);
+-    }
+-  }
+-}
+-
+-// Exit the current process.  Does not return.
+-// An exited process remains in the zombie state
+-// until its parent calls wait().
+-void
+-exit(int status)
+-{
+-  struct proc *p = myproc();
+-
+-  if(p == initproc)
+-    panic("init exiting");
+-
+-  // Close all open files.
+-  for(int fd = 0; fd < NOFILE; fd++){
+-    if(p->ofile[fd]){
+-      struct file *f = p->ofile[fd];
+-      fileclose(f);
+-      p->ofile[fd] = 0;
+-    }
+-  }
+-
+-  begin_op();
+-  iput(p->cwd);
+-  end_op();
+-  p->cwd = 0;
+-
+-  acquire(&wait_lock);
+-
+-  // Give any children to init.
+-  reparent(p);
+-
+-  // Parent might be sleeping in wait().
+-  wakeup(p->parent);
+-  
+-  acquire(&p->lock);
+-
+-  p->xstate = status;
+-  p->state = ZOMBIE;
+-
+-  release(&wait_lock);
+-
+-  // Jump into the scheduler, never to return.
+-  sched();
+-  panic("zombie exit");
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-wait(uint64 addr)
+-{
+-  struct proc *pp;
+-  int havekids, pid;
+-  struct proc *p = myproc();
+-
+-  acquire(&wait_lock);
+-
+-  for(;;){
+-    // Scan through table looking for exited children.
+-    havekids = 0;
+-    for(pp = proc; pp < &proc[NPROC]; pp++){
+-      if(pp->parent == p){
+-        // make sure the child isn't still in exit() or swtch().
+-        acquire(&pp->lock);
+-
+-        havekids = 1;
+-        if(pp->state == ZOMBIE){
+-          // Found one.
+-          pid = pp->pid;
+-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+-                                  sizeof(pp->xstate)) < 0) {
+-            release(&pp->lock);
+-            release(&wait_lock);
+-            return -1;
+-          }
+-          freeproc(pp);
+-          release(&pp->lock);
+-          release(&wait_lock);
+-          return pid;
+-        }
+-        release(&pp->lock);
+-      }
+-    }
+-
+-    // No point waiting if we don't have any children.
+-    if(!havekids || killed(p)){
+-      release(&wait_lock);
+-      return -1;
+-    }
+-    
+-    // Wait for a child to exit.
+-    sleep(p, &wait_lock);  //DOC: wait-sleep
+-  }
+-}
+-
+-// Per-CPU process scheduler.
+-// Each CPU calls scheduler() after setting itself up.
+-// Scheduler never returns.  It loops, doing:
+-//  - choose a process to run.
+-//  - swtch to start running that process.
+-//  - eventually that process transfers control
+-//    via swtch back to the scheduler.
+-void
+-scheduler(void)
+-{
+-  struct proc *p;
+-  struct cpu *c = mycpu();
+-  
+-  c->proc = 0;
+-  for(;;){
+-    // Avoid deadlock by ensuring that devices can interrupt.
+-    intr_on();
+-
+-    for(p = proc; p < &proc[NPROC]; p++) {
+-      acquire(&p->lock);
+-      if(p->state == RUNNABLE) {
+-        // Switch to chosen process.  It is the process's job
+-        // to release its lock and then reacquire it
+-        // before jumping back to us.
+-        p->state = RUNNING;
+-        c->proc = p;
+-        swtch(&c->context, &p->context);
+-
+-        // Process is done running for now.
+-        // It should have changed its p->state before coming back.
+-        c->proc = 0;
+-      }
+-      release(&p->lock);
+-    }
+-  }
+-}
+-
+-// Switch to scheduler.  Must hold only p->lock
+-// and have changed proc->state. Saves and restores
+-// intena because intena is a property of this
+-// kernel thread, not this CPU. It should
+-// be proc->intena and proc->noff, but that would
+-// break in the few places where a lock is held but
+-// there's no process.
+-void
+-sched(void)
+-{
+-  int intena;
+-  struct proc *p = myproc();
+-
+-  if(!holding(&p->lock))
+-    panic("sched p->lock");
+-  if(mycpu()->noff != 1)
+-    panic("sched locks");
+-  if(p->state == RUNNING)
+-    panic("sched running");
+-  if(intr_get())
+-    panic("sched interruptible");
+-
+-  intena = mycpu()->intena;
+-  swtch(&p->context, &mycpu()->context);
+-  mycpu()->intena = intena;
+-}
+-
+-// Give up the CPU for one scheduling round.
+-void
+-yield(void)
+-{
+-  struct proc *p = myproc();
+-  acquire(&p->lock);
+-  p->state = RUNNABLE;
+-  sched();
+-  release(&p->lock);
+-}
+-
+-// A fork child's very first scheduling by scheduler()
+-// will swtch to forkret.
+-void
+-forkret(void)
+-{
+-  static int first = 1;
+-
+-  // Still holding p->lock from scheduler.
+-  release(&myproc()->lock);
+-
+-  if (first) {
+-    // File system initialization must be run in the context of a
+-    // regular process (e.g., because it calls sleep), and thus cannot
+-    // be run from main().
+-    first = 0;
+-    fsinit(ROOTDEV);
+-  }
+-
+-  usertrapret();
+-}
+-
+-// Atomically release lock and sleep on chan.
+-// Reacquires lock when awakened.
+-void
+-sleep(void *chan, struct spinlock *lk)
+-{
+-  struct proc *p = myproc();
+-  
+-  // Must acquire p->lock in order to
+-  // change p->state and then call sched.
+-  // Once we hold p->lock, we can be
+-  // guaranteed that we won't miss any wakeup
+-  // (wakeup locks p->lock),
+-  // so it's okay to release lk.
+-
+-  acquire(&p->lock);  //DOC: sleeplock1
+-  release(lk);
+-
+-  // Go to sleep.
+-  p->chan = chan;
+-  p->state = SLEEPING;
+-
+-  sched();
+-
+-  // Tidy up.
+-  p->chan = 0;
+-
+-  // Reacquire original lock.
+-  release(&p->lock);
+-  acquire(lk);
+-}
+-
+-// Wake up all processes sleeping on chan.
+-// Must be called without any p->lock.
+-void
+-wakeup(void *chan)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    if(p != myproc()){
+-      acquire(&p->lock);
+-      if(p->state == SLEEPING && p->chan == chan) {
+-        p->state = RUNNABLE;
+-      }
+-      release(&p->lock);
+-    }
+-  }
+-}
+-
+-// Kill the process with the given pid.
+-// The victim won't exit until it tries to return
+-// to user space (see usertrap() in trap.c).
+-int
+-kill(int pid)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++){
+-    acquire(&p->lock);
+-    if(p->pid == pid){
+-      p->killed = 1;
+-      if(p->state == SLEEPING){
+-        // Wake process from sleep().
+-        p->state = RUNNABLE;
+-      }
+-      release(&p->lock);
+-      return 0;
+-    }
+-    release(&p->lock);
+-  }
+-  return -1;
+-}
+-
+-void
+-setkilled(struct proc *p)
+-{
+-  acquire(&p->lock);
+-  p->killed = 1;
+-  release(&p->lock);
+-}
+-
+-int
+-killed(struct proc *p)
+-{
+-  int k;
+-  
+-  acquire(&p->lock);
+-  k = p->killed;
+-  release(&p->lock);
+-  return k;
+-}
+-
+-// Copy to either a user address, or kernel address,
+-// depending on usr_dst.
+-// Returns 0 on success, -1 on error.
+-int
+-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+-{
+-  struct proc *p = myproc();
+-  if(user_dst){
+-    return copyout(p->pagetable, dst, src, len);
+-  } else {
+-    memmove((char *)dst, src, len);
+-    return 0;
+-  }
+-}
+-
+-// Copy from either a user address, or kernel address,
+-// depending on usr_src.
+-// Returns 0 on success, -1 on error.
+-int
+-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+-{
+-  struct proc *p = myproc();
+-  if(user_src){
+-    return copyin(p->pagetable, dst, src, len);
+-  } else {
+-    memmove(dst, (char*)src, len);
+-    return 0;
+-  }
+-}
+-
+-// Print a process listing to console.  For debugging.
+-// Runs when user types ^P on console.
+-// No lock to avoid wedging a stuck machine further.
+-void
+-procdump(void)
+-{
+-  static char *states[] = {
+-  [UNUSED]    "unused",
+-  [USED]      "used",
+-  [SLEEPING]  "sleep ",
+-  [RUNNABLE]  "runble",
+-  [RUNNING]   "run   ",
+-  [ZOMBIE]    "zombie"
+-  };
+-  struct proc *p;
+-  char *state;
+-
+-  printf("\n");
+-  for(p = proc; p < &proc[NPROC]; p++){
+-    if(p->state == UNUSED)
+-      continue;
+-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-      state = states[p->state];
+-    else
+-      state = "???";
+-    printf("%d %s %s", p->pid, state, p->name);
+-    printf("\n");
+-  }
+-}
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "spinlock.h"
++#include "proc.h"
++#include "defs.h"
++
++int global_swap_flag;
++
++struct cpu cpus[NCPU];
++
++struct proc proc[NPROC];
++
++struct proc *initproc;
++
++int nextpid = 1;
++struct spinlock pid_lock;
++
++extern void forkret(void);
++static void freeproc(struct proc *p);
++
++extern char trampoline[]; // trampoline.S
++
++// helps ensure that wakeups of wait()ing
++// parents are not lost. helps obey the
++// memory model when using p->parent.
++// must be acquired before any p->lock.
++struct spinlock wait_lock;
++
++// Allocate a page for each process's kernel stack.
++// Map it high in memory, followed by an invalid
++// guard page.
++void
++proc_mapstacks(pagetable_t kpgtbl)
++{
++  struct proc *p;
++  
++  for(p = proc; p < &proc[NPROC]; p++) {
++    char *pa = kalloc();
++    if(pa == 0)
++      panic("kalloc");
++    uint64 va = KSTACK((int) (p - proc));
++    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
++  }
++}
++
++// initialize the proc table.
++void
++procinit(void)
++{
++  struct proc *p;
++  
++  initlock(&pid_lock, "nextpid");
++  initlock(&wait_lock, "wait_lock");
++  for(p = proc; p < &proc[NPROC]; p++) {
++      initlock(&p->lock, "proc");
++      p->state = UNUSED;
++      p->kstack = KSTACK((int) (p - proc));
++  }
++}
++
++// Must be called with interrupts disabled,
++// to prevent race with process being moved
++// to a different CPU.
++int
++cpuid()
++{
++  int id = r_tp();
++  return id;
++}
++
++// Return this CPU's cpu struct.
++// Interrupts must be disabled.
++struct cpu*
++mycpu(void)
++{
++  int id = cpuid();
++  struct cpu *c = &cpus[id];
++  return c;
++}
++
++// Return the current struct proc *, or zero if none.
++struct proc*
++myproc(void)
++{
++  push_off();
++  struct cpu *c = mycpu();
++  struct proc *p = c->proc;
++  pop_off();
++  return p;
++}
++
++int
++allocpid()
++{
++  int pid;
++  
++  acquire(&pid_lock);
++  pid = nextpid;
++  nextpid = nextpid + 1;
++  release(&pid_lock);
++
++  return pid;
++}
++
++// Look in the process table for an UNUSED proc.
++// If found, initialize state required to run in the kernel,
++// and return with p->lock held.
++// If there are no free procs, or a memory allocation fails, return 0.
++static struct proc*
++allocproc(void)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++) {
++    acquire(&p->lock);
++    if(p->state == UNUSED) {
++      goto found;
++    } else {
++      release(&p->lock);
++    }
++  }
++  return 0;
++
++found:
++  p->pid = allocpid();
++  p->state = USED;
++
++  // Allocate a trapframe page.
++  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
++    freeproc(p);
++    release(&p->lock);
++    return 0;
++  }
++
++  // An empty user page table.
++  p->pagetable = proc_pagetable(p);
++  if(p->pagetable == 0){
++    freeproc(p);
++    release(&p->lock);
++    return 0;
++  }
++
++  // Set up new context to start executing at forkret,
++  // which returns to user space.
++  memset(&p->context, 0, sizeof(p->context));
++  p->context.ra = (uint64)forkret;
++  p->context.sp = p->kstack + PGSIZE;
++
++  return p;
++}
++
++// free a proc structure and the data hanging from it,
++// including user pages.
++// p->lock must be held.
++static void
++freeproc(struct proc *p)
++{
++  if(p->trapframe)
++    kfree((void*)p->trapframe);
++  p->trapframe = 0;
++  if(p->pagetable)
++    proc_freepagetable(p->pagetable, p->sz);
++  p->pagetable = 0;
++  p->sz = 0;
++  p->pid = 0;
++  p->parent = 0;
++  p->name[0] = 0;
++  p->chan = 0;
++  p->killed = 0;
++  p->xstate = 0;
++  p->state = UNUSED;
++}
++
++// Create a user page table for a given process, with no user memory,
++// but with trampoline and trapframe pages.
++pagetable_t
++proc_pagetable(struct proc *p)
++{
++  pagetable_t pagetable;
++
++  // An empty page table.
++  pagetable = uvmcreate();
++  if(pagetable == 0)
++    return 0;
++
++  // map the trampoline code (for system call return)
++  // at the highest user virtual address.
++  // only the supervisor uses it, on the way
++  // to/from user space, so not PTE_U.
++  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
++              (uint64)trampoline, PTE_R | PTE_X) < 0){
++    uvmfree(pagetable, 0);
++    return 0;
++  }
++
++  // map the trapframe page just below the trampoline page, for
++  // trampoline.S.
++  if(mappages(pagetable, TRAPFRAME, PGSIZE,
++              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
++    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
++    uvmfree(pagetable, 0);
++    return 0;
++  }
++
++  return pagetable;
++}
++
++// Free a process's page table, and free the
++// physical memory it refers to.
++void
++proc_freepagetable(pagetable_t pagetable, uint64 sz)
++{
++  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
++  uvmunmap(pagetable, TRAPFRAME, 1, 0);
++  uvmfree(pagetable, sz);
++}
++
++// a user program that calls exec("/init")
++// assembled from ../user/initcode.S
++// od -t xC ../user/initcode
++uchar initcode[] = {
++  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
++  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
++  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
++  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
++  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
++  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x00, 0x00, 0x00
++};
++
++// Set up first user process.
++void
++userinit(void)
++{
++  struct proc *p;
++
++  p = allocproc();
++  initproc = p;
++  
++  // allocate one user page and copy initcode's instructions
++  // and data into it.
++  uvmfirst(p->pagetable, initcode, sizeof(initcode));
++  p->sz = PGSIZE;
++
++  // prepare for the very first "return" from kernel to user.
++  p->trapframe->epc = 0;      // user program counter
++  p->trapframe->sp = PGSIZE;  // user stack pointer
++
++  safestrcpy(p->name, "initcode", sizeof(p->name));
++  p->cwd = namei("/");
++
++  p->state = RUNNABLE;
++
++  release(&p->lock);
++}
++
++// Grow or shrink user memory by n bytes.
++// Return 0 on success, -1 on failure.
++int
++growproc(int n)
++{
++  uint64 sz;
++  struct proc *p = myproc();
++
++  sz = p->sz;
++  
++  if(n > 0){
++    // printf("entering growproc with global swap flag %d, n = %d, sz = %d\n", global_swap_flag, n, sz);
++    global_swap_flag = 1;
++    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
++      return -1;
++    }
++  } else if(n < 0){
++    sz = uvmdealloc(p->pagetable, sz, sz + n);
++  }
++  p->sz = sz;
++  return 0;
++}
++
++// Create a new process, copying the parent.
++// Sets up child kernel stack to return as if from fork() system call.
++int
++fork(void)
++{
++  int i, pid;
++  struct proc *np;
++  struct proc *p = myproc();
++
++  // Allocate process.
++  if((np = allocproc()) == 0){
++    return -1;
++  }
++
++  // Copy user memory from parent to child.
++    release(&np->lock);
++  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
++    freeproc(np);
++    return -1;
++  }
++  acquire(&np->lock);
++  np->sz = p->sz;
++
++  // copy saved user registers.
++  *(np->trapframe) = *(p->trapframe);
++
++  // Cause fork to return 0 in the child.
++  np->trapframe->a0 = 0;
++
++  // increment reference counts on open file descriptors.
++  for(i = 0; i < NOFILE; i++)
++    if(p->ofile[i])
++      np->ofile[i] = filedup(p->ofile[i]);
++  np->cwd = idup(p->cwd);
++
++  safestrcpy(np->name, p->name, sizeof(p->name));
++
++  pid = np->pid;
++
++  release(&np->lock);
++
++  acquire(&wait_lock);
++  np->parent = p;
++  release(&wait_lock);
++
++  acquire(&np->lock);
++  np->state = RUNNABLE;
++  release(&np->lock);
++
++  return pid;
++}
++
++// Pass p's abandoned children to init.
++// Caller must hold wait_lock.
++void
++reparent(struct proc *p)
++{
++  struct proc *pp;
++
++  for(pp = proc; pp < &proc[NPROC]; pp++){
++    if(pp->parent == p){
++      pp->parent = initproc;
++      wakeup(initproc);
++    }
++  }
++}
++
++// Exit the current process.  Does not return.
++// An exited process remains in the zombie state
++// until its parent calls wait().
++void
++exit(int status)
++{
++  struct proc *p = myproc();
++
++  if(p == initproc)
++    panic("init exiting");
++
++  // Close all open files.
++  for(int fd = 0; fd < NOFILE; fd++){
++    if(p->ofile[fd]){
++      struct file *f = p->ofile[fd];
++      fileclose(f);
++      p->ofile[fd] = 0;
++    }
++  }
++
++  begin_op();
++  iput(p->cwd);
++  end_op();
++  p->cwd = 0;
++
++  acquire(&wait_lock);
++  // Give any children to init.
++  reparent(p);
++
++  // Parent might be sleeping in wait().
++  wakeup(p->parent);
++  
++  acquire(&p->lock);
++
++  p->xstate = status;
++  p->state = ZOMBIE;
++
++  release(&wait_lock);
++
++  // Jump into the scheduler, never to return.
++  sched();
++  panic("zombie exit");
++}
++
++// Wait for a child process to exit and return its pid.
++// Return -1 if this process has no children.
++int
++wait(uint64 addr)
++{
++  struct proc *pp;
++  int havekids, pid;
++  struct proc *p = myproc();
++
++  acquire(&wait_lock);
++
++  for(;;){
++    // Scan through table looking for exited children.
++    havekids = 0;
++    for(pp = proc; pp < &proc[NPROC]; pp++){
++      if(pp->parent == p){
++        // make sure the child isn't still in exit() or swtch().
++        acquire(&pp->lock);
++
++        havekids = 1;
++        if(pp->state == ZOMBIE){
++          // Found one.
++          pid = pp->pid;
++          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
++                                  sizeof(pp->xstate)) < 0) {
++            release(&pp->lock);
++            release(&wait_lock);
++
++            return -1;
++          }
++          // freeproc(pp);
++          release(&pp->lock);
++          release(&wait_lock);
++
++          /* crazy stuff*/
++          //printf("freeproc starting\n");
++          freeproc(pp);
++          //printf("freeproc ended\n");
++          
++          return pid;
++        }
++        release(&pp->lock);
++      }
++    }
++
++    // No point waiting if we don't have any children.
++    if(!havekids || killed(p)){
++      release(&wait_lock);
++      return -1;
++    }
++    
++    // Wait for a child to exit.
++    sleep(p, &wait_lock);  //DOC: wait-sleep
++  }
++}
++
++// Per-CPU process scheduler.
++// Each CPU calls scheduler() after setting itself up.
++// Scheduler never returns.  It loops, doing:
++//  - choose a process to run.
++//  - swtch to start running that process.
++//  - eventually that process transfers control
++//    via swtch back to the scheduler.
++void
++scheduler(void)
++{
++  struct proc *p;
++  struct cpu *c = mycpu();
++  
++  c->proc = 0;
++  for(;;){
++    // Avoid deadlock by ensuring that devices can interrupt.
++    intr_on();
++
++    for(p = proc; p < &proc[NPROC]; p++) {
++      acquire(&p->lock);
++      if(p->state == RUNNABLE) {
++        // Switch to chosen process.  It is the process's job
++        // to release its lock and then reacquire it
++        // before jumping back to us.
++        p->state = RUNNING;
++        c->proc = p;
++        swtch(&c->context, &p->context);
++
++        // Process is done running for now.
++        // It should have changed its p->state before coming back.
++        c->proc = 0;
++      }
++      release(&p->lock);
++    }
++  }
++}
++
++// Switch to scheduler.  Must hold only p->lock
++// and have changed proc->state. Saves and restores
++// intena because intena is a property of this
++// kernel thread, not this CPU. It should
++// be proc->intena and proc->noff, but that would
++// break in the few places where a lock is held but
++// there's no process.
++void
++sched(void)
++{
++  int intena;
++  struct proc *p = myproc();
++
++  if(!holding(&p->lock))
++    panic("sched p->lock");
++  if(mycpu()->noff != 1)
++    panic("sched locks");
++  if(p->state == RUNNING)
++    panic("sched running");
++  if(intr_get())
++    panic("sched interruptible");
++
++  intena = mycpu()->intena;
++  swtch(&p->context, &mycpu()->context);
++  mycpu()->intena = intena;
++}
++
++// Give up the CPU for one scheduling round.
++void
++yield(void)
++{
++  struct proc *p = myproc();
++  acquire(&p->lock);
++  p->state = RUNNABLE;
++  sched();
++  release(&p->lock);
++}
++
++// A fork child's very first scheduling by scheduler()
++// will swtch to forkret.
++void
++forkret(void)
++{
++  static int first = 1;
++
++  // Still holding p->lock from scheduler.
++  release(&myproc()->lock);
++
++  if (first) {
++    // File system initialization must be run in the context of a
++    // regular process (e.g., because it calls sleep), and thus cannot
++    // be run from main().
++    first = 0;
++    fsinit(ROOTDEV);
++  }
++
++  usertrapret();
++}
++
++// Atomically release lock and sleep on chan.
++// Reacquires lock when awakened.
++void
++sleep(void *chan, struct spinlock *lk)
++{
++  struct proc *p = myproc();
++  
++  // Must acquire p->lock in order to
++  // change p->state and then call sched.
++  // Once we hold p->lock, we can be
++  // guaranteed that we won't miss any wakeup
++  // (wakeup locks p->lock),
++  // so it's okay to release lk.
++
++  acquire(&p->lock);  //DOC: sleeplock1
++  release(lk);
++
++  // Go to sleep.
++  p->chan = chan;
++  p->state = SLEEPING;
++
++  sched();
++
++  // Tidy up.
++  p->chan = 0;
++
++  // Reacquire original lock.
++  release(&p->lock);
++  acquire(lk);
++}
++
++// Wake up all processes sleeping on chan.
++// Must be called without any p->lock.
++void
++wakeup(void *chan)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++) {
++    if(p != myproc()){
++      // printf("lock process %d\n", p->pid);
++      acquire(&p->lock);
++      if(p->state == SLEEPING && p->chan == chan) {
++        p->state = RUNNABLE;
++      }
++      release(&p->lock);
++    }
++  }
++}
++
++// Kill the process with the given pid.
++// The victim won't exit until it tries to return
++// to user space (see usertrap() in trap.c).
++int
++kill(int pid)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++){
++    acquire(&p->lock);
++    if(p->pid == pid){
++      p->killed = 1;
++      if(p->state == SLEEPING){
++        // Wake process from sleep().
++        p->state = RUNNABLE;
++      }
++      release(&p->lock);
++      return 0;
++    }
++    release(&p->lock);
++  }
++  return -1;
++}
++
++void
++setkilled(struct proc *p)
++{
++  acquire(&p->lock);
++  p->killed = 1;
++  release(&p->lock);
++}
++
++int
++killed(struct proc *p)
++{
++  int k;
++  
++  acquire(&p->lock);
++  k = p->killed;
++  release(&p->lock);
++  return k;
++}
++
++// Copy to either a user address, or kernel address,
++// depending on usr_dst.
++// Returns 0 on success, -1 on error.
++int
++either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
++{
++  struct proc *p = myproc();
++  if(user_dst){
++    return copyout(p->pagetable, dst, src, len);
++  } else {
++    memmove((char *)dst, src, len);
++    return 0;
++  }
++}
++
++// Copy from either a user address, or kernel address,
++// depending on usr_src.
++// Returns 0 on success, -1 on error.
++int
++either_copyin(void *dst, int user_src, uint64 src, uint64 len)
++{
++  struct proc *p = myproc();
++  if(user_src){
++    return copyin(p->pagetable, dst, src, len);
++  } else {
++    memmove(dst, (char*)src, len);
++    return 0;
++  }
++}
++
++// Print a process listing to console.  For debugging.
++// Runs when user types ^P on console.
++// No lock to avoid wedging a stuck machine further.
++void
++procdump(void)
++{
++  static char *states[] = {
++  [UNUSED]    "unused",
++  [USED]      "used",
++  [SLEEPING]  "sleep ",
++  [RUNNABLE]  "runble",
++  [RUNNING]   "run   ",
++  [ZOMBIE]    "zombie"
++  };
++  struct proc *p;
++  char *state;
++
++  printf("\n");
++  for(p = proc; p < &proc[NPROC]; p++){
++    if(p->state == UNUSED)
++      continue;
++    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++      state = states[p->state];
++    else
++      state = "???";
++    printf("%d %s %s", p->pid, state, p->name);
++    printf("\n");
++  }
++}
+diff --git a/kernel/riscv.h b/kernel/riscv.h
+index 20a01db..5da3579 100644
+--- a/kernel/riscv.h
++++ b/kernel/riscv.h
+@@ -1,363 +1,366 @@
+-#ifndef __ASSEMBLER__
+-
+-// which hart (core) is this?
+-static inline uint64
+-r_mhartid()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mhartid" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine Status Register, mstatus
+-
+-#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
+-#define MSTATUS_MPP_M (3L << 11)
+-#define MSTATUS_MPP_S (1L << 11)
+-#define MSTATUS_MPP_U (0L << 11)
+-#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
+-
+-static inline uint64
+-r_mstatus()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mstatus" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mstatus(uint64 x)
+-{
+-  asm volatile("csrw mstatus, %0" : : "r" (x));
+-}
+-
+-// machine exception program counter, holds the
+-// instruction address to which a return from
+-// exception will go.
+-static inline void 
+-w_mepc(uint64 x)
+-{
+-  asm volatile("csrw mepc, %0" : : "r" (x));
+-}
+-
+-// Supervisor Status Register, sstatus
+-
+-#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
+-#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
+-#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
+-#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
+-#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
+-
+-static inline uint64
+-r_sstatus()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sstatus" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sstatus(uint64 x)
+-{
+-  asm volatile("csrw sstatus, %0" : : "r" (x));
+-}
+-
+-// Supervisor Interrupt Pending
+-static inline uint64
+-r_sip()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sip" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sip(uint64 x)
+-{
+-  asm volatile("csrw sip, %0" : : "r" (x));
+-}
+-
+-// Supervisor Interrupt Enable
+-#define SIE_SEIE (1L << 9) // external
+-#define SIE_STIE (1L << 5) // timer
+-#define SIE_SSIE (1L << 1) // software
+-static inline uint64
+-r_sie()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sie" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sie(uint64 x)
+-{
+-  asm volatile("csrw sie, %0" : : "r" (x));
+-}
+-
+-// Machine-mode Interrupt Enable
+-#define MIE_MEIE (1L << 11) // external
+-#define MIE_MTIE (1L << 7)  // timer
+-#define MIE_MSIE (1L << 3)  // software
+-static inline uint64
+-r_mie()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mie" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mie(uint64 x)
+-{
+-  asm volatile("csrw mie, %0" : : "r" (x));
+-}
+-
+-// supervisor exception program counter, holds the
+-// instruction address to which a return from
+-// exception will go.
+-static inline void 
+-w_sepc(uint64 x)
+-{
+-  asm volatile("csrw sepc, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_sepc()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sepc" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine Exception Delegation
+-static inline uint64
+-r_medeleg()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, medeleg" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_medeleg(uint64 x)
+-{
+-  asm volatile("csrw medeleg, %0" : : "r" (x));
+-}
+-
+-// Machine Interrupt Delegation
+-static inline uint64
+-r_mideleg()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mideleg" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mideleg(uint64 x)
+-{
+-  asm volatile("csrw mideleg, %0" : : "r" (x));
+-}
+-
+-// Supervisor Trap-Vector Base Address
+-// low two bits are mode.
+-static inline void 
+-w_stvec(uint64 x)
+-{
+-  asm volatile("csrw stvec, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_stvec()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, stvec" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine-mode interrupt vector
+-static inline void 
+-w_mtvec(uint64 x)
+-{
+-  asm volatile("csrw mtvec, %0" : : "r" (x));
+-}
+-
+-// Physical Memory Protection
+-static inline void
+-w_pmpcfg0(uint64 x)
+-{
+-  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
+-}
+-
+-static inline void
+-w_pmpaddr0(uint64 x)
+-{
+-  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
+-}
+-
+-// use riscv's sv39 page table scheme.
+-#define SATP_SV39 (8L << 60)
+-
+-#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
+-
+-// supervisor address translation and protection;
+-// holds the address of the page table.
+-static inline void 
+-w_satp(uint64 x)
+-{
+-  asm volatile("csrw satp, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_satp()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, satp" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mscratch(uint64 x)
+-{
+-  asm volatile("csrw mscratch, %0" : : "r" (x));
+-}
+-
+-// Supervisor Trap Cause
+-static inline uint64
+-r_scause()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, scause" : "=r" (x) );
+-  return x;
+-}
+-
+-// Supervisor Trap Value
+-static inline uint64
+-r_stval()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, stval" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine-mode Counter-Enable
+-static inline void 
+-w_mcounteren(uint64 x)
+-{
+-  asm volatile("csrw mcounteren, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_mcounteren()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mcounteren" : "=r" (x) );
+-  return x;
+-}
+-
+-// machine-mode cycle counter
+-static inline uint64
+-r_time()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, time" : "=r" (x) );
+-  return x;
+-}
+-
+-// enable device interrupts
+-static inline void
+-intr_on()
+-{
+-  w_sstatus(r_sstatus() | SSTATUS_SIE);
+-}
+-
+-// disable device interrupts
+-static inline void
+-intr_off()
+-{
+-  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+-}
+-
+-// are device interrupts enabled?
+-static inline int
+-intr_get()
+-{
+-  uint64 x = r_sstatus();
+-  return (x & SSTATUS_SIE) != 0;
+-}
+-
+-static inline uint64
+-r_sp()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, sp" : "=r" (x) );
+-  return x;
+-}
+-
+-// read and write tp, the thread pointer, which xv6 uses to hold
+-// this core's hartid (core number), the index into cpus[].
+-static inline uint64
+-r_tp()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, tp" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_tp(uint64 x)
+-{
+-  asm volatile("mv tp, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_ra()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, ra" : "=r" (x) );
+-  return x;
+-}
+-
+-// flush the TLB.
+-static inline void
+-sfence_vma()
+-{
+-  // the zero, zero means flush all TLB entries.
+-  asm volatile("sfence.vma zero, zero");
+-}
+-
+-typedef uint64 pte_t;
+-typedef uint64 *pagetable_t; // 512 PTEs
+-
+-#endif // __ASSEMBLER__
+-
+-#define PGSIZE 4096 // bytes per page
+-#define PGSHIFT 12  // bits of offset within a page
+-
+-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+-
+-#define PTE_V (1L << 0) // valid
+-#define PTE_R (1L << 1)
+-#define PTE_W (1L << 2)
+-#define PTE_X (1L << 3)
+-#define PTE_U (1L << 4) // user can access
+-
+-// shift a physical address to the right place for a PTE.
+-#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
+-
+-#define PTE2PA(pte) (((pte) >> 10) << 12)
+-
+-#define PTE_FLAGS(pte) ((pte) & 0x3FF)
+-
+-// extract the three 9-bit page table indices from a virtual address.
+-#define PXMASK          0x1FF // 9 bits
+-#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
+-#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
+-
+-// one beyond the highest possible virtual address.
+-// MAXVA is actually one bit less than the max allowed by
+-// Sv39, to avoid having to sign-extend virtual addresses
+-// that have the high bit set.
+-#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
++#ifndef __ASSEMBLER__
++
++// which hart (core) is this?
++static inline uint64
++r_mhartid()
++{
++  uint64 x;
++  asm volatile("csrr %0, mhartid" : "=r" (x) );
++  return x;
++}
++
++// Machine Status Register, mstatus
++
++#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
++#define MSTATUS_MPP_M (3L << 11)
++#define MSTATUS_MPP_S (1L << 11)
++#define MSTATUS_MPP_U (0L << 11)
++#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
++
++static inline uint64
++r_mstatus()
++{
++  uint64 x;
++  asm volatile("csrr %0, mstatus" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mstatus(uint64 x)
++{
++  asm volatile("csrw mstatus, %0" : : "r" (x));
++}
++
++// machine exception program counter, holds the
++// instruction address to which a return from
++// exception will go.
++static inline void 
++w_mepc(uint64 x)
++{
++  asm volatile("csrw mepc, %0" : : "r" (x));
++}
++
++// Supervisor Status Register, sstatus
++
++#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
++#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
++#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
++#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
++#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
++
++static inline uint64
++r_sstatus()
++{
++  uint64 x;
++  asm volatile("csrr %0, sstatus" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sstatus(uint64 x)
++{
++  asm volatile("csrw sstatus, %0" : : "r" (x));
++}
++
++// Supervisor Interrupt Pending
++static inline uint64
++r_sip()
++{
++  uint64 x;
++  asm volatile("csrr %0, sip" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sip(uint64 x)
++{
++  asm volatile("csrw sip, %0" : : "r" (x));
++}
++
++// Supervisor Interrupt Enable
++#define SIE_SEIE (1L << 9) // external
++#define SIE_STIE (1L << 5) // timer
++#define SIE_SSIE (1L << 1) // software
++static inline uint64
++r_sie()
++{
++  uint64 x;
++  asm volatile("csrr %0, sie" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sie(uint64 x)
++{
++  asm volatile("csrw sie, %0" : : "r" (x));
++}
++
++// Machine-mode Interrupt Enable
++#define MIE_MEIE (1L << 11) // external
++#define MIE_MTIE (1L << 7)  // timer
++#define MIE_MSIE (1L << 3)  // software
++static inline uint64
++r_mie()
++{
++  uint64 x;
++  asm volatile("csrr %0, mie" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mie(uint64 x)
++{
++  asm volatile("csrw mie, %0" : : "r" (x));
++}
++
++// supervisor exception program counter, holds the
++// instruction address to which a return from
++// exception will go.
++static inline void 
++w_sepc(uint64 x)
++{
++  asm volatile("csrw sepc, %0" : : "r" (x));
++}
++
++static inline uint64
++r_sepc()
++{
++  uint64 x;
++  asm volatile("csrr %0, sepc" : "=r" (x) );
++  return x;
++}
++
++// Machine Exception Delegation
++static inline uint64
++r_medeleg()
++{
++  uint64 x;
++  asm volatile("csrr %0, medeleg" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_medeleg(uint64 x)
++{
++  asm volatile("csrw medeleg, %0" : : "r" (x));
++}
++
++// Machine Interrupt Delegation
++static inline uint64
++r_mideleg()
++{
++  uint64 x;
++  asm volatile("csrr %0, mideleg" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mideleg(uint64 x)
++{
++  asm volatile("csrw mideleg, %0" : : "r" (x));
++}
++
++// Supervisor Trap-Vector Base Address
++// low two bits are mode.
++static inline void 
++w_stvec(uint64 x)
++{
++  asm volatile("csrw stvec, %0" : : "r" (x));
++}
++
++static inline uint64
++r_stvec()
++{
++  uint64 x;
++  asm volatile("csrr %0, stvec" : "=r" (x) );
++  return x;
++}
++
++// Machine-mode interrupt vector
++static inline void 
++w_mtvec(uint64 x)
++{
++  asm volatile("csrw mtvec, %0" : : "r" (x));
++}
++
++// Physical Memory Protection
++static inline void
++w_pmpcfg0(uint64 x)
++{
++  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
++}
++
++static inline void
++w_pmpaddr0(uint64 x)
++{
++  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
++}
++
++// use riscv's sv39 page table scheme.
++#define SATP_SV39 (8L << 60)
++
++#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
++
++// supervisor address translation and protection;
++// holds the address of the page table.
++static inline void 
++w_satp(uint64 x)
++{
++  asm volatile("csrw satp, %0" : : "r" (x));
++}
++
++static inline uint64
++r_satp()
++{
++  uint64 x;
++  asm volatile("csrr %0, satp" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mscratch(uint64 x)
++{
++  asm volatile("csrw mscratch, %0" : : "r" (x));
++}
++
++// Supervisor Trap Cause
++static inline uint64
++r_scause()
++{
++  uint64 x;
++  asm volatile("csrr %0, scause" : "=r" (x) );
++  return x;
++}
++
++// Supervisor Trap Value
++static inline uint64
++r_stval()
++{
++  uint64 x;
++  asm volatile("csrr %0, stval" : "=r" (x) );
++  return x;
++}
++
++// Machine-mode Counter-Enable
++static inline void 
++w_mcounteren(uint64 x)
++{
++  asm volatile("csrw mcounteren, %0" : : "r" (x));
++}
++
++static inline uint64
++r_mcounteren()
++{
++  uint64 x;
++  asm volatile("csrr %0, mcounteren" : "=r" (x) );
++  return x;
++}
++
++// machine-mode cycle counter
++static inline uint64
++r_time()
++{
++  uint64 x;
++  asm volatile("csrr %0, time" : "=r" (x) );
++  return x;
++}
++
++// enable device interrupts
++static inline void
++intr_on()
++{
++  w_sstatus(r_sstatus() | SSTATUS_SIE);
++}
++
++// disable device interrupts
++static inline void
++intr_off()
++{
++  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
++}
++
++// are device interrupts enabled?
++static inline int
++intr_get()
++{
++  uint64 x = r_sstatus();
++  return (x & SSTATUS_SIE) != 0;
++}
++
++static inline uint64
++r_sp()
++{
++  uint64 x;
++  asm volatile("mv %0, sp" : "=r" (x) );
++  return x;
++}
++
++// read and write tp, the thread pointer, which xv6 uses to hold
++// this core's hartid (core number), the index into cpus[].
++static inline uint64
++r_tp()
++{
++  uint64 x;
++  asm volatile("mv %0, tp" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_tp(uint64 x)
++{
++  asm volatile("mv tp, %0" : : "r" (x));
++}
++
++static inline uint64
++r_ra()
++{
++  uint64 x;
++  asm volatile("mv %0, ra" : "=r" (x) );
++  return x;
++}
++
++// flush the TLB.
++static inline void
++sfence_vma()
++{
++  // the zero, zero means flush all TLB entries.
++  asm volatile("sfence.vma zero, zero");
++}
++
++typedef uint64 pte_t;
++typedef uint64 *pagetable_t; // 512 PTEs
++
++#endif // __ASSEMBLER__
++
++#define PGSIZE 4096 // bytes per page
++#define PGSHIFT 12  // bits of offset within a page
++
++#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
++#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
++
++#define PTE_V (1L << 0) // valid
++#define PTE_R (1L << 1)
++#define PTE_W (1L << 2)
++#define PTE_X (1L << 3)
++#define PTE_U (1L << 4) // user can access
++
++#define PTE_COW (1L << 8)
++#define PTE_SWAP (1L << 9)
++
++// shift a physical address to the right place for a PTE.
++#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
++
++#define PTE2PA(pte) (((pte) >> 10) << 12)
++
++#define PTE_FLAGS(pte) ((pte) & 0x3FF)
++
++// extract the three 9-bit page table indices from a virtual address.
++#define PXMASK          0x1FF // 9 bits
++#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
++#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
++
++// one beyond the highest possible virtual address.
++// MAXVA is actually one bit less than the max allowed by
++// Sv39, to avoid having to sign-extend virtual addresses
++// that have the high bit set.
++#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
+diff --git a/kernel/swap.c b/kernel/swap.c
+new file mode 100644
+index 0000000..2122326
+--- /dev/null
++++ b/kernel/swap.c
+@@ -0,0 +1,155 @@
++#include "types.h"
++#include "riscv.h"
++#include "fs.h"
++#include "swap.h"
++#include "defs.h"
++#include "param.h"
++#include "proc.h"
++// #include "sleeplock.h"
++#include "buf.h"
++
++#define NBLOCKPERPAGE (PGSIZE / BSIZE)
++
++struct swapped_vpn {
++  uint64 vpn;
++};
++
++struct swap {
++  uint blocknos[NBLOCKPERPAGE];
++};
++
++struct swapped_pages {
++  struct swap swapped_block;
++  struct live page_info;
++  struct swapped_pages *next;
++};
++
++struct run {
++  struct run *next;
++};
++
++struct {
++  struct spinlock lock;
++  struct run *freelist;
++} swapmem;
++
++// Initialize swapmem
++void
++swapinit(void)
++{
++  initlock(&swapmem.lock, "swapmem");
++  swapmem.freelist = 0;
++}
++
++// Allocate one swap struct.
++// Returns a pointer to the swap struct.
++// Returns 0 if the memory cannot be allocated.
++struct swap *
++swapalloc(void)
++{
++  struct run *r;
++  struct swap *s;
++
++  acquire(&swapmem.lock);
++  r = swapmem.freelist;
++  if(!r){
++    release(&swapmem.lock);
++    char *mem = kalloc();
++    char *mem_end = mem + PGSIZE;
++    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
++      r = (struct run*)mem;
++
++      acquire(&swapmem.lock);
++      r->next = swapmem.freelist;
++      swapmem.freelist = r;
++      release(&swapmem.lock);
++    }
++    acquire(&swapmem.lock);
++    r = swapmem.freelist;
++  }
++  swapmem.freelist = r->next;
++  release(&swapmem.lock);
++  
++  s = (struct swap*)r;
++  if(s)
++    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
++  
++  return s;
++}
++
++// Free the swap struct pointed by s, and the blocks
++// contained in s, which normally should have been returned
++// by a call to swapalloc() and swapout().
++void
++swapfree(struct swap *s)
++{
++  // printf("inside swapfree\n");
++  uint *blockno;
++  struct run *r;
++
++  if(!s)
++    panic("swapfree");
++  
++  begin_op();
++  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
++    if(*blockno)
++      bfree(ROOTDEV, *blockno);
++  }
++  end_op();
++
++  r = (struct run*)s;
++
++  acquire(&swapmem.lock);
++  r->next = swapmem.freelist;
++  swapmem.freelist = r;
++  release(&swapmem.lock);
++  // printf("exiting swapfree\n");
++}
++
++// Swap out a given physical page src_pa to disk.
++// The metadata for retriving src_pa will be saved
++// to dst_pa which normally should have been returned
++// by a call to swapalloc().
++void
++swapout(struct swap *dst_sp, char *src_pa)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  begin_op();
++  // printf("crossed begin op\n");
++  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
++    // printf("before balloc %d\n", myproc()->pid);
++    *blockno = balloc(ROOTDEV);
++    if(*blockno == 0)
++      panic("swapout");
++    // printf("before bread\n");
++    bp = bread(ROOTDEV, *blockno);
++    // printf("before memmove\n");
++    memmove(bp->data, src_pa, BSIZE);
++    // printf("before log\n");
++    log_write(bp);
++    // printf("after log\n");
++    brelse(bp);
++    
++  }
++  end_op();
++}
++
++// Swap in a page into dst_pa from disk using src_sp.
++// src_sp should normally be updated with metadata
++// for retriving the page by a call to swapout().
++void
++swapin(char *dst_pa, struct swap *src_sp)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  if(!dst_pa)
++    panic("swapin");
++  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
++    bp = bread(ROOTDEV, *blockno);
++    memmove(dst_pa, bp->data, BSIZE);
++    brelse(bp);
++  }
++}
+diff --git a/kernel/swap.h b/kernel/swap.h
+new file mode 100644
+index 0000000..8a18da2
+--- /dev/null
++++ b/kernel/swap.h
+@@ -0,0 +1,27 @@
++#ifndef _swap_h_
++#define _swap_h_
++
++#include "types.h"
++#include "spinlock.h"
++#include "sleeplock.h"
++#include "defs.h"
++
++#define MAXPHYPAGES 50
++
++struct live{
++  uint64 vpn;
++  uint64 pa;
++  pagetable_t pagetable;
++};
++
++struct live_page_list {
++  int size;
++  struct spinlock lock;
++  struct live elem[MAXPHYPAGES];
++  // int next_index[MAXPHYPAGES];
++  // int valid[MAXPHYPAGES];
++  // int head;
++  // int tail;
++};
++
++#endif
+\ No newline at end of file
+diff --git a/kernel/trap.c b/kernel/trap.c
+index 512c850..9c4d4cf 100644
+--- a/kernel/trap.c
++++ b/kernel/trap.c
+@@ -1,221 +1,262 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "riscv.h"
+-#include "spinlock.h"
+-#include "proc.h"
+-#include "defs.h"
+-
+-struct spinlock tickslock;
+-uint ticks;
+-
+-extern char trampoline[], uservec[], userret[];
+-
+-// in kernelvec.S, calls kerneltrap().
+-void kernelvec();
+-
+-extern int devintr();
+-
+-void
+-trapinit(void)
+-{
+-  initlock(&tickslock, "time");
+-}
+-
+-// set up to take exceptions and traps while in the kernel.
+-void
+-trapinithart(void)
+-{
+-  w_stvec((uint64)kernelvec);
+-}
+-
+-//
+-// handle an interrupt, exception, or system call from user space.
+-// called from trampoline.S
+-//
+-void
+-usertrap(void)
+-{
+-  int which_dev = 0;
+-
+-  if((r_sstatus() & SSTATUS_SPP) != 0)
+-    panic("usertrap: not from user mode");
+-
+-  // send interrupts and exceptions to kerneltrap(),
+-  // since we're now in the kernel.
+-  w_stvec((uint64)kernelvec);
+-
+-  struct proc *p = myproc();
+-  
+-  // save user program counter.
+-  p->trapframe->epc = r_sepc();
+-  
+-  if(r_scause() == 8){
+-    // system call
+-
+-    if(killed(p))
+-      exit(-1);
+-
+-    // sepc points to the ecall instruction,
+-    // but we want to return to the next instruction.
+-    p->trapframe->epc += 4;
+-
+-    // an interrupt will change sepc, scause, and sstatus,
+-    // so enable only now that we're done with those registers.
+-    intr_on();
+-
+-    syscall();
+-  } else if((which_dev = devintr()) != 0){
+-    // ok
+-  } else {
+-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+-    setkilled(p);
+-  }
+-
+-  if(killed(p))
+-    exit(-1);
+-
+-  // give up the CPU if this is a timer interrupt.
+-  if(which_dev == 2)
+-    yield();
+-
+-  usertrapret();
+-}
+-
+-//
+-// return to user space
+-//
+-void
+-usertrapret(void)
+-{
+-  struct proc *p = myproc();
+-
+-  // we're about to switch the destination of traps from
+-  // kerneltrap() to usertrap(), so turn off interrupts until
+-  // we're back in user space, where usertrap() is correct.
+-  intr_off();
+-
+-  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
+-  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
+-  w_stvec(trampoline_uservec);
+-
+-  // set up trapframe values that uservec will need when
+-  // the process next traps into the kernel.
+-  p->trapframe->kernel_satp = r_satp();         // kernel page table
+-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
+-  p->trapframe->kernel_trap = (uint64)usertrap;
+-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+-
+-  // set up the registers that trampoline.S's sret will use
+-  // to get to user space.
+-  
+-  // set S Previous Privilege mode to User.
+-  unsigned long x = r_sstatus();
+-  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+-  x |= SSTATUS_SPIE; // enable interrupts in user mode
+-  w_sstatus(x);
+-
+-  // set S Exception Program Counter to the saved user pc.
+-  w_sepc(p->trapframe->epc);
+-
+-  // tell trampoline.S the user page table to switch to.
+-  uint64 satp = MAKE_SATP(p->pagetable);
+-
+-  // jump to userret in trampoline.S at the top of memory, which 
+-  // switches to the user page table, restores user registers,
+-  // and switches to user mode with sret.
+-  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
+-  ((void (*)(uint64))trampoline_userret)(satp);
+-}
+-
+-// interrupts and exceptions from kernel code go here via kernelvec,
+-// on whatever the current kernel stack is.
+-void 
+-kerneltrap()
+-{
+-  int which_dev = 0;
+-  uint64 sepc = r_sepc();
+-  uint64 sstatus = r_sstatus();
+-  uint64 scause = r_scause();
+-  
+-  if((sstatus & SSTATUS_SPP) == 0)
+-    panic("kerneltrap: not from supervisor mode");
+-  if(intr_get() != 0)
+-    panic("kerneltrap: interrupts enabled");
+-
+-  if((which_dev = devintr()) == 0){
+-    printf("scause %p\n", scause);
+-    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
+-    panic("kerneltrap");
+-  }
+-
+-  // give up the CPU if this is a timer interrupt.
+-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+-    yield();
+-
+-  // the yield() may have caused some traps to occur,
+-  // so restore trap registers for use by kernelvec.S's sepc instruction.
+-  w_sepc(sepc);
+-  w_sstatus(sstatus);
+-}
+-
+-void
+-clockintr()
+-{
+-  acquire(&tickslock);
+-  ticks++;
+-  wakeup(&ticks);
+-  release(&tickslock);
+-}
+-
+-// check if it's an external interrupt or software interrupt,
+-// and handle it.
+-// returns 2 if timer interrupt,
+-// 1 if other device,
+-// 0 if not recognized.
+-int
+-devintr()
+-{
+-  uint64 scause = r_scause();
+-
+-  if((scause & 0x8000000000000000L) &&
+-     (scause & 0xff) == 9){
+-    // this is a supervisor external interrupt, via PLIC.
+-
+-    // irq indicates which device interrupted.
+-    int irq = plic_claim();
+-
+-    if(irq == UART0_IRQ){
+-      uartintr();
+-    } else if(irq == VIRTIO0_IRQ){
+-      virtio_disk_intr();
+-    } else if(irq){
+-      printf("unexpected interrupt irq=%d\n", irq);
+-    }
+-
+-    // the PLIC allows each device to raise at most one
+-    // interrupt at a time; tell the PLIC the device is
+-    // now allowed to interrupt again.
+-    if(irq)
+-      plic_complete(irq);
+-
+-    return 1;
+-  } else if(scause == 0x8000000000000001L){
+-    // software interrupt from a machine-mode timer interrupt,
+-    // forwarded by timervec in kernelvec.S.
+-
+-    if(cpuid() == 0){
+-      clockintr();
+-    }
+-    
+-    // acknowledge the software interrupt by clearing
+-    // the SSIP bit in sip.
+-    w_sip(r_sip() & ~2);
+-
+-    return 2;
+-  } else {
+-    return 0;
+-  }
+-}
+-
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "swap.h"
++#include "proc.h"
++#include "defs.h"
++
++struct spinlock tickslock;
++uint ticks;
++
++extern struct live_page_list live_list;
++
++extern char trampoline[], uservec[], userret[];
++
++// in kernelvec.S, calls kerneltrap().
++void kernelvec();
++
++extern int devintr();
++
++void
++trapinit(void)
++{
++  initlock(&tickslock, "time");
++}
++
++// set up to take exceptions and traps while in the kernel.
++void
++trapinithart(void)
++{
++  w_stvec((uint64)kernelvec);
++}
++
++//
++// handle an interrupt, exception, or system call from user space.
++// called from trampoline.S
++//
++void
++usertrap(void)
++{
++  int which_dev = 0;
++
++  if((r_sstatus() & SSTATUS_SPP) != 0)
++    panic("usertrap: not from user mode");
++
++  // send interrupts and exceptions to kerneltrap(),
++  // since we're now in the kernel.
++  w_stvec((uint64)kernelvec);
++
++  struct proc *p = myproc();
++  
++  // save user program counter.
++  p->trapframe->epc = r_sepc();
++  
++  if(r_scause() == 8){
++    // system call
++
++    if(killed(p))
++      exit(-1);
++
++    // sepc points to the ecall instruction,
++    // but we want to return to the next instruction.
++    p->trapframe->epc += 4;
++
++    // an interrupt will change sepc, scause, and sstatus,
++    // so enable only now that we're done with those registers.
++    intr_on();
++
++    syscall();
++  } else if (r_scause() == 15 || r_scause() == 13) {
++      // printf("yessir got it for %d\n", r_stval());
++      struct proc *p = myproc();
++      uint flags;
++      uint64 va = PGROUNDDOWN(r_stval());
++      uint64 toSwap;
++      pte_t *pte;
++      char *mem;
++
++      if((pte = walk(p->pagetable, va, 0)) == 0) {
++        printf("No such page\n");
++        return ;
++      }
++      flags = PTE_FLAGS(*pte);
++      if(flags & PTE_SWAP) {
++        flags &= (~PTE_SWAP);
++        flags |= (PTE_V);
++        toSwap = (*pte >> 10);
++        if (swap_out_wrapper() == 0) {
++          panic("in trap, swap out error\n");
++        }
++        if((mem = kalloc()) == 0) {
++          panic("in trap, memory allocation error\n");
++        }
++        // swap address unmapping
++        uvmunmap(p->pagetable, va, 1, 0);
++
++        // printf("uvmcopy: before releasing %d\n", p->pid);
++        // release(&p->lock);
++        // printf("uvmcopy: after releasing %d\n", p->pid);
++        swapin(mem, (struct swap *)toSwap);
++        // acquire(&p->lock);
++
++        if((mappages(p->pagetable, va, PGSIZE, (uint64)mem, flags)) != 0) {
++          panic("in trap, mapping failed\n");
++        }
++        swapfree((struct swap *)toSwap);
++        // printf("Exiting Trap\n");
++      }
++  } else if((which_dev = devintr()) != 0){
++     // ok
++  } else {
++    // printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
++    // printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
++    setkilled(p);
++  }
++
++  if(killed(p))
++    exit(-1);
++
++  // give up the CPU if this is a timer interrupt.
++  if(which_dev == 2)
++    yield();
++
++  usertrapret();
++}
++
++//
++// return to user space
++//
++void
++usertrapret(void)
++{
++  struct proc *p = myproc();
++
++  // we're about to switch the destination of traps from
++  // kerneltrap() to usertrap(), so turn off interrupts until
++  // we're back in user space, where usertrap() is correct.
++  intr_off();
++
++  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
++  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
++  w_stvec(trampoline_uservec);
++
++  // set up trapframe values that uservec will need when
++  // the process next traps into the kernel.
++  p->trapframe->kernel_satp = r_satp();         // kernel page table
++  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
++  p->trapframe->kernel_trap = (uint64)usertrap;
++  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
++
++  // set up the registers that trampoline.S's sret will use
++  // to get to user space.
++  
++  // set S Previous Privilege mode to User.
++  unsigned long x = r_sstatus();
++  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
++  x |= SSTATUS_SPIE; // enable interrupts in user mode
++  w_sstatus(x);
++
++  // set S Exception Program Counter to the saved user pc.
++  w_sepc(p->trapframe->epc);
++
++  // tell trampoline.S the user page table to switch to.
++  uint64 satp = MAKE_SATP(p->pagetable);
++
++  // jump to userret in trampoline.S at the top of memory, which 
++  // switches to the user page table, restores user registers,
++  // and switches to user mode with sret.
++  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
++  ((void (*)(uint64))trampoline_userret)(satp);
++}
++
++// interrupts and exceptions from kernel code go here via kernelvec,
++// on whatever the current kernel stack is.
++void 
++kerneltrap()
++{
++  int which_dev = 0;
++  uint64 sepc = r_sepc();
++  uint64 sstatus = r_sstatus();
++  uint64 scause = r_scause();
++  
++  if((sstatus & SSTATUS_SPP) == 0)
++    panic("kerneltrap: not from supervisor mode");
++  if(intr_get() != 0)
++    panic("kerneltrap: interrupts enabled");
++
++  if((which_dev = devintr()) == 0){
++    printf("scause %p\n", scause);
++    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
++    panic("kerneltrap");
++  }
++
++  // give up the CPU if this is a timer interrupt.
++  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
++    yield();
++
++  // the yield() may have caused some traps to occur,
++  // so restore trap registers for use by kernelvec.S's sepc instruction.
++  w_sepc(sepc);
++  w_sstatus(sstatus);
++}
++
++void
++clockintr()
++{
++  acquire(&tickslock);
++  ticks++;
++  wakeup(&ticks);
++  release(&tickslock);
++}
++
++// check if it's an external interrupt or software interrupt,
++// and handle it.
++// returns 2 if timer interrupt,
++// 1 if other device,
++// 0 if not recognized.
++int
++devintr()
++{
++  uint64 scause = r_scause();
++
++  if((scause & 0x8000000000000000L) &&
++     (scause & 0xff) == 9){
++    // this is a supervisor external interrupt, via PLIC.
++
++    // irq indicates which device interrupted.
++    int irq = plic_claim();
++
++    if(irq == UART0_IRQ){
++      uartintr();
++    } else if(irq == VIRTIO0_IRQ){
++      virtio_disk_intr();
++    } else if(irq){
++      printf("unexpected interrupt irq=%d\n", irq);
++    }
++
++    // the PLIC allows each device to raise at most one
++    // interrupt at a time; tell the PLIC the device is
++    // now allowed to interrupt again.
++    if(irq)
++      plic_complete(irq);
++
++    return 1;
++  } else if(scause == 0x8000000000000001L){
++    // software interrupt from a machine-mode timer interrupt,
++    // forwarded by timervec in kernelvec.S.
++
++    if(cpuid() == 0){
++      clockintr();
++    }
++    
++    // acknowledge the software interrupt by clearing
++    // the SSIP bit in sip.
++    w_sip(r_sip() & ~2);
++
++    return 2;
++  } else {
++    return 0;
++  }
++}
++
+diff --git a/kernel/vm.c b/kernel/vm.c
+index 9f69783..f75e7b5 100644
+--- a/kernel/vm.c
++++ b/kernel/vm.c
+@@ -1,439 +1,676 @@
+-#include "param.h"
+-#include "types.h"
+-#include "memlayout.h"
+-#include "elf.h"
+-#include "riscv.h"
+-#include "defs.h"
+-#include "fs.h"
+-
+-/*
+- * the kernel's page table.
+- */
+-pagetable_t kernel_pagetable;
+-
+-extern char etext[];  // kernel.ld sets this to end of kernel code.
+-
+-extern char trampoline[]; // trampoline.S
+-
+-// Make a direct-map page table for the kernel.
+-pagetable_t
+-kvmmake(void)
+-{
+-  pagetable_t kpgtbl;
+-
+-  kpgtbl = (pagetable_t) kalloc();
+-  memset(kpgtbl, 0, PGSIZE);
+-
+-  // uart registers
+-  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+-
+-  // virtio mmio disk interface
+-  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+-
+-  // PLIC
+-  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+-
+-  // map kernel text executable and read-only.
+-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+-
+-  // map kernel data and the physical RAM we'll make use of.
+-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+-
+-  // map the trampoline for trap entry/exit to
+-  // the highest virtual address in the kernel.
+-  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+-
+-  // allocate and map a kernel stack for each process.
+-  proc_mapstacks(kpgtbl);
+-  
+-  return kpgtbl;
+-}
+-
+-// Initialize the one kernel_pagetable
+-void
+-kvminit(void)
+-{
+-  kernel_pagetable = kvmmake();
+-}
+-
+-// Switch h/w page table register to the kernel's page table,
+-// and enable paging.
+-void
+-kvminithart()
+-{
+-  // wait for any previous writes to the page table memory to finish.
+-  sfence_vma();
+-
+-  w_satp(MAKE_SATP(kernel_pagetable));
+-
+-  // flush stale entries from the TLB.
+-  sfence_vma();
+-}
+-
+-// Return the address of the PTE in page table pagetable
+-// that corresponds to virtual address va.  If alloc!=0,
+-// create any required page-table pages.
+-//
+-// The risc-v Sv39 scheme has three levels of page-table
+-// pages. A page-table page contains 512 64-bit PTEs.
+-// A 64-bit virtual address is split into five fields:
+-//   39..63 -- must be zero.
+-//   30..38 -- 9 bits of level-2 index.
+-//   21..29 -- 9 bits of level-1 index.
+-//   12..20 -- 9 bits of level-0 index.
+-//    0..11 -- 12 bits of byte offset within the page.
+-pte_t *
+-walk(pagetable_t pagetable, uint64 va, int alloc)
+-{
+-  if(va >= MAXVA)
+-    panic("walk");
+-
+-  for(int level = 2; level > 0; level--) {
+-    pte_t *pte = &pagetable[PX(level, va)];
+-    if(*pte & PTE_V) {
+-      pagetable = (pagetable_t)PTE2PA(*pte);
+-    } else {
+-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+-        return 0;
+-      memset(pagetable, 0, PGSIZE);
+-      *pte = PA2PTE(pagetable) | PTE_V;
+-    }
+-  }
+-  return &pagetable[PX(0, va)];
+-}
+-
+-// Look up a virtual address, return the physical address,
+-// or 0 if not mapped.
+-// Can only be used to look up user pages.
+-uint64
+-walkaddr(pagetable_t pagetable, uint64 va)
+-{
+-  pte_t *pte;
+-  uint64 pa;
+-
+-  if(va >= MAXVA)
+-    return 0;
+-
+-  pte = walk(pagetable, va, 0);
+-  if(pte == 0)
+-    return 0;
+-  if((*pte & PTE_V) == 0)
+-    return 0;
+-  if((*pte & PTE_U) == 0)
+-    return 0;
+-  pa = PTE2PA(*pte);
+-  return pa;
+-}
+-
+-// add a mapping to the kernel page table.
+-// only used when booting.
+-// does not flush TLB or enable paging.
+-void
+-kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
+-{
+-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+-    panic("kvmmap");
+-}
+-
+-// Create PTEs for virtual addresses starting at va that refer to
+-// physical addresses starting at pa. va and size might not
+-// be page-aligned. Returns 0 on success, -1 if walk() couldn't
+-// allocate a needed page-table page.
+-int
+-mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+-{
+-  uint64 a, last;
+-  pte_t *pte;
+-
+-  if(size == 0)
+-    panic("mappages: size");
+-  
+-  a = PGROUNDDOWN(va);
+-  last = PGROUNDDOWN(va + size - 1);
+-  for(;;){
+-    if((pte = walk(pagetable, a, 1)) == 0)
+-      return -1;
+-    if(*pte & PTE_V)
+-      panic("mappages: remap");
+-    *pte = PA2PTE(pa) | perm | PTE_V;
+-    if(a == last)
+-      break;
+-    a += PGSIZE;
+-    pa += PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Remove npages of mappings starting from va. va must be
+-// page-aligned. The mappings must exist.
+-// Optionally free the physical memory.
+-void
+-uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+-{
+-  uint64 a;
+-  pte_t *pte;
+-
+-  if((va % PGSIZE) != 0)
+-    panic("uvmunmap: not aligned");
+-
+-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+-    if((pte = walk(pagetable, a, 0)) == 0)
+-      panic("uvmunmap: walk");
+-    if((*pte & PTE_V) == 0)
+-      panic("uvmunmap: not mapped");
+-    if(PTE_FLAGS(*pte) == PTE_V)
+-      panic("uvmunmap: not a leaf");
+-    if(do_free){
+-      uint64 pa = PTE2PA(*pte);
+-      kfree((void*)pa);
+-    }
+-    *pte = 0;
+-  }
+-}
+-
+-// create an empty user page table.
+-// returns 0 if out of memory.
+-pagetable_t
+-uvmcreate()
+-{
+-  pagetable_t pagetable;
+-  pagetable = (pagetable_t) kalloc();
+-  if(pagetable == 0)
+-    return 0;
+-  memset(pagetable, 0, PGSIZE);
+-  return pagetable;
+-}
+-
+-// Load the user initcode into address 0 of pagetable,
+-// for the very first process.
+-// sz must be less than a page.
+-void
+-uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+-{
+-  char *mem;
+-
+-  if(sz >= PGSIZE)
+-    panic("uvmfirst: more than a page");
+-  mem = kalloc();
+-  memset(mem, 0, PGSIZE);
+-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+-  memmove(mem, src, sz);
+-}
+-
+-// Allocate PTEs and physical memory to grow process from oldsz to
+-// newsz, which need not be page aligned.  Returns new size or 0 on error.
+-uint64
+-uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
+-{
+-  char *mem;
+-  uint64 a;
+-
+-  if(newsz < oldsz)
+-    return oldsz;
+-
+-  oldsz = PGROUNDUP(oldsz);
+-  for(a = oldsz; a < newsz; a += PGSIZE){
+-    mem = kalloc();
+-    if(mem == 0){
+-      uvmdealloc(pagetable, a, oldsz);
+-      return 0;
+-    }
+-    memset(mem, 0, PGSIZE);
+-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+-      kfree(mem);
+-      uvmdealloc(pagetable, a, oldsz);
+-      return 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Deallocate user pages to bring the process size from oldsz to
+-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+-// need to be less than oldsz.  oldsz can be larger than the actual
+-// process size.  Returns the new process size.
+-uint64
+-uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+-{
+-  if(newsz >= oldsz)
+-    return oldsz;
+-
+-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+-    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+-    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+-  }
+-
+-  return newsz;
+-}
+-
+-// Recursively free page-table pages.
+-// All leaf mappings must already have been removed.
+-void
+-freewalk(pagetable_t pagetable)
+-{
+-  // there are 2^9 = 512 PTEs in a page table.
+-  for(int i = 0; i < 512; i++){
+-    pte_t pte = pagetable[i];
+-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+-      // this PTE points to a lower-level page table.
+-      uint64 child = PTE2PA(pte);
+-      freewalk((pagetable_t)child);
+-      pagetable[i] = 0;
+-    } else if(pte & PTE_V){
+-      panic("freewalk: leaf");
+-    }
+-  }
+-  kfree((void*)pagetable);
+-}
+-
+-// Free user memory pages,
+-// then free page-table pages.
+-void
+-uvmfree(pagetable_t pagetable, uint64 sz)
+-{
+-  if(sz > 0)
+-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+-  freewalk(pagetable);
+-}
+-
+-// Given a parent process's page table, copy
+-// its memory into a child's page table.
+-// Copies both the page table and the
+-// physical memory.
+-// returns 0 on success, -1 on failure.
+-// frees any allocated pages on failure.
+-int
+-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+-{
+-  pte_t *pte;
+-  uint64 pa, i;
+-  uint flags;
+-  char *mem;
+-
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walk(old, i, 0)) == 0)
+-      panic("uvmcopy: pte should exist");
+-    if((*pte & PTE_V) == 0)
+-      panic("uvmcopy: page not present");
+-    pa = PTE2PA(*pte);
+-    flags = PTE_FLAGS(*pte);
+-    if((mem = kalloc()) == 0)
+-      goto err;
+-    memmove(mem, (char*)pa, PGSIZE);
+-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+-      kfree(mem);
+-      goto err;
+-    }
+-  }
+-  return 0;
+-
+- err:
+-  uvmunmap(new, 0, i / PGSIZE, 1);
+-  return -1;
+-}
+-
+-// mark a PTE invalid for user access.
+-// used by exec for the user stack guard page.
+-void
+-uvmclear(pagetable_t pagetable, uint64 va)
+-{
+-  pte_t *pte;
+-  
+-  pte = walk(pagetable, va, 0);
+-  if(pte == 0)
+-    panic("uvmclear");
+-  *pte &= ~PTE_U;
+-}
+-
+-// Copy from kernel to user.
+-// Copy len bytes from src to virtual address dstva in a given page table.
+-// Return 0 on success, -1 on error.
+-int
+-copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+-{
+-  uint64 n, va0, pa0;
+-
+-  while(len > 0){
+-    va0 = PGROUNDDOWN(dstva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (dstva - va0);
+-    if(n > len)
+-      n = len;
+-    memmove((void *)(pa0 + (dstva - va0)), src, n);
+-
+-    len -= n;
+-    src += n;
+-    dstva = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Copy from user to kernel.
+-// Copy len bytes to dst from virtual address srcva in a given page table.
+-// Return 0 on success, -1 on error.
+-int
+-copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
+-{
+-  uint64 n, va0, pa0;
+-
+-  while(len > 0){
+-    va0 = PGROUNDDOWN(srcva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (srcva - va0);
+-    if(n > len)
+-      n = len;
+-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+-
+-    len -= n;
+-    dst += n;
+-    srcva = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Copy a null-terminated string from user to kernel.
+-// Copy bytes to dst from virtual address srcva in a given page table,
+-// until a '\0', or max.
+-// Return 0 on success, -1 on error.
+-int
+-copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+-{
+-  uint64 n, va0, pa0;
+-  int got_null = 0;
+-
+-  while(got_null == 0 && max > 0){
+-    va0 = PGROUNDDOWN(srcva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (srcva - va0);
+-    if(n > max)
+-      n = max;
+-
+-    char *p = (char *) (pa0 + (srcva - va0));
+-    while(n > 0){
+-      if(*p == '\0'){
+-        *dst = '\0';
+-        got_null = 1;
+-        break;
+-      } else {
+-        *dst = *p;
+-      }
+-      --n;
+-      --max;
+-      p++;
+-      dst++;
+-    }
+-
+-    srcva = va0 + PGSIZE;
+-  }
+-  if(got_null){
+-    return 0;
+-  } else {
+-    return -1;
+-  }
+-}
++#include "param.h"
++#include "types.h"
++#include "memlayout.h"
++#include "elf.h"
++#include "riscv.h"
++#include "defs.h"
++#include "fs.h"
++
++#include "swap.h"
++#include "proc.h"
++
++extern int global_swap_flag;
++
++struct live_page_list live_list;
++struct swapped_pages *swapped_list;
++
++void print_live_count() {
++  printf("Live Pages: %d\n", live_list.size);
++}
++
++
++/*
++ * the kernel's page table.
++ */
++pagetable_t kernel_pagetable;
++
++
++extern char etext[];  // kernel.ld sets this to end of kernel code.
++
++extern char trampoline[]; // trampoline.S
++
++// Make a direct-map page table for the kernel.
++pagetable_t
++kvmmake(void)
++{
++  pagetable_t kpgtbl;
++
++  kpgtbl = (pagetable_t) kalloc();
++  memset(kpgtbl, 0, PGSIZE);
++
++  // printf("In kvmmake\n");
++  // uart registers
++  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
++
++  // printf("In kvmmake 2\n");
++
++  // virtio mmio disk interface
++  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
++
++  // printf("In kvmmake 3\n");
++
++  // PLIC
++  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
++
++  // map kernel text executable and read-only.
++  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
++
++  // map kernel data and the physical RAM we'll make use of.
++  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
++
++  // map the trampoline for trap entry/exit to
++  // the highest virtual address in the kernel.
++  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
++
++  // allocate and map a kernel stack for each process.
++  proc_mapstacks(kpgtbl);
++  
++  return kpgtbl;
++}
++
++// void init_live_pages() {
++//   //printf("yess\n");
++//   // acquiresleep(&live_list.lock);
++//   // printf("yessir\n");
++//   for (int i = 0; i < MAXPHYPAGES; i++) {
++//     live_list.valid[i] = 0;
++//     // live_list.next_index[i] = -1;
++//     live_list.elem[i].pagetable = 0;
++//     live_list.elem[i].vpn = 0;
++//     live_list.elem[i].pa = 0;
++//   }
++//   live_list.head = 0;
++//   live_list.tail = 0;
++//   live_list.size = 0;
++//   // releasesleep(&live_list.lock);
++// }
++
++void init_live_pages() {
++  live_list.size = 0;
++}
++
++// Initialize the one kernel_pagetable
++void
++kvminit(void)
++{
++  global_swap_flag = 0;
++  kernel_pagetable = kvmmake();
++  // initsleeplock(&live_list.lock, "live_list");
++  init_live_pages();
++}
++
++// Switch h/w page table register to the kernel's page table,
++// and enable paging.
++void
++kvminithart()
++{
++  // wait for any previous writes to the page table memory to finish.
++  sfence_vma();
++
++  w_satp(MAKE_SATP(kernel_pagetable));
++
++  // flush stale entries from the TLB.
++  sfence_vma();
++}
++
++// Return the address of the PTE in page table pagetable
++// that corresponds to virtual address va.  If alloc!=0,
++// create any required page-table pages.
++//
++// The risc-v Sv39 scheme has three levels of page-table
++// pages. A page-table page contains 512 64-bit PTEs.
++// A 64-bit virtual address is split into five fields:
++//   39..63 -- must be zero.
++//   30..38 -- 9 bits of level-2 index.
++//   21..29 -- 9 bits of level-1 index.
++//   12..20 -- 9 bits of level-0 index.
++//    0..11 -- 12 bits of byte offset within the page.
++pte_t *
++walk(pagetable_t pagetable, uint64 va, int alloc)
++{
++  if(va >= MAXVA)
++    panic("walk");
++
++  for(int level = 2; level > 0; level--) {
++    // sfence_vma();
++    pte_t *pte = &pagetable[PX(level, va)];
++    // printf("pte: %d\n", PTE_FLAGS(*pte));
++    if ((*pte & PTE_SWAP)) {
++      // printf("Yessir found page %d\n", (int)*pte & 0x3ff);
++      return pte;
++    }
++    // printf("passed swap check in walk\n");
++    if(*pte & PTE_V) {
++      // printf("matched valid bit\n");
++      pagetable = (pagetable_t)PTE2PA(*pte);
++    } else {
++      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
++        return 0;
++      memset(pagetable, 0, PGSIZE);
++      *pte = PA2PTE(pagetable) | PTE_V;
++    }
++  }
++  return &pagetable[PX(0, va)];
++}
++
++// Look up a virtual address, return the physical address,
++// or 0 if not mapped.
++// Can only be used to look up user pages.
++uint64
++walkaddr(pagetable_t pagetable, uint64 va)
++{
++  pte_t *pte;
++  uint64 pa;
++
++  if(va >= MAXVA)
++    return 0;
++
++  pte = walk(pagetable, va, 0);
++  if(pte == 0)
++    return 0;
++  if((*pte & PTE_V) == 0)
++    return 0;
++  if((*pte & PTE_U) == 0)
++    return 0;
++  pa = PTE2PA(*pte);
++  return pa;
++}
++
++void
++print_live_list() {
++  printf("va\tpagetable\n");
++  for(int i=0; i < live_list.size; i++) {
++    printf("%d\t%p\n", live_list.elem[i].vpn, live_list.elem[i].pagetable);
++  }
++}
++
++// add a mapping to the kernel page table.
++// only used when booting.
++// does not flush TLB or enable paging.
++void
++kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
++{
++  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
++    panic("kvmmap");
++}
++
++// Create PTEs for virtual addresses starting at va that refer to
++// physical addresses starting at pa. va and size might not
++// be page-aligned. Returns 0 on success, -1 if walk() couldn't
++// allocate a needed page-table page.
++int
++mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
++{
++  uint64 a, last;
++  pte_t *pte;
++
++  if(size == 0)
++    panic("mappages: size");
++  
++  a = PGROUNDDOWN(va);
++  last = PGROUNDDOWN(va + size - 1);
++  for(;;){
++    if((pte = walk(pagetable, a, 1)) == 0) {
++      // printf("lengra\n");
++      return -1;
++    }
++    if(*pte & PTE_V)
++      panic("mappages: remap");
++    *pte = PA2PTE(pa) | perm | PTE_V;
++    if(a == last)
++      break;
++    a += PGSIZE;
++    pa += PGSIZE;
++  }
++  return 0;
++}
++
++// Remove npages of mappings starting from va. va must be
++// page-aligned. The mappings must exist.
++// Optionally free the physical memory.
++void
++uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
++{
++  // printf("entering uvmunmap\n");
++  uint64 a;
++  pte_t *pte;
++
++  if((va % PGSIZE) != 0)
++    panic("uvmunmap: not aligned");
++
++  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
++    if((pte = walk(pagetable, a, 0)) == 0)
++      panic("uvmunmap: walk");
++    // if(((*pte & PTE_V) == 0))
++    //   panic("uvmunmap: not mapped");
++    if (((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0)
++        panic("uvmunmap: not mapped");
++    if (PTE_FLAGS(*pte) == PTE_V)
++      panic("uvmunmap: not a leaf");
++    if(do_free){
++      if (*pte & PTE_SWAP) {
++        // printf("inside uvmunmap->swap\n");
++        // pte contains swap address
++        struct swap *swapAddress = (struct swap *)((*pte) >> 10);
++        swapfree(swapAddress);
++        // printf("swap free done\n");
++      } else {
++        uint64 pa = PTE2PA(*pte);
++
++        // acquire(&live_list.lock);
++        // printf("trying to look_up %d\n", (unsigned int) pa);
++        int idx = list_lookup(pa);
++
++        if (idx >= 0) {
++          // printf("removing live page\n");
++          remove_live_page(idx);
++        }
++        // release(&live_list.lock);
++        kfree((void*)pa);
++      }
++    }
++    *pte = 0;
++  }
++  // printf("Exiting uvmunmap\n");
++  // printf("after deallocation: ");
++  // print_live_count();
++}
++
++// create an empty user page table.
++// returns 0 if out of memory.
++pagetable_t
++uvmcreate()
++{
++  pagetable_t pagetable;
++  pagetable = (pagetable_t) kalloc();
++  if(pagetable == 0)
++    return 0;
++  memset(pagetable, 0, PGSIZE);
++  return pagetable;
++}
++
++// Load the user initcode into address 0 of pagetable,
++// for the very first process.
++// sz must be less than a page.
++void
++uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
++{
++  char *mem;
++
++  if(sz >= PGSIZE)
++    panic("uvmfirst: more than a page");
++  mem = kalloc();
++  memset(mem, 0, PGSIZE);
++  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
++  memmove(mem, src, sz);
++}
++
++void
++add_live_page(pagetable_t pagetable, uint64 va, uint64 pa) {
++  if(live_list.size >= 50) {
++    panic ("Live page full\n");
++  }
++  live_list.elem[live_list.size].pagetable = pagetable;
++  live_list.elem[live_list.size].vpn = va;
++  live_list.elem[live_list.size].pa = pa;
++  live_list.size++;
++}
++
++int
++list_lookup(uint64 pa) {
++  // acquiresleep(&live_list.lock);
++  for (int i = 0; i < live_list.size; i++) {
++      if (pa == live_list.elem[i].pa) {
++        return i;
++      }
++  }
++
++  return -1;
++}
++
++struct live
++remove_live_page(int idx) {
++  if(live_list.size <= idx) {
++    panic ("Empty live_list\n");
++  }
++  struct live temp = live_list.elem[idx];
++  for(int i = idx; i < live_list.size-1; i++) {
++    live_list.elem[i] = live_list.elem[i+1];
++  }
++  live_list.size--;
++  return temp;
++}
++
++
++
++// returns 0 if not successful
++uint
++swap_out_wrapper() {
++  // printf("Entering swap_out_wrapper\n");
++  pte_t *pte;
++  uint64 pa;
++  uint flags;
++
++  // acquire(&live_list.lock);
++  if (live_list.size >= 50) {
++    // print_live_list();
++    struct live live_to_remove = remove_live_page(0);
++    pagetable_t pagetable = live_to_remove.pagetable;
++    uint64 va = live_to_remove.vpn;
++    pa = live_to_remove.pa;
++    
++    // printf("actually swapping out\n");
++    // allocate a swap
++    struct swap* toSwap;
++    if((toSwap = swapalloc()) == 0) {
++      printf("Memory Full\n");
++      // release(&live_list.lock);
++      return 0;
++    } 
++
++    swapout(toSwap, (char *)pa);
++
++    // get a live page to swap
++    
++
++    /*
++      walk inconsistency bug modification
++    */
++
++    if((pte = walk(pagetable, va, 0)) == 0) {
++      printf("Unable to walk\n");
++      // release(&live_list.lock);
++      return 0;
++    }
++    flags = PTE_FLAGS(*pte);
++    flags |= PTE_SWAP; 
++    flags &= (~PTE_V);
++    
++    kfree((void *)PGROUNDDOWN(pa));    
++    *pte = ((uint64)toSwap << 10) | flags;
++  }
++
++  return 1;
++}
++
++// Allocate PTEs and physical memory to grow process from oldsz to
++// newsz, which need not be page aligned.  Returns new size or 0 on error.
++uint64
++uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
++{
++  char *mem;
++  uint64 a;
++  // printf("Entering uvmalloc\n");
++  if(newsz < oldsz)
++    return oldsz;
++
++  oldsz = PGROUNDUP(oldsz);
++  for(a = oldsz; a < newsz; a += PGSIZE) {
++    mem = kalloc();
++    if(mem == 0){
++      goto err;
++    }
++    memset(mem, 0, PGSIZE);
++    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
++      kfree(mem);
++      uvmdealloc(pagetable, a, oldsz);
++      return 0;
++    }
++    // only swap the non executables. 
++    if(global_swap_flag) {
++      if (swap_out_wrapper() == 0)
++        goto err;
++    
++      add_live_page(pagetable, a, (uint64)mem);
++    }
++    // print_live_count();
++  }
++  global_swap_flag = 0;
++  return newsz;
++
++  err:
++    uvmdealloc(pagetable, a, oldsz);
++    global_swap_flag = 0;
++    return 0;
++}
++
++// Deallocate user pages to bring the process size from oldsz to
++// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
++// need to be less than oldsz.  oldsz can be larger than the actual
++// process size.  Returns the new process size.
++uint64
++uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
++{
++  if(newsz >= oldsz)
++    return oldsz;
++
++  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
++    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
++    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
++  }
++
++  return newsz;
++}
++
++// Recursively free page-table pages.
++// All leaf mappings must already have been removed.
++void
++freewalk(pagetable_t pagetable)
++{
++  // there are 2^9 = 512 PTEs in a page table.
++  for(int i = 0; i < 512; i++){
++    pte_t pte = pagetable[i];
++    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
++      // this PTE points to a lower-level page table.
++      uint64 child = PTE2PA(pte);
++      freewalk((pagetable_t)child);
++      pagetable[i] = 0;
++    } else if(pte & PTE_V){
++      panic("freewalk: leaf");
++    }
++  }
++  kfree((void*)pagetable);
++}
++
++// Free user memory pages,
++// then free page-table pages.
++void
++uvmfree(pagetable_t pagetable, uint64 sz)
++{
++  if(sz > 0)
++    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
++  freewalk(pagetable);
++}
++
++// Given a parent process's page table, copy
++// its memory into a child's page table.
++// Copies both the page table and the
++// physical memory.
++// returns 0 on success, -1 on failure.
++// frees any allocated pages on failure.
++int
++uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
++{
++  pte_t *pte;
++  uint64 pa, i;
++  uint flags;
++  char *mem;
++  // printf("Entering UVMcopy\n");
++  for(i = 0; i < sz; i += PGSIZE){
++    if((pte = walk(old, i, 0)) == 0)
++      panic("uvmcopy: pte should exist");
++    // not valid and not swapped
++    if(((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0)
++      panic("uvmcopy: page not present");
++    //either valid or swapped
++    pa = PTE2PA(*pte);
++    flags = PTE_FLAGS(*pte);
++    if(flags & PTE_SWAP) {
++      // swapped memory for parent
++      // printf("in parent process: swap page found\n");
++      if(swap_out_wrapper() == 0) {
++        // printf("Error in uvmcopy->swap_out_wrapper\n");
++        goto err;
++      }
++
++      // printf("swapout finished\n");
++      char *mem2;
++      struct swap* toSwap = (struct swap*)(*pte >> 10);
++      flags &= (~PTE_SWAP);
++      flags |= (PTE_V);
++
++      if ((mem2 = kalloc()) == 0) {
++        goto err;
++      }
++
++      swapin((char *)mem2, toSwap);
++      // printf("swapin done\n");
++      // acquire(&p->lock);
++      add_live_page(old, i, (uint64)mem2);
++
++      if(mappages(old, i, PGSIZE, (uint64)mem2, flags) != 0){
++        kfree(mem2);
++        goto err;
++      }
++      pa = (uint64)mem2;
++      swapfree(toSwap);
++    }
++    // all parent pages are either live or not swappable
++    // for child, memory alloc
++    if((mem = kalloc()) == 0){
++      goto err;
++    }
++    memmove(mem, (char*)pa, PGSIZE);
++    
++    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
++      kfree(mem);
++      goto err;
++    }
++
++    int parent_livepage_idx = list_lookup(pa);
++    
++    if (parent_livepage_idx == -1) {
++      // not live page. so directly map
++    } else {
++      // parent is a live page. So,
++      // child should be kept in live
++      if (swap_out_wrapper() == 0){
++        goto err;
++      }
++
++      add_live_page(new, i, (uint64)mem);
++    }
++  }
++
++  return 0;
++
++ err:
++  uvmunmap(new, 0, i / PGSIZE, 1);
++  return -1;
++}
++
++// mark a PTE invalid for user access.
++// used by exec for the user stack guard page.
++void
++uvmclear(pagetable_t pagetable, uint64 va)
++{
++  pte_t *pte;
++  
++  pte = walk(pagetable, va, 0);
++  if(pte == 0)
++    panic("uvmclear");
++  *pte &= ~PTE_U;
++}
++
++// Copy from kernel to user.
++// Copy len bytes from src to virtual address dstva in a given page table.
++// Return 0 on success, -1 on error.
++int
++copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
++{
++  uint64 n, va0, pa0;
++
++  while(len > 0){
++    va0 = PGROUNDDOWN(dstva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (dstva - va0);
++    if(n > len)
++      n = len;
++    memmove((void *)(pa0 + (dstva - va0)), src, n);
++
++    len -= n;
++    src += n;
++    dstva = va0 + PGSIZE;
++  }
++  return 0;
++}
++
++// Copy from user to kernel.
++// Copy len bytes to dst from virtual address srcva in a given page table.
++// Return 0 on success, -1 on error.
++int
++copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
++{
++  uint64 n, va0, pa0;
++
++  while(len > 0){
++    va0 = PGROUNDDOWN(srcva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (srcva - va0);
++    if(n > len)
++      n = len;
++    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
++
++    len -= n;
++    dst += n;
++    srcva = va0 + PGSIZE;
++  }
++  return 0;
++}
++
++// Copy a null-terminated string from user to kernel.
++// Copy bytes to dst from virtual address srcva in a given page table,
++// until a '\0', or max.
++// Return 0 on success, -1 on error.
++int
++copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
++{
++  uint64 n, va0, pa0;
++  int got_null = 0;
++
++  while(got_null == 0 && max > 0){
++    va0 = PGROUNDDOWN(srcva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (srcva - va0);
++    if(n > max)
++      n = max;
++
++    char *p = (char *) (pa0 + (srcva - va0));
++    while(n > 0){
++      if(*p == '\0'){
++        *dst = '\0';
++        got_null = 1;
++        break;
++      } else {
++        *dst = *p;
++      }
++      --n;
++      --max;
++      p++;
++      dst++;
++    }
++
++    srcva = va0 + PGSIZE;
++  }
++  if(got_null){
++    return 0;
++  } else {
++    return -1;
++  }
++}
+diff --git a/user/usertest.c b/user/usertest.c
+new file mode 100644
+index 0000000..e960941
+--- /dev/null
++++ b/user/usertest.c
+@@ -0,0 +1,18 @@
++#include "kernel/param.h"
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++void main(int argc, char *argv[])
++{
++    int n = atoi(argv[1]);
++    printf("%d\n", n);
++    char *i = sbrk(4096 * n);
++    // printf("pointer: %p\n", i);
++    *((int *)i) = 7;
++    printf("Hello %d\n", *i);
++    // char *j = sbrk(4096 * 10);
++    // *((int *)j) = 13;
++    // printf("Hello %d\n", *i);
++    // printf("hello 2 %d\n", *j);
++}
+\ No newline at end of file
diff --git a/paging_CHOLE.patch b/paging_CHOLE.patch
new file mode 100644
index 0000000..357cff7
--- /dev/null
+++ b/paging_CHOLE.patch
@@ -0,0 +1,4929 @@
+diff --git a/Makefile b/Makefile
+index 39a99d7..00df97e 100644
+--- a/Makefile
++++ b/Makefile
+@@ -1,173 +1,175 @@
+-K=kernel
+-U=user
+-
+-OBJS = \
+-  $K/entry.o \
+-  $K/start.o \
+-  $K/console.o \
+-  $K/printf.o \
+-  $K/uart.o \
+-  $K/kalloc.o \
+-  $K/spinlock.o \
+-  $K/string.o \
+-  $K/main.o \
+-  $K/vm.o \
+-  $K/proc.o \
+-  $K/swtch.o \
+-  $K/trampoline.o \
+-  $K/trap.o \
+-  $K/syscall.o \
+-  $K/sysproc.o \
+-  $K/bio.o \
+-  $K/fs.o \
+-  $K/log.o \
+-  $K/sleeplock.o \
+-  $K/file.o \
+-  $K/pipe.o \
+-  $K/exec.o \
+-  $K/sysfile.o \
+-  $K/kernelvec.o \
+-  $K/plic.o \
+-  $K/virtio_disk.o
+-
+-# riscv64-unknown-elf- or riscv64-linux-gnu-
+-# perhaps in /opt/riscv/bin
+-#TOOLPREFIX = 
+-
+-# Try to infer the correct TOOLPREFIX if not set
+-ifndef TOOLPREFIX
+-TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-unknown-elf-'; \
+-	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-linux-gnu-'; \
+-	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
+-	then echo 'riscv64-unknown-linux-gnu-'; \
+-	else echo "***" 1>&2; \
+-	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
+-	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
+-	echo "***" 1>&2; exit 1; fi)
+-endif
+-
+-QEMU = qemu-system-riscv64
+-
+-CC = $(TOOLPREFIX)gcc
+-AS = $(TOOLPREFIX)gas
+-LD = $(TOOLPREFIX)ld
+-OBJCOPY = $(TOOLPREFIX)objcopy
+-OBJDUMP = $(TOOLPREFIX)objdump
+-
+-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
+-CFLAGS += -MD
+-CFLAGS += -mcmodel=medany
+-CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
+-CFLAGS += -I.
+-CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
+-
+-# Disable PIE when possible (for Ubuntu 16.10 toolchain)
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
+-CFLAGS += -fno-pie -no-pie
+-endif
+-ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
+-CFLAGS += -fno-pie -nopie
+-endif
+-
+-LDFLAGS = -z max-page-size=4096
+-
+-$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
+-	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
+-	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
+-	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
+-
+-$U/initcode: $U/initcode.S
+-	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
+-	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
+-	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
+-	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
+-
+-tags: $(OBJS) _init
+-	etags *.S *.c
+-
+-ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
+-
+-_%: %.o $(ULIB)
+-	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
+-	$(OBJDUMP) -S $@ > $*.asm
+-	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
+-
+-$U/usys.S : $U/usys.pl
+-	perl $U/usys.pl > $U/usys.S
+-
+-$U/usys.o : $U/usys.S
+-	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
+-
+-$U/_forktest: $U/forktest.o $(ULIB)
+-	# forktest has less library code linked in - needs to be small
+-	# in order to be able to max out the proc table.
+-	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
+-	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
+-
+-mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
+-	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
+-
+-# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
+-# that disk image changes after first build are persistent until clean.  More
+-# details:
+-# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
+-.PRECIOUS: %.o
+-
+-UPROGS=\
+-	$U/_cat\
+-	$U/_echo\
+-	$U/_forktest\
+-	$U/_grep\
+-	$U/_init\
+-	$U/_kill\
+-	$U/_ln\
+-	$U/_ls\
+-	$U/_mkdir\
+-	$U/_rm\
+-	$U/_sh\
+-	$U/_stressfs\
+-	$U/_usertests\
+-	$U/_grind\
+-	$U/_wc\
+-	$U/_zombie\
+-
+-fs.img: mkfs/mkfs README $(UPROGS)
+-	mkfs/mkfs fs.img README $(UPROGS)
+-
+--include kernel/*.d user/*.d
+-
+-clean: 
+-	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
+-	*/*.o */*.d */*.asm */*.sym \
+-	$U/initcode $U/initcode.out $K/kernel fs.img \
+-	mkfs/mkfs .gdbinit \
+-        $U/usys.S \
+-	$(UPROGS)
+-
+-# try to generate a unique GDB port
+-GDBPORT = $(shell expr `id -u` % 5000 + 25000)
+-# QEMU's gdb stub command line changed in 0.11
+-QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
+-	then echo "-gdb tcp::$(GDBPORT)"; \
+-	else echo "-s -p $(GDBPORT)"; fi)
+-ifndef CPUS
+-CPUS := 3
+-endif
+-
+-QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
+-QEMUOPTS += -global virtio-mmio.force-legacy=false
+-QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
+-QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
+-
+-qemu: $K/kernel fs.img
+-	$(QEMU) $(QEMUOPTS)
+-
+-.gdbinit: .gdbinit.tmpl-riscv
+-	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
+-
+-qemu-gdb: $K/kernel .gdbinit fs.img
+-	@echo "*** Now run 'gdb' in another window." 1>&2
+-	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
+-
++K=kernel
++U=user
++
++OBJS = \
++  $K/entry.o \
++  $K/start.o \
++  $K/console.o \
++  $K/printf.o \
++  $K/uart.o \
++  $K/kalloc.o \
++  $K/spinlock.o \
++  $K/string.o \
++  $K/main.o \
++  $K/vm.o \
++  $K/proc.o \
++  $K/swtch.o \
++  $K/trampoline.o \
++  $K/trap.o \
++  $K/syscall.o \
++  $K/sysproc.o \
++  $K/bio.o \
++  $K/fs.o \
++  $K/log.o \
++  $K/sleeplock.o \
++  $K/file.o \
++  $K/pipe.o \
++  $K/swap.o \
++  $K/exec.o \
++  $K/sysfile.o \
++  $K/kernelvec.o \
++  $K/plic.o \
++  $K/virtio_disk.o
++
++# riscv64-unknown-elf- or riscv64-linux-gnu-
++# perhaps in /opt/riscv/bin
++#TOOLPREFIX = 
++
++# Try to infer the correct TOOLPREFIX if not set
++ifndef TOOLPREFIX
++TOOLPREFIX := $(shell if riscv64-unknown-elf-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-unknown-elf-'; \
++	elif riscv64-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-linux-gnu-'; \
++	elif riscv64-unknown-linux-gnu-objdump -i 2>&1 | grep 'elf64-big' >/dev/null 2>&1; \
++	then echo 'riscv64-unknown-linux-gnu-'; \
++	else echo "***" 1>&2; \
++	echo "*** Error: Couldn't find a riscv64 version of GCC/binutils." 1>&2; \
++	echo "*** To turn off this error, run 'gmake TOOLPREFIX= ...'." 1>&2; \
++	echo "***" 1>&2; exit 1; fi)
++endif
++
++QEMU = qemu-system-riscv64
++
++CC = $(TOOLPREFIX)gcc
++AS = $(TOOLPREFIX)gas
++LD = $(TOOLPREFIX)ld
++OBJCOPY = $(TOOLPREFIX)objcopy
++OBJDUMP = $(TOOLPREFIX)objdump
++
++CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
++CFLAGS += -MD
++CFLAGS += -mcmodel=medany
++CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
++CFLAGS += -I.
++CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
++
++# Disable PIE when possible (for Ubuntu 16.10 toolchain)
++ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
++CFLAGS += -fno-pie -no-pie
++endif
++ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
++CFLAGS += -fno-pie -nopie
++endif
++
++LDFLAGS = -z max-page-size=4096
++
++$K/kernel: $(OBJS) $K/kernel.ld $U/initcode
++	$(LD) $(LDFLAGS) -T $K/kernel.ld -o $K/kernel $(OBJS) 
++	$(OBJDUMP) -S $K/kernel > $K/kernel.asm
++	$(OBJDUMP) -t $K/kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $K/kernel.sym
++
++$U/initcode: $U/initcode.S
++	$(CC) $(CFLAGS) -march=rv64g -nostdinc -I. -Ikernel -c $U/initcode.S -o $U/initcode.o
++	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o $U/initcode.out $U/initcode.o
++	$(OBJCOPY) -S -O binary $U/initcode.out $U/initcode
++	$(OBJDUMP) -S $U/initcode.o > $U/initcode.asm
++
++tags: $(OBJS) _init
++	etags *.S *.c
++
++ULIB = $U/ulib.o $U/usys.o $U/printf.o $U/umalloc.o
++
++_%: %.o $(ULIB)
++	$(LD) $(LDFLAGS) -T $U/user.ld -o $@ $^
++	$(OBJDUMP) -S $@ > $*.asm
++	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
++
++$U/usys.S : $U/usys.pl
++	perl $U/usys.pl > $U/usys.S
++
++$U/usys.o : $U/usys.S
++	$(CC) $(CFLAGS) -c -o $U/usys.o $U/usys.S
++
++$U/_forktest: $U/forktest.o $(ULIB)
++	# forktest has less library code linked in - needs to be small
++	# in order to be able to max out the proc table.
++	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $U/_forktest $U/forktest.o $U/ulib.o $U/usys.o
++	$(OBJDUMP) -S $U/_forktest > $U/forktest.asm
++
++mkfs/mkfs: mkfs/mkfs.c $K/fs.h $K/param.h
++	gcc -Werror -Wall -I. -o mkfs/mkfs mkfs/mkfs.c
++
++# Prevent deletion of intermediate files, e.g. cat.o, after first build, so
++# that disk image changes after first build are persistent until clean.  More
++# details:
++# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
++.PRECIOUS: %.o
++
++UPROGS=\
++	$U/_cat\
++	$U/_echo\
++	$U/_forktest\
++	$U/_grep\
++	$U/_init\
++	$U/_kill\
++	$U/_ln\
++	$U/_ls\
++	$U/_mkdir\
++	$U/_rm\
++	$U/_sh\
++	$U/_stressfs\
++	$U/_usertests\
++	$U/_grind\
++	$U/_wc\
++	$U/_zombie\
++	$U/_usertest\
++
++fs.img: mkfs/mkfs README $(UPROGS)
++	mkfs/mkfs fs.img README $(UPROGS)
++
++-include kernel/*.d user/*.d
++
++clean: 
++	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
++	*/*.o */*.d */*.asm */*.sym \
++	$U/initcode $U/initcode.out $K/kernel fs.img \
++	mkfs/mkfs .gdbinit \
++        $U/usys.S \
++	$(UPROGS)
++
++# try to generate a unique GDB port
++GDBPORT = $(shell expr `id -u` % 5000 + 25000)
++# QEMU's gdb stub command line changed in 0.11
++QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
++	then echo "-gdb tcp::$(GDBPORT)"; \
++	else echo "-s -p $(GDBPORT)"; fi)
++ifndef CPUS
++CPUS := 1
++endif
++
++QEMUOPTS = -machine virt -bios none -kernel $K/kernel -m 128M -smp $(CPUS) -nographic
++QEMUOPTS += -global virtio-mmio.force-legacy=false
++QEMUOPTS += -drive file=fs.img,if=none,format=raw,id=x0
++QEMUOPTS += -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
++
++qemu: $K/kernel fs.img
++	$(QEMU) $(QEMUOPTS)
++
++.gdbinit: .gdbinit.tmpl-riscv
++	sed "s/:1234/:$(GDBPORT)/" < $^ > $@
++
++qemu-gdb: $K/kernel .gdbinit fs.img
++	@echo "*** Now run 'gdb' in another window." 1>&2
++	$(QEMU) $(QEMUOPTS) -S $(QEMUGDB)
++
+diff --git a/kernel/defs.h b/kernel/defs.h
+index a3c962b..84e9983 100644
+--- a/kernel/defs.h
++++ b/kernel/defs.h
+@@ -1,189 +1,208 @@
+-struct buf;
+-struct context;
+-struct file;
+-struct inode;
+-struct pipe;
+-struct proc;
+-struct spinlock;
+-struct sleeplock;
+-struct stat;
+-struct superblock;
+-
+-// bio.c
+-void            binit(void);
+-struct buf*     bread(uint, uint);
+-void            brelse(struct buf*);
+-void            bwrite(struct buf*);
+-void            bpin(struct buf*);
+-void            bunpin(struct buf*);
+-
+-// console.c
+-void            consoleinit(void);
+-void            consoleintr(int);
+-void            consputc(int);
+-
+-// exec.c
+-int             exec(char*, char**);
+-
+-// file.c
+-struct file*    filealloc(void);
+-void            fileclose(struct file*);
+-struct file*    filedup(struct file*);
+-void            fileinit(void);
+-int             fileread(struct file*, uint64, int n);
+-int             filestat(struct file*, uint64 addr);
+-int             filewrite(struct file*, uint64, int n);
+-
+-// fs.c
+-void            fsinit(int);
+-int             dirlink(struct inode*, char*, uint);
+-struct inode*   dirlookup(struct inode*, char*, uint*);
+-struct inode*   ialloc(uint, short);
+-struct inode*   idup(struct inode*);
+-void            iinit();
+-void            ilock(struct inode*);
+-void            iput(struct inode*);
+-void            iunlock(struct inode*);
+-void            iunlockput(struct inode*);
+-void            iupdate(struct inode*);
+-int             namecmp(const char*, const char*);
+-struct inode*   namei(char*);
+-struct inode*   nameiparent(char*, char*);
+-int             readi(struct inode*, int, uint64, uint, uint);
+-void            stati(struct inode*, struct stat*);
+-int             writei(struct inode*, int, uint64, uint, uint);
+-void            itrunc(struct inode*);
+-
+-// ramdisk.c
+-void            ramdiskinit(void);
+-void            ramdiskintr(void);
+-void            ramdiskrw(struct buf*);
+-
+-// kalloc.c
+-void*           kalloc(void);
+-void            kfree(void *);
+-void            kinit(void);
+-
+-// log.c
+-void            initlog(int, struct superblock*);
+-void            log_write(struct buf*);
+-void            begin_op(void);
+-void            end_op(void);
+-
+-// pipe.c
+-int             pipealloc(struct file**, struct file**);
+-void            pipeclose(struct pipe*, int);
+-int             piperead(struct pipe*, uint64, int);
+-int             pipewrite(struct pipe*, uint64, int);
+-
+-// printf.c
+-void            printf(char*, ...);
+-void            panic(char*) __attribute__((noreturn));
+-void            printfinit(void);
+-
+-// proc.c
+-int             cpuid(void);
+-void            exit(int);
+-int             fork(void);
+-int             growproc(int);
+-void            proc_mapstacks(pagetable_t);
+-pagetable_t     proc_pagetable(struct proc *);
+-void            proc_freepagetable(pagetable_t, uint64);
+-int             kill(int);
+-int             killed(struct proc*);
+-void            setkilled(struct proc*);
+-struct cpu*     mycpu(void);
+-struct cpu*     getmycpu(void);
+-struct proc*    myproc();
+-void            procinit(void);
+-void            scheduler(void) __attribute__((noreturn));
+-void            sched(void);
+-void            sleep(void*, struct spinlock*);
+-void            userinit(void);
+-int             wait(uint64);
+-void            wakeup(void*);
+-void            yield(void);
+-int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
+-int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
+-void            procdump(void);
+-
+-// swtch.S
+-void            swtch(struct context*, struct context*);
+-
+-// spinlock.c
+-void            acquire(struct spinlock*);
+-int             holding(struct spinlock*);
+-void            initlock(struct spinlock*, char*);
+-void            release(struct spinlock*);
+-void            push_off(void);
+-void            pop_off(void);
+-
+-// sleeplock.c
+-void            acquiresleep(struct sleeplock*);
+-void            releasesleep(struct sleeplock*);
+-int             holdingsleep(struct sleeplock*);
+-void            initsleeplock(struct sleeplock*, char*);
+-
+-// string.c
+-int             memcmp(const void*, const void*, uint);
+-void*           memmove(void*, const void*, uint);
+-void*           memset(void*, int, uint);
+-char*           safestrcpy(char*, const char*, int);
+-int             strlen(const char*);
+-int             strncmp(const char*, const char*, uint);
+-char*           strncpy(char*, const char*, int);
+-
+-// syscall.c
+-void            argint(int, int*);
+-int             argstr(int, char*, int);
+-void            argaddr(int, uint64 *);
+-int             fetchstr(uint64, char*, int);
+-int             fetchaddr(uint64, uint64*);
+-void            syscall();
+-
+-// trap.c
+-extern uint     ticks;
+-void            trapinit(void);
+-void            trapinithart(void);
+-extern struct spinlock tickslock;
+-void            usertrapret(void);
+-
+-// uart.c
+-void            uartinit(void);
+-void            uartintr(void);
+-void            uartputc(int);
+-void            uartputc_sync(int);
+-int             uartgetc(void);
+-
+-// vm.c
+-void            kvminit(void);
+-void            kvminithart(void);
+-void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
+-int             mappages(pagetable_t, uint64, uint64, uint64, int);
+-pagetable_t     uvmcreate(void);
+-void            uvmfirst(pagetable_t, uchar *, uint);
+-uint64          uvmalloc(pagetable_t, uint64, uint64, int);
+-uint64          uvmdealloc(pagetable_t, uint64, uint64);
+-int             uvmcopy(pagetable_t, pagetable_t, uint64);
+-void            uvmfree(pagetable_t, uint64);
+-void            uvmunmap(pagetable_t, uint64, uint64, int);
+-void            uvmclear(pagetable_t, uint64);
+-pte_t *         walk(pagetable_t, uint64, int);
+-uint64          walkaddr(pagetable_t, uint64);
+-int             copyout(pagetable_t, uint64, char *, uint64);
+-int             copyin(pagetable_t, char *, uint64, uint64);
+-int             copyinstr(pagetable_t, char *, uint64, uint64);
+-
+-// plic.c
+-void            plicinit(void);
+-void            plicinithart(void);
+-int             plic_claim(void);
+-void            plic_complete(int);
+-
+-// virtio_disk.c
+-void            virtio_disk_init(void);
+-void            virtio_disk_rw(struct buf *, int);
+-void            virtio_disk_intr(void);
+-
+-// number of elements in fixed-size array
+-#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
++struct buf;
++struct context;
++struct file;
++struct inode;
++struct pipe;
++struct proc;
++struct spinlock;
++struct sleeplock;
++struct stat;
++struct superblock;
++struct swap;
++
++struct live;
++struct live_page_list;
++struct swapped_pages;
++
++// bio.c
++void            binit(void);
++struct buf*     bread(uint, uint);
++void            brelse(struct buf*);
++void            bwrite(struct buf*);
++void            bpin(struct buf*);
++void            bunpin(struct buf*);
++
++// console.c
++void            consoleinit(void);
++void            consoleintr(int);
++void            consputc(int);
++
++// exec.c
++int             exec(char*, char**);
++
++// file.c
++struct file*    filealloc(void);
++void            fileclose(struct file*);
++struct file*    filedup(struct file*);
++void            fileinit(void);
++int             fileread(struct file*, uint64, int n);
++int             filestat(struct file*, uint64 addr);
++int             filewrite(struct file*, uint64, int n);
++
++// fs.c
++void            fsinit(int);
++uint            balloc(uint dev);
++void            bfree(int dev, uint b);
++int             dirlink(struct inode*, char*, uint);
++struct inode*   dirlookup(struct inode*, char*, uint*);
++struct inode*   ialloc(uint, short);
++struct inode*   idup(struct inode*);
++void            iinit();
++void            ilock(struct inode*);
++void            iput(struct inode*);
++void            iunlock(struct inode*);
++void            iunlockput(struct inode*);
++void            iupdate(struct inode*);
++int             namecmp(const char*, const char*);
++struct inode*   namei(char*);
++struct inode*   nameiparent(char*, char*);
++int             readi(struct inode*, int, uint64, uint, uint);
++void            stati(struct inode*, struct stat*);
++int             writei(struct inode*, int, uint64, uint, uint);
++void            itrunc(struct inode*);
++
++// ramdisk.c
++void            ramdiskinit(void);
++void            ramdiskintr(void);
++void            ramdiskrw(struct buf*);
++
++// kalloc.c
++void*           kalloc(void);
++void            kfree(void *);
++void            kinit(void);
++
++// log.c
++void            initlog(int, struct superblock*);
++void            log_write(struct buf*);
++void            begin_op(void);
++void            end_op(void);
++
++// pipe.c
++int             pipealloc(struct file**, struct file**);
++void            pipeclose(struct pipe*, int);
++int             piperead(struct pipe*, uint64, int);
++int             pipewrite(struct pipe*, uint64, int);
++
++// printf.c
++void            printf(char*, ...);
++void            panic(char*) __attribute__((noreturn));
++void            printfinit(void);
++
++// proc.c
++int             cpuid(void);
++void            exit(int);
++int             fork(void);
++int             growproc(int);
++void            proc_mapstacks(pagetable_t);
++pagetable_t     proc_pagetable(struct proc *);
++void            proc_freepagetable(pagetable_t, uint64);
++int             kill(int);
++int             killed(struct proc*);
++void            setkilled(struct proc*);
++struct cpu*     mycpu(void);
++struct cpu*     getmycpu(void);
++struct proc*    myproc();
++void            procinit(void);
++void            scheduler(void) __attribute__((noreturn));
++void            sched(void);
++void            sleep(void*, struct spinlock*);
++void            userinit(void);
++int             wait(uint64);
++void            wakeup(void*);
++void            yield(void);
++int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
++int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
++void            procdump(void);
++
++// swap.c
++void            swapinit(void);
++void            swapfree(struct swap*);
++struct swap*    swapalloc(void);
++void            swapout(struct swap *dst_sp, char *src_pa);
++void            swapin(char *dst_pa, struct swap *src_sp);
++
++// swtch.S
++void            swtch(struct context*, struct context*);
++
++// spinlock.c
++void            acquire(struct spinlock*);
++int             holding(struct spinlock*);
++void            initlock(struct spinlock*, char*);
++void            release(struct spinlock*);
++void            push_off(void);
++void            pop_off(void);
++
++// sleeplock.c
++void            acquiresleep(struct sleeplock*);
++void            releasesleep(struct sleeplock*);
++int             holdingsleep(struct sleeplock*);
++void            initsleeplock(struct sleeplock*, char*);
++
++// string.c
++int             memcmp(const void*, const void*, uint);
++void*           memmove(void*, const void*, uint);
++void*           memset(void*, int, uint);
++char*           safestrcpy(char*, const char*, int);
++int             strlen(const char*);
++int             strncmp(const char*, const char*, uint);
++char*           strncpy(char*, const char*, int);
++
++// syscall.c
++void            argint(int, int*);
++int             argstr(int, char*, int);
++void            argaddr(int, uint64 *);
++int             fetchstr(uint64, char*, int);
++int             fetchaddr(uint64, uint64*);
++void            syscall();
++
++// trap.c
++extern uint     ticks;
++void            trapinit(void);
++void            trapinithart(void);
++extern struct spinlock tickslock;
++void            usertrapret(void);
++
++// uart.c
++void            uartinit(void);
++void            uartintr(void);
++void            uartputc(int);
++void            uartputc_sync(int);
++int             uartgetc(void);
++
++// vm.c
++void            kvminit(void);
++void            kvminithart(void);
++void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
++int             mappages(pagetable_t, uint64, uint64, uint64, int);
++pagetable_t     uvmcreate(void);
++void            uvmfirst(pagetable_t, uchar *, uint);
++uint64          uvmalloc(pagetable_t, uint64, uint64, int);
++uint64          uvmdealloc(pagetable_t, uint64, uint64);
++int             uvmcopy(pagetable_t, pagetable_t, uint64);
++void            uvmfree(pagetable_t, uint64);
++void            uvmunmap(pagetable_t, uint64, uint64, int);
++void            uvmclear(pagetable_t, uint64);
++pte_t *         walk(pagetable_t, uint64, int);
++uint64          walkaddr(pagetable_t, uint64);
++int             copyout(pagetable_t, uint64, char *, uint64);
++int             copyin(pagetable_t, char *, uint64, uint64);
++int             copyinstr(pagetable_t, char *, uint64, uint64);
++uint            swap_out_wrapper();
++struct live     remove_live_page(int);
++void            add_live_page(pagetable_t, uint64, uint64);
++int             list_lookup(uint64);
++void            print_live_list();
++
++// plic.c
++void            plicinit(void);
++void            plicinithart(void);
++int             plic_claim(void);
++void            plic_complete(int);
++
++// virtio_disk.c
++void            virtio_disk_init(void);
++void            virtio_disk_rw(struct buf *, int);
++void            virtio_disk_intr(void);
++
++// number of elements in fixed-size array
++#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
+diff --git a/kernel/fs.c b/kernel/fs.c
+index c6bab15..2d9b419 100644
+--- a/kernel/fs.c
++++ b/kernel/fs.c
+@@ -62,7 +62,7 @@ bzero(int dev, int bno)
+ 
+ // Allocate a zeroed disk block.
+ // returns 0 if out of disk space.
+-static uint
++uint
+ balloc(uint dev)
+ {
+   int b, bi, m;
+@@ -88,7 +88,7 @@ balloc(uint dev)
+ }
+ 
+ // Free a disk block.
+-static void
++void
+ bfree(int dev, uint b)
+ {
+   struct buf *bp;
+diff --git a/kernel/kalloc.c b/kernel/kalloc.c
+index 0699e7e..e1d2340 100644
+--- a/kernel/kalloc.c
++++ b/kernel/kalloc.c
+@@ -1,82 +1,104 @@
+-// Physical memory allocator, for user processes,
+-// kernel stacks, page-table pages,
+-// and pipe buffers. Allocates whole 4096-byte pages.
+-
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "spinlock.h"
+-#include "riscv.h"
+-#include "defs.h"
+-
+-void freerange(void *pa_start, void *pa_end);
+-
+-extern char end[]; // first address after kernel.
+-                   // defined by kernel.ld.
+-
+-struct run {
+-  struct run *next;
+-};
+-
+-struct {
+-  struct spinlock lock;
+-  struct run *freelist;
+-} kmem;
+-
+-void
+-kinit()
+-{
+-  initlock(&kmem.lock, "kmem");
+-  freerange(end, (void*)PHYSTOP);
+-}
+-
+-void
+-freerange(void *pa_start, void *pa_end)
+-{
+-  char *p;
+-  p = (char*)PGROUNDUP((uint64)pa_start);
+-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+-    kfree(p);
+-}
+-
+-// Free the page of physical memory pointed at by pa,
+-// which normally should have been returned by a
+-// call to kalloc().  (The exception is when
+-// initializing the allocator; see kinit above.)
+-void
+-kfree(void *pa)
+-{
+-  struct run *r;
+-
+-  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
+-    panic("kfree");
+-
+-  // Fill with junk to catch dangling refs.
+-  memset(pa, 1, PGSIZE);
+-
+-  r = (struct run*)pa;
+-
+-  acquire(&kmem.lock);
+-  r->next = kmem.freelist;
+-  kmem.freelist = r;
+-  release(&kmem.lock);
+-}
+-
+-// Allocate one 4096-byte page of physical memory.
+-// Returns a pointer that the kernel can use.
+-// Returns 0 if the memory cannot be allocated.
+-void *
+-kalloc(void)
+-{
+-  struct run *r;
+-
+-  acquire(&kmem.lock);
+-  r = kmem.freelist;
+-  if(r)
+-    kmem.freelist = r->next;
+-  release(&kmem.lock);
+-
+-  if(r)
+-    memset((char*)r, 5, PGSIZE); // fill with junk
+-  return (void*)r;
+-}
++// Physical memory allocator, for user processes,
++// kernel stacks, page-table pages,
++// and pipe buffers. Allocates whole 4096-byte pages.
++
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "defs.h"
++#include "swap.h"
++
++void freerange(void *pa_start, void *pa_end);
++
++extern char end[]; // first address after kernel.
++                   // defined by kernel.ld.
++
++extern struct live_page_list live_list;
++
++struct run {
++  struct run *next;
++};
++
++struct {
++  struct spinlock lock;
++  struct run *freelist;
++} kmem;
++
++// void init_live_pages();
++
++void
++kinit()
++{
++  initlock(&kmem.lock, "kmem");
++  // init_live_pages();
++  initlock(&live_list.lock, "live_list");
++  swapinit();
++  freerange(end, (void*)PHYSTOP);
++}
++
++// void 
++// init_live_pages() {
++//   acquiresleep(&live_list.lock);
++//   for(int i=0;i<MAXPHYPAGES;i++) {
++//     live_list.valid[i] = 0;
++//     // live_list.next_index[i] = -1;
++//   }
++//   live_list.head = 0;
++//   live_list.tail = 0;
++//   live_list.size = 0;
++//   releasesleep(&live_list.lock);
++// }
++
++void
++freerange(void *pa_start, void *pa_end)
++{
++  char *p;
++  p = (char*)PGROUNDUP((uint64)pa_start);
++  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
++    kfree(p);
++}
++
++// Free the page of physical memory pointed at by pa,
++// which normally should have been returned by a
++// call to kalloc().  (The exception is when
++// initializing the allocator; see kinit above.)
++void
++kfree(void *pa)
++{
++  struct run *r;
++
++  if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
++    panic("kfree");
++
++  // Fill with junk to catch dangling refs.
++  memset(pa, 1, PGSIZE);
++
++  r = (struct run*)pa;
++
++  acquire(&kmem.lock);
++  r->next = kmem.freelist;
++  kmem.freelist = r;
++  release(&kmem.lock);
++}
++
++// Allocate one 4096-byte page of physical memory.
++// Returns a pointer that the kernel can use.
++// Returns 0 if the memory cannot be allocated.
++void *
++kalloc(void)
++{
++  struct run *r;
++
++  acquire(&kmem.lock);
++  r = kmem.freelist;
++  if(r)
++    kmem.freelist = r->next;
++  release(&kmem.lock);
++
++  if(r) {
++    memset((char*)r, 5, PGSIZE); // fill with junk
++  }
++  return (void*)r;
++}
++
+diff --git a/kernel/proc.c b/kernel/proc.c
+index 959b778..e156d8a 100644
+--- a/kernel/proc.c
++++ b/kernel/proc.c
+@@ -1,683 +1,696 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "riscv.h"
+-#include "spinlock.h"
+-#include "proc.h"
+-#include "defs.h"
+-
+-struct cpu cpus[NCPU];
+-
+-struct proc proc[NPROC];
+-
+-struct proc *initproc;
+-
+-int nextpid = 1;
+-struct spinlock pid_lock;
+-
+-extern void forkret(void);
+-static void freeproc(struct proc *p);
+-
+-extern char trampoline[]; // trampoline.S
+-
+-// helps ensure that wakeups of wait()ing
+-// parents are not lost. helps obey the
+-// memory model when using p->parent.
+-// must be acquired before any p->lock.
+-struct spinlock wait_lock;
+-
+-// Allocate a page for each process's kernel stack.
+-// Map it high in memory, followed by an invalid
+-// guard page.
+-void
+-proc_mapstacks(pagetable_t kpgtbl)
+-{
+-  struct proc *p;
+-  
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    char *pa = kalloc();
+-    if(pa == 0)
+-      panic("kalloc");
+-    uint64 va = KSTACK((int) (p - proc));
+-    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
+-  }
+-}
+-
+-// initialize the proc table.
+-void
+-procinit(void)
+-{
+-  struct proc *p;
+-  
+-  initlock(&pid_lock, "nextpid");
+-  initlock(&wait_lock, "wait_lock");
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-      initlock(&p->lock, "proc");
+-      p->state = UNUSED;
+-      p->kstack = KSTACK((int) (p - proc));
+-  }
+-}
+-
+-// Must be called with interrupts disabled,
+-// to prevent race with process being moved
+-// to a different CPU.
+-int
+-cpuid()
+-{
+-  int id = r_tp();
+-  return id;
+-}
+-
+-// Return this CPU's cpu struct.
+-// Interrupts must be disabled.
+-struct cpu*
+-mycpu(void)
+-{
+-  int id = cpuid();
+-  struct cpu *c = &cpus[id];
+-  return c;
+-}
+-
+-// Return the current struct proc *, or zero if none.
+-struct proc*
+-myproc(void)
+-{
+-  push_off();
+-  struct cpu *c = mycpu();
+-  struct proc *p = c->proc;
+-  pop_off();
+-  return p;
+-}
+-
+-int
+-allocpid()
+-{
+-  int pid;
+-  
+-  acquire(&pid_lock);
+-  pid = nextpid;
+-  nextpid = nextpid + 1;
+-  release(&pid_lock);
+-
+-  return pid;
+-}
+-
+-// Look in the process table for an UNUSED proc.
+-// If found, initialize state required to run in the kernel,
+-// and return with p->lock held.
+-// If there are no free procs, or a memory allocation fails, return 0.
+-static struct proc*
+-allocproc(void)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    acquire(&p->lock);
+-    if(p->state == UNUSED) {
+-      goto found;
+-    } else {
+-      release(&p->lock);
+-    }
+-  }
+-  return 0;
+-
+-found:
+-  p->pid = allocpid();
+-  p->state = USED;
+-
+-  // Allocate a trapframe page.
+-  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
+-    freeproc(p);
+-    release(&p->lock);
+-    return 0;
+-  }
+-
+-  // An empty user page table.
+-  p->pagetable = proc_pagetable(p);
+-  if(p->pagetable == 0){
+-    freeproc(p);
+-    release(&p->lock);
+-    return 0;
+-  }
+-
+-  // Set up new context to start executing at forkret,
+-  // which returns to user space.
+-  memset(&p->context, 0, sizeof(p->context));
+-  p->context.ra = (uint64)forkret;
+-  p->context.sp = p->kstack + PGSIZE;
+-
+-  return p;
+-}
+-
+-// free a proc structure and the data hanging from it,
+-// including user pages.
+-// p->lock must be held.
+-static void
+-freeproc(struct proc *p)
+-{
+-  if(p->trapframe)
+-    kfree((void*)p->trapframe);
+-  p->trapframe = 0;
+-  if(p->pagetable)
+-    proc_freepagetable(p->pagetable, p->sz);
+-  p->pagetable = 0;
+-  p->sz = 0;
+-  p->pid = 0;
+-  p->parent = 0;
+-  p->name[0] = 0;
+-  p->chan = 0;
+-  p->killed = 0;
+-  p->xstate = 0;
+-  p->state = UNUSED;
+-}
+-
+-// Create a user page table for a given process, with no user memory,
+-// but with trampoline and trapframe pages.
+-pagetable_t
+-proc_pagetable(struct proc *p)
+-{
+-  pagetable_t pagetable;
+-
+-  // An empty page table.
+-  pagetable = uvmcreate();
+-  if(pagetable == 0)
+-    return 0;
+-
+-  // map the trampoline code (for system call return)
+-  // at the highest user virtual address.
+-  // only the supervisor uses it, on the way
+-  // to/from user space, so not PTE_U.
+-  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
+-              (uint64)trampoline, PTE_R | PTE_X) < 0){
+-    uvmfree(pagetable, 0);
+-    return 0;
+-  }
+-
+-  // map the trapframe page just below the trampoline page, for
+-  // trampoline.S.
+-  if(mappages(pagetable, TRAPFRAME, PGSIZE,
+-              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
+-    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+-    uvmfree(pagetable, 0);
+-    return 0;
+-  }
+-
+-  return pagetable;
+-}
+-
+-// Free a process's page table, and free the
+-// physical memory it refers to.
+-void
+-proc_freepagetable(pagetable_t pagetable, uint64 sz)
+-{
+-  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+-  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+-  uvmfree(pagetable, sz);
+-}
+-
+-// a user program that calls exec("/init")
+-// assembled from ../user/initcode.S
+-// od -t xC ../user/initcode
+-uchar initcode[] = {
+-  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
+-  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
+-  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
+-  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
+-  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
+-  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
+-  0x00, 0x00, 0x00, 0x00
+-};
+-
+-// Set up first user process.
+-void
+-userinit(void)
+-{
+-  struct proc *p;
+-
+-  p = allocproc();
+-  initproc = p;
+-  
+-  // allocate one user page and copy initcode's instructions
+-  // and data into it.
+-  uvmfirst(p->pagetable, initcode, sizeof(initcode));
+-  p->sz = PGSIZE;
+-
+-  // prepare for the very first "return" from kernel to user.
+-  p->trapframe->epc = 0;      // user program counter
+-  p->trapframe->sp = PGSIZE;  // user stack pointer
+-
+-  safestrcpy(p->name, "initcode", sizeof(p->name));
+-  p->cwd = namei("/");
+-
+-  p->state = RUNNABLE;
+-
+-  release(&p->lock);
+-}
+-
+-// Grow or shrink user memory by n bytes.
+-// Return 0 on success, -1 on failure.
+-int
+-growproc(int n)
+-{
+-  uint64 sz;
+-  struct proc *p = myproc();
+-
+-  sz = p->sz;
+-  if(n > 0){
+-    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+-      return -1;
+-    }
+-  } else if(n < 0){
+-    sz = uvmdealloc(p->pagetable, sz, sz + n);
+-  }
+-  p->sz = sz;
+-  return 0;
+-}
+-
+-// Create a new process, copying the parent.
+-// Sets up child kernel stack to return as if from fork() system call.
+-int
+-fork(void)
+-{
+-  int i, pid;
+-  struct proc *np;
+-  struct proc *p = myproc();
+-
+-  // Allocate process.
+-  if((np = allocproc()) == 0){
+-    return -1;
+-  }
+-
+-  // Copy user memory from parent to child.
+-  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
+-    freeproc(np);
+-    release(&np->lock);
+-    return -1;
+-  }
+-  np->sz = p->sz;
+-
+-  // copy saved user registers.
+-  *(np->trapframe) = *(p->trapframe);
+-
+-  // Cause fork to return 0 in the child.
+-  np->trapframe->a0 = 0;
+-
+-  // increment reference counts on open file descriptors.
+-  for(i = 0; i < NOFILE; i++)
+-    if(p->ofile[i])
+-      np->ofile[i] = filedup(p->ofile[i]);
+-  np->cwd = idup(p->cwd);
+-
+-  safestrcpy(np->name, p->name, sizeof(p->name));
+-
+-  pid = np->pid;
+-
+-  release(&np->lock);
+-
+-  acquire(&wait_lock);
+-  np->parent = p;
+-  release(&wait_lock);
+-
+-  acquire(&np->lock);
+-  np->state = RUNNABLE;
+-  release(&np->lock);
+-
+-  return pid;
+-}
+-
+-// Pass p's abandoned children to init.
+-// Caller must hold wait_lock.
+-void
+-reparent(struct proc *p)
+-{
+-  struct proc *pp;
+-
+-  for(pp = proc; pp < &proc[NPROC]; pp++){
+-    if(pp->parent == p){
+-      pp->parent = initproc;
+-      wakeup(initproc);
+-    }
+-  }
+-}
+-
+-// Exit the current process.  Does not return.
+-// An exited process remains in the zombie state
+-// until its parent calls wait().
+-void
+-exit(int status)
+-{
+-  struct proc *p = myproc();
+-
+-  if(p == initproc)
+-    panic("init exiting");
+-
+-  // Close all open files.
+-  for(int fd = 0; fd < NOFILE; fd++){
+-    if(p->ofile[fd]){
+-      struct file *f = p->ofile[fd];
+-      fileclose(f);
+-      p->ofile[fd] = 0;
+-    }
+-  }
+-
+-  begin_op();
+-  iput(p->cwd);
+-  end_op();
+-  p->cwd = 0;
+-
+-  acquire(&wait_lock);
+-
+-  // Give any children to init.
+-  reparent(p);
+-
+-  // Parent might be sleeping in wait().
+-  wakeup(p->parent);
+-  
+-  acquire(&p->lock);
+-
+-  p->xstate = status;
+-  p->state = ZOMBIE;
+-
+-  release(&wait_lock);
+-
+-  // Jump into the scheduler, never to return.
+-  sched();
+-  panic("zombie exit");
+-}
+-
+-// Wait for a child process to exit and return its pid.
+-// Return -1 if this process has no children.
+-int
+-wait(uint64 addr)
+-{
+-  struct proc *pp;
+-  int havekids, pid;
+-  struct proc *p = myproc();
+-
+-  acquire(&wait_lock);
+-
+-  for(;;){
+-    // Scan through table looking for exited children.
+-    havekids = 0;
+-    for(pp = proc; pp < &proc[NPROC]; pp++){
+-      if(pp->parent == p){
+-        // make sure the child isn't still in exit() or swtch().
+-        acquire(&pp->lock);
+-
+-        havekids = 1;
+-        if(pp->state == ZOMBIE){
+-          // Found one.
+-          pid = pp->pid;
+-          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
+-                                  sizeof(pp->xstate)) < 0) {
+-            release(&pp->lock);
+-            release(&wait_lock);
+-            return -1;
+-          }
+-          freeproc(pp);
+-          release(&pp->lock);
+-          release(&wait_lock);
+-          return pid;
+-        }
+-        release(&pp->lock);
+-      }
+-    }
+-
+-    // No point waiting if we don't have any children.
+-    if(!havekids || killed(p)){
+-      release(&wait_lock);
+-      return -1;
+-    }
+-    
+-    // Wait for a child to exit.
+-    sleep(p, &wait_lock);  //DOC: wait-sleep
+-  }
+-}
+-
+-// Per-CPU process scheduler.
+-// Each CPU calls scheduler() after setting itself up.
+-// Scheduler never returns.  It loops, doing:
+-//  - choose a process to run.
+-//  - swtch to start running that process.
+-//  - eventually that process transfers control
+-//    via swtch back to the scheduler.
+-void
+-scheduler(void)
+-{
+-  struct proc *p;
+-  struct cpu *c = mycpu();
+-  
+-  c->proc = 0;
+-  for(;;){
+-    // Avoid deadlock by ensuring that devices can interrupt.
+-    intr_on();
+-
+-    for(p = proc; p < &proc[NPROC]; p++) {
+-      acquire(&p->lock);
+-      if(p->state == RUNNABLE) {
+-        // Switch to chosen process.  It is the process's job
+-        // to release its lock and then reacquire it
+-        // before jumping back to us.
+-        p->state = RUNNING;
+-        c->proc = p;
+-        swtch(&c->context, &p->context);
+-
+-        // Process is done running for now.
+-        // It should have changed its p->state before coming back.
+-        c->proc = 0;
+-      }
+-      release(&p->lock);
+-    }
+-  }
+-}
+-
+-// Switch to scheduler.  Must hold only p->lock
+-// and have changed proc->state. Saves and restores
+-// intena because intena is a property of this
+-// kernel thread, not this CPU. It should
+-// be proc->intena and proc->noff, but that would
+-// break in the few places where a lock is held but
+-// there's no process.
+-void
+-sched(void)
+-{
+-  int intena;
+-  struct proc *p = myproc();
+-
+-  if(!holding(&p->lock))
+-    panic("sched p->lock");
+-  if(mycpu()->noff != 1)
+-    panic("sched locks");
+-  if(p->state == RUNNING)
+-    panic("sched running");
+-  if(intr_get())
+-    panic("sched interruptible");
+-
+-  intena = mycpu()->intena;
+-  swtch(&p->context, &mycpu()->context);
+-  mycpu()->intena = intena;
+-}
+-
+-// Give up the CPU for one scheduling round.
+-void
+-yield(void)
+-{
+-  struct proc *p = myproc();
+-  acquire(&p->lock);
+-  p->state = RUNNABLE;
+-  sched();
+-  release(&p->lock);
+-}
+-
+-// A fork child's very first scheduling by scheduler()
+-// will swtch to forkret.
+-void
+-forkret(void)
+-{
+-  static int first = 1;
+-
+-  // Still holding p->lock from scheduler.
+-  release(&myproc()->lock);
+-
+-  if (first) {
+-    // File system initialization must be run in the context of a
+-    // regular process (e.g., because it calls sleep), and thus cannot
+-    // be run from main().
+-    first = 0;
+-    fsinit(ROOTDEV);
+-  }
+-
+-  usertrapret();
+-}
+-
+-// Atomically release lock and sleep on chan.
+-// Reacquires lock when awakened.
+-void
+-sleep(void *chan, struct spinlock *lk)
+-{
+-  struct proc *p = myproc();
+-  
+-  // Must acquire p->lock in order to
+-  // change p->state and then call sched.
+-  // Once we hold p->lock, we can be
+-  // guaranteed that we won't miss any wakeup
+-  // (wakeup locks p->lock),
+-  // so it's okay to release lk.
+-
+-  acquire(&p->lock);  //DOC: sleeplock1
+-  release(lk);
+-
+-  // Go to sleep.
+-  p->chan = chan;
+-  p->state = SLEEPING;
+-
+-  sched();
+-
+-  // Tidy up.
+-  p->chan = 0;
+-
+-  // Reacquire original lock.
+-  release(&p->lock);
+-  acquire(lk);
+-}
+-
+-// Wake up all processes sleeping on chan.
+-// Must be called without any p->lock.
+-void
+-wakeup(void *chan)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++) {
+-    if(p != myproc()){
+-      acquire(&p->lock);
+-      if(p->state == SLEEPING && p->chan == chan) {
+-        p->state = RUNNABLE;
+-      }
+-      release(&p->lock);
+-    }
+-  }
+-}
+-
+-// Kill the process with the given pid.
+-// The victim won't exit until it tries to return
+-// to user space (see usertrap() in trap.c).
+-int
+-kill(int pid)
+-{
+-  struct proc *p;
+-
+-  for(p = proc; p < &proc[NPROC]; p++){
+-    acquire(&p->lock);
+-    if(p->pid == pid){
+-      p->killed = 1;
+-      if(p->state == SLEEPING){
+-        // Wake process from sleep().
+-        p->state = RUNNABLE;
+-      }
+-      release(&p->lock);
+-      return 0;
+-    }
+-    release(&p->lock);
+-  }
+-  return -1;
+-}
+-
+-void
+-setkilled(struct proc *p)
+-{
+-  acquire(&p->lock);
+-  p->killed = 1;
+-  release(&p->lock);
+-}
+-
+-int
+-killed(struct proc *p)
+-{
+-  int k;
+-  
+-  acquire(&p->lock);
+-  k = p->killed;
+-  release(&p->lock);
+-  return k;
+-}
+-
+-// Copy to either a user address, or kernel address,
+-// depending on usr_dst.
+-// Returns 0 on success, -1 on error.
+-int
+-either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
+-{
+-  struct proc *p = myproc();
+-  if(user_dst){
+-    return copyout(p->pagetable, dst, src, len);
+-  } else {
+-    memmove((char *)dst, src, len);
+-    return 0;
+-  }
+-}
+-
+-// Copy from either a user address, or kernel address,
+-// depending on usr_src.
+-// Returns 0 on success, -1 on error.
+-int
+-either_copyin(void *dst, int user_src, uint64 src, uint64 len)
+-{
+-  struct proc *p = myproc();
+-  if(user_src){
+-    return copyin(p->pagetable, dst, src, len);
+-  } else {
+-    memmove(dst, (char*)src, len);
+-    return 0;
+-  }
+-}
+-
+-// Print a process listing to console.  For debugging.
+-// Runs when user types ^P on console.
+-// No lock to avoid wedging a stuck machine further.
+-void
+-procdump(void)
+-{
+-  static char *states[] = {
+-  [UNUSED]    "unused",
+-  [USED]      "used",
+-  [SLEEPING]  "sleep ",
+-  [RUNNABLE]  "runble",
+-  [RUNNING]   "run   ",
+-  [ZOMBIE]    "zombie"
+-  };
+-  struct proc *p;
+-  char *state;
+-
+-  printf("\n");
+-  for(p = proc; p < &proc[NPROC]; p++){
+-    if(p->state == UNUSED)
+-      continue;
+-    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+-      state = states[p->state];
+-    else
+-      state = "???";
+-    printf("%d %s %s", p->pid, state, p->name);
+-    printf("\n");
+-  }
+-}
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "spinlock.h"
++#include "proc.h"
++#include "defs.h"
++
++int global_swap_flag;
++
++struct cpu cpus[NCPU];
++
++struct proc proc[NPROC];
++
++struct proc *initproc;
++
++int nextpid = 1;
++struct spinlock pid_lock;
++
++extern void forkret(void);
++static void freeproc(struct proc *p);
++
++extern char trampoline[]; // trampoline.S
++
++// helps ensure that wakeups of wait()ing
++// parents are not lost. helps obey the
++// memory model when using p->parent.
++// must be acquired before any p->lock.
++struct spinlock wait_lock;
++
++// Allocate a page for each process's kernel stack.
++// Map it high in memory, followed by an invalid
++// guard page.
++void
++proc_mapstacks(pagetable_t kpgtbl)
++{
++  struct proc *p;
++  
++  for(p = proc; p < &proc[NPROC]; p++) {
++    char *pa = kalloc();
++    if(pa == 0)
++      panic("kalloc");
++    uint64 va = KSTACK((int) (p - proc));
++    kvmmap(kpgtbl, va, (uint64)pa, PGSIZE, PTE_R | PTE_W);
++  }
++}
++
++// initialize the proc table.
++void
++procinit(void)
++{
++  struct proc *p;
++  
++  initlock(&pid_lock, "nextpid");
++  initlock(&wait_lock, "wait_lock");
++  for(p = proc; p < &proc[NPROC]; p++) {
++      initlock(&p->lock, "proc");
++      p->state = UNUSED;
++      p->kstack = KSTACK((int) (p - proc));
++  }
++}
++
++// Must be called with interrupts disabled,
++// to prevent race with process being moved
++// to a different CPU.
++int
++cpuid()
++{
++  int id = r_tp();
++  return id;
++}
++
++// Return this CPU's cpu struct.
++// Interrupts must be disabled.
++struct cpu*
++mycpu(void)
++{
++  int id = cpuid();
++  struct cpu *c = &cpus[id];
++  return c;
++}
++
++// Return the current struct proc *, or zero if none.
++struct proc*
++myproc(void)
++{
++  push_off();
++  struct cpu *c = mycpu();
++  struct proc *p = c->proc;
++  pop_off();
++  return p;
++}
++
++int
++allocpid()
++{
++  int pid;
++  
++  acquire(&pid_lock);
++  pid = nextpid;
++  nextpid = nextpid + 1;
++  release(&pid_lock);
++
++  return pid;
++}
++
++// Look in the process table for an UNUSED proc.
++// If found, initialize state required to run in the kernel,
++// and return with p->lock held.
++// If there are no free procs, or a memory allocation fails, return 0.
++static struct proc*
++allocproc(void)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++) {
++    acquire(&p->lock);
++    if(p->state == UNUSED) {
++      goto found;
++    } else {
++      release(&p->lock);
++    }
++  }
++  return 0;
++
++found:
++  p->pid = allocpid();
++  p->state = USED;
++
++  // Allocate a trapframe page.
++  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
++    freeproc(p);
++    release(&p->lock);
++    return 0;
++  }
++
++  // An empty user page table.
++  p->pagetable = proc_pagetable(p);
++  if(p->pagetable == 0){
++    freeproc(p);
++    release(&p->lock);
++    return 0;
++  }
++
++  // Set up new context to start executing at forkret,
++  // which returns to user space.
++  memset(&p->context, 0, sizeof(p->context));
++  p->context.ra = (uint64)forkret;
++  p->context.sp = p->kstack + PGSIZE;
++
++  return p;
++}
++
++// free a proc structure and the data hanging from it,
++// including user pages.
++// p->lock must be held.
++static void
++freeproc(struct proc *p)
++{
++  if(p->trapframe)
++    kfree((void*)p->trapframe);
++  p->trapframe = 0;
++  if(p->pagetable)
++    proc_freepagetable(p->pagetable, p->sz);
++  p->pagetable = 0;
++  p->sz = 0;
++  p->pid = 0;
++  p->parent = 0;
++  p->name[0] = 0;
++  p->chan = 0;
++  p->killed = 0;
++  p->xstate = 0;
++  p->state = UNUSED;
++}
++
++// Create a user page table for a given process, with no user memory,
++// but with trampoline and trapframe pages.
++pagetable_t
++proc_pagetable(struct proc *p)
++{
++  pagetable_t pagetable;
++
++  // An empty page table.
++  pagetable = uvmcreate();
++  if(pagetable == 0)
++    return 0;
++
++  // map the trampoline code (for system call return)
++  // at the highest user virtual address.
++  // only the supervisor uses it, on the way
++  // to/from user space, so not PTE_U.
++  if(mappages(pagetable, TRAMPOLINE, PGSIZE,
++              (uint64)trampoline, PTE_R | PTE_X) < 0){
++    uvmfree(pagetable, 0);
++    return 0;
++  }
++
++  // map the trapframe page just below the trampoline page, for
++  // trampoline.S.
++  if(mappages(pagetable, TRAPFRAME, PGSIZE,
++              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
++    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
++    uvmfree(pagetable, 0);
++    return 0;
++  }
++
++  return pagetable;
++}
++
++// Free a process's page table, and free the
++// physical memory it refers to.
++void
++proc_freepagetable(pagetable_t pagetable, uint64 sz)
++{
++  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
++  uvmunmap(pagetable, TRAPFRAME, 1, 0);
++  uvmfree(pagetable, sz);
++}
++
++// a user program that calls exec("/init")
++// assembled from ../user/initcode.S
++// od -t xC ../user/initcode
++uchar initcode[] = {
++  0x17, 0x05, 0x00, 0x00, 0x13, 0x05, 0x45, 0x02,
++  0x97, 0x05, 0x00, 0x00, 0x93, 0x85, 0x35, 0x02,
++  0x93, 0x08, 0x70, 0x00, 0x73, 0x00, 0x00, 0x00,
++  0x93, 0x08, 0x20, 0x00, 0x73, 0x00, 0x00, 0x00,
++  0xef, 0xf0, 0x9f, 0xff, 0x2f, 0x69, 0x6e, 0x69,
++  0x74, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x00,
++  0x00, 0x00, 0x00, 0x00
++};
++
++// Set up first user process.
++void
++userinit(void)
++{
++  struct proc *p;
++
++  p = allocproc();
++  initproc = p;
++  
++  // allocate one user page and copy initcode's instructions
++  // and data into it.
++  uvmfirst(p->pagetable, initcode, sizeof(initcode));
++  p->sz = PGSIZE;
++
++  // prepare for the very first "return" from kernel to user.
++  p->trapframe->epc = 0;      // user program counter
++  p->trapframe->sp = PGSIZE;  // user stack pointer
++
++  safestrcpy(p->name, "initcode", sizeof(p->name));
++  p->cwd = namei("/");
++
++  p->state = RUNNABLE;
++
++  release(&p->lock);
++}
++
++// Grow or shrink user memory by n bytes.
++// Return 0 on success, -1 on failure.
++int
++growproc(int n)
++{
++  uint64 sz;
++  struct proc *p = myproc();
++
++  sz = p->sz;
++  
++  if(n > 0){
++    // printf("entering growproc with global swap flag %d, n = %d, sz = %d\n", global_swap_flag, n, sz);
++    global_swap_flag = 1;
++    if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
++      return -1;
++    }
++  } else if(n < 0){
++    sz = uvmdealloc(p->pagetable, sz, sz + n);
++  }
++  p->sz = sz;
++  return 0;
++}
++
++// Create a new process, copying the parent.
++// Sets up child kernel stack to return as if from fork() system call.
++int
++fork(void)
++{
++  int i, pid;
++  struct proc *np;
++  struct proc *p = myproc();
++
++  // Allocate process.
++  if((np = allocproc()) == 0){
++    return -1;
++  }
++
++  // Copy user memory from parent to child.
++    release(&np->lock);
++  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
++    freeproc(np);
++    return -1;
++  }
++  acquire(&np->lock);
++  np->sz = p->sz;
++
++  // copy saved user registers.
++  *(np->trapframe) = *(p->trapframe);
++
++  // Cause fork to return 0 in the child.
++  np->trapframe->a0 = 0;
++
++  // increment reference counts on open file descriptors.
++  for(i = 0; i < NOFILE; i++)
++    if(p->ofile[i])
++      np->ofile[i] = filedup(p->ofile[i]);
++  np->cwd = idup(p->cwd);
++
++  safestrcpy(np->name, p->name, sizeof(p->name));
++
++  pid = np->pid;
++
++  release(&np->lock);
++
++  acquire(&wait_lock);
++  np->parent = p;
++  release(&wait_lock);
++
++  acquire(&np->lock);
++  np->state = RUNNABLE;
++  release(&np->lock);
++
++  return pid;
++}
++
++// Pass p's abandoned children to init.
++// Caller must hold wait_lock.
++void
++reparent(struct proc *p)
++{
++  struct proc *pp;
++
++  for(pp = proc; pp < &proc[NPROC]; pp++){
++    if(pp->parent == p){
++      pp->parent = initproc;
++      wakeup(initproc);
++    }
++  }
++}
++
++// Exit the current process.  Does not return.
++// An exited process remains in the zombie state
++// until its parent calls wait().
++void
++exit(int status)
++{
++  struct proc *p = myproc();
++
++  if(p == initproc)
++    panic("init exiting");
++
++  // Close all open files.
++  for(int fd = 0; fd < NOFILE; fd++){
++    if(p->ofile[fd]){
++      struct file *f = p->ofile[fd];
++      fileclose(f);
++      p->ofile[fd] = 0;
++    }
++  }
++
++  begin_op();
++  iput(p->cwd);
++  end_op();
++  p->cwd = 0;
++
++  acquire(&wait_lock);
++  // Give any children to init.
++  reparent(p);
++
++  // Parent might be sleeping in wait().
++  wakeup(p->parent);
++  
++  acquire(&p->lock);
++
++  p->xstate = status;
++  p->state = ZOMBIE;
++
++  release(&wait_lock);
++
++  // Jump into the scheduler, never to return.
++  sched();
++  panic("zombie exit");
++}
++
++// Wait for a child process to exit and return its pid.
++// Return -1 if this process has no children.
++int
++wait(uint64 addr)
++{
++  struct proc *pp;
++  int havekids, pid;
++  struct proc *p = myproc();
++
++  acquire(&wait_lock);
++
++  for(;;){
++    // Scan through table looking for exited children.
++    havekids = 0;
++    for(pp = proc; pp < &proc[NPROC]; pp++){
++      if(pp->parent == p){
++        // make sure the child isn't still in exit() or swtch().
++        acquire(&pp->lock);
++
++        havekids = 1;
++        if(pp->state == ZOMBIE){
++          // Found one.
++          pid = pp->pid;
++          if(addr != 0 && copyout(p->pagetable, addr, (char *)&pp->xstate,
++                                  sizeof(pp->xstate)) < 0) {
++            release(&pp->lock);
++            release(&wait_lock);
++
++            return -1;
++          }
++          // freeproc(pp);
++          release(&pp->lock);
++          release(&wait_lock);
++
++          /* crazy stuff*/
++          //printf("freeproc starting\n");
++          freeproc(pp);
++          //printf("freeproc ended\n");
++          
++          return pid;
++        }
++        release(&pp->lock);
++      }
++    }
++
++    // No point waiting if we don't have any children.
++    if(!havekids || killed(p)){
++      release(&wait_lock);
++      return -1;
++    }
++    
++    // Wait for a child to exit.
++    sleep(p, &wait_lock);  //DOC: wait-sleep
++  }
++}
++
++// Per-CPU process scheduler.
++// Each CPU calls scheduler() after setting itself up.
++// Scheduler never returns.  It loops, doing:
++//  - choose a process to run.
++//  - swtch to start running that process.
++//  - eventually that process transfers control
++//    via swtch back to the scheduler.
++void
++scheduler(void)
++{
++  struct proc *p;
++  struct cpu *c = mycpu();
++  
++  c->proc = 0;
++  for(;;){
++    // Avoid deadlock by ensuring that devices can interrupt.
++    intr_on();
++
++    for(p = proc; p < &proc[NPROC]; p++) {
++      acquire(&p->lock);
++      if(p->state == RUNNABLE) {
++        // Switch to chosen process.  It is the process's job
++        // to release its lock and then reacquire it
++        // before jumping back to us.
++        p->state = RUNNING;
++        c->proc = p;
++        swtch(&c->context, &p->context);
++
++        // Process is done running for now.
++        // It should have changed its p->state before coming back.
++        c->proc = 0;
++      }
++      release(&p->lock);
++    }
++  }
++}
++
++// Switch to scheduler.  Must hold only p->lock
++// and have changed proc->state. Saves and restores
++// intena because intena is a property of this
++// kernel thread, not this CPU. It should
++// be proc->intena and proc->noff, but that would
++// break in the few places where a lock is held but
++// there's no process.
++void
++sched(void)
++{
++  int intena;
++  struct proc *p = myproc();
++
++  if(!holding(&p->lock))
++    panic("sched p->lock");
++  if(mycpu()->noff != 1)
++    panic("sched locks");
++  if(p->state == RUNNING)
++    panic("sched running");
++  if(intr_get())
++    panic("sched interruptible");
++
++  intena = mycpu()->intena;
++  swtch(&p->context, &mycpu()->context);
++  mycpu()->intena = intena;
++}
++
++// Give up the CPU for one scheduling round.
++void
++yield(void)
++{
++  struct proc *p = myproc();
++  acquire(&p->lock);
++  p->state = RUNNABLE;
++  sched();
++  release(&p->lock);
++}
++
++// A fork child's very first scheduling by scheduler()
++// will swtch to forkret.
++void
++forkret(void)
++{
++  static int first = 1;
++
++  // Still holding p->lock from scheduler.
++  release(&myproc()->lock);
++
++  if (first) {
++    // File system initialization must be run in the context of a
++    // regular process (e.g., because it calls sleep), and thus cannot
++    // be run from main().
++    first = 0;
++    fsinit(ROOTDEV);
++  }
++
++  usertrapret();
++}
++
++// Atomically release lock and sleep on chan.
++// Reacquires lock when awakened.
++void
++sleep(void *chan, struct spinlock *lk)
++{
++  struct proc *p = myproc();
++  
++  // Must acquire p->lock in order to
++  // change p->state and then call sched.
++  // Once we hold p->lock, we can be
++  // guaranteed that we won't miss any wakeup
++  // (wakeup locks p->lock),
++  // so it's okay to release lk.
++
++  acquire(&p->lock);  //DOC: sleeplock1
++  release(lk);
++
++  // Go to sleep.
++  p->chan = chan;
++  p->state = SLEEPING;
++
++  sched();
++
++  // Tidy up.
++  p->chan = 0;
++
++  // Reacquire original lock.
++  release(&p->lock);
++  acquire(lk);
++}
++
++// Wake up all processes sleeping on chan.
++// Must be called without any p->lock.
++void
++wakeup(void *chan)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++) {
++    if(p != myproc()){
++      // printf("lock process %d\n", p->pid);
++      acquire(&p->lock);
++      if(p->state == SLEEPING && p->chan == chan) {
++        p->state = RUNNABLE;
++      }
++      release(&p->lock);
++    }
++  }
++}
++
++// Kill the process with the given pid.
++// The victim won't exit until it tries to return
++// to user space (see usertrap() in trap.c).
++int
++kill(int pid)
++{
++  struct proc *p;
++
++  for(p = proc; p < &proc[NPROC]; p++){
++    acquire(&p->lock);
++    if(p->pid == pid){
++      p->killed = 1;
++      if(p->state == SLEEPING){
++        // Wake process from sleep().
++        p->state = RUNNABLE;
++      }
++      release(&p->lock);
++      return 0;
++    }
++    release(&p->lock);
++  }
++  return -1;
++}
++
++void
++setkilled(struct proc *p)
++{
++  acquire(&p->lock);
++  p->killed = 1;
++  release(&p->lock);
++}
++
++int
++killed(struct proc *p)
++{
++  int k;
++  
++  acquire(&p->lock);
++  k = p->killed;
++  release(&p->lock);
++  return k;
++}
++
++// Copy to either a user address, or kernel address,
++// depending on usr_dst.
++// Returns 0 on success, -1 on error.
++int
++either_copyout(int user_dst, uint64 dst, void *src, uint64 len)
++{
++  struct proc *p = myproc();
++  if(user_dst){
++    return copyout(p->pagetable, dst, src, len);
++  } else {
++    memmove((char *)dst, src, len);
++    return 0;
++  }
++}
++
++// Copy from either a user address, or kernel address,
++// depending on usr_src.
++// Returns 0 on success, -1 on error.
++int
++either_copyin(void *dst, int user_src, uint64 src, uint64 len)
++{
++  struct proc *p = myproc();
++  if(user_src){
++    return copyin(p->pagetable, dst, src, len);
++  } else {
++    memmove(dst, (char*)src, len);
++    return 0;
++  }
++}
++
++// Print a process listing to console.  For debugging.
++// Runs when user types ^P on console.
++// No lock to avoid wedging a stuck machine further.
++void
++procdump(void)
++{
++  static char *states[] = {
++  [UNUSED]    "unused",
++  [USED]      "used",
++  [SLEEPING]  "sleep ",
++  [RUNNABLE]  "runble",
++  [RUNNING]   "run   ",
++  [ZOMBIE]    "zombie"
++  };
++  struct proc *p;
++  char *state;
++
++  printf("\n");
++  for(p = proc; p < &proc[NPROC]; p++){
++    if(p->state == UNUSED)
++      continue;
++    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
++      state = states[p->state];
++    else
++      state = "???";
++    printf("%d %s %s", p->pid, state, p->name);
++    printf("\n");
++  }
++}
+diff --git a/kernel/riscv.h b/kernel/riscv.h
+index 20a01db..5da3579 100644
+--- a/kernel/riscv.h
++++ b/kernel/riscv.h
+@@ -1,363 +1,366 @@
+-#ifndef __ASSEMBLER__
+-
+-// which hart (core) is this?
+-static inline uint64
+-r_mhartid()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mhartid" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine Status Register, mstatus
+-
+-#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
+-#define MSTATUS_MPP_M (3L << 11)
+-#define MSTATUS_MPP_S (1L << 11)
+-#define MSTATUS_MPP_U (0L << 11)
+-#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
+-
+-static inline uint64
+-r_mstatus()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mstatus" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mstatus(uint64 x)
+-{
+-  asm volatile("csrw mstatus, %0" : : "r" (x));
+-}
+-
+-// machine exception program counter, holds the
+-// instruction address to which a return from
+-// exception will go.
+-static inline void 
+-w_mepc(uint64 x)
+-{
+-  asm volatile("csrw mepc, %0" : : "r" (x));
+-}
+-
+-// Supervisor Status Register, sstatus
+-
+-#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
+-#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
+-#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
+-#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
+-#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
+-
+-static inline uint64
+-r_sstatus()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sstatus" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sstatus(uint64 x)
+-{
+-  asm volatile("csrw sstatus, %0" : : "r" (x));
+-}
+-
+-// Supervisor Interrupt Pending
+-static inline uint64
+-r_sip()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sip" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sip(uint64 x)
+-{
+-  asm volatile("csrw sip, %0" : : "r" (x));
+-}
+-
+-// Supervisor Interrupt Enable
+-#define SIE_SEIE (1L << 9) // external
+-#define SIE_STIE (1L << 5) // timer
+-#define SIE_SSIE (1L << 1) // software
+-static inline uint64
+-r_sie()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sie" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_sie(uint64 x)
+-{
+-  asm volatile("csrw sie, %0" : : "r" (x));
+-}
+-
+-// Machine-mode Interrupt Enable
+-#define MIE_MEIE (1L << 11) // external
+-#define MIE_MTIE (1L << 7)  // timer
+-#define MIE_MSIE (1L << 3)  // software
+-static inline uint64
+-r_mie()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mie" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mie(uint64 x)
+-{
+-  asm volatile("csrw mie, %0" : : "r" (x));
+-}
+-
+-// supervisor exception program counter, holds the
+-// instruction address to which a return from
+-// exception will go.
+-static inline void 
+-w_sepc(uint64 x)
+-{
+-  asm volatile("csrw sepc, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_sepc()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, sepc" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine Exception Delegation
+-static inline uint64
+-r_medeleg()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, medeleg" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_medeleg(uint64 x)
+-{
+-  asm volatile("csrw medeleg, %0" : : "r" (x));
+-}
+-
+-// Machine Interrupt Delegation
+-static inline uint64
+-r_mideleg()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mideleg" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mideleg(uint64 x)
+-{
+-  asm volatile("csrw mideleg, %0" : : "r" (x));
+-}
+-
+-// Supervisor Trap-Vector Base Address
+-// low two bits are mode.
+-static inline void 
+-w_stvec(uint64 x)
+-{
+-  asm volatile("csrw stvec, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_stvec()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, stvec" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine-mode interrupt vector
+-static inline void 
+-w_mtvec(uint64 x)
+-{
+-  asm volatile("csrw mtvec, %0" : : "r" (x));
+-}
+-
+-// Physical Memory Protection
+-static inline void
+-w_pmpcfg0(uint64 x)
+-{
+-  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
+-}
+-
+-static inline void
+-w_pmpaddr0(uint64 x)
+-{
+-  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
+-}
+-
+-// use riscv's sv39 page table scheme.
+-#define SATP_SV39 (8L << 60)
+-
+-#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
+-
+-// supervisor address translation and protection;
+-// holds the address of the page table.
+-static inline void 
+-w_satp(uint64 x)
+-{
+-  asm volatile("csrw satp, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_satp()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, satp" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_mscratch(uint64 x)
+-{
+-  asm volatile("csrw mscratch, %0" : : "r" (x));
+-}
+-
+-// Supervisor Trap Cause
+-static inline uint64
+-r_scause()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, scause" : "=r" (x) );
+-  return x;
+-}
+-
+-// Supervisor Trap Value
+-static inline uint64
+-r_stval()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, stval" : "=r" (x) );
+-  return x;
+-}
+-
+-// Machine-mode Counter-Enable
+-static inline void 
+-w_mcounteren(uint64 x)
+-{
+-  asm volatile("csrw mcounteren, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_mcounteren()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, mcounteren" : "=r" (x) );
+-  return x;
+-}
+-
+-// machine-mode cycle counter
+-static inline uint64
+-r_time()
+-{
+-  uint64 x;
+-  asm volatile("csrr %0, time" : "=r" (x) );
+-  return x;
+-}
+-
+-// enable device interrupts
+-static inline void
+-intr_on()
+-{
+-  w_sstatus(r_sstatus() | SSTATUS_SIE);
+-}
+-
+-// disable device interrupts
+-static inline void
+-intr_off()
+-{
+-  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
+-}
+-
+-// are device interrupts enabled?
+-static inline int
+-intr_get()
+-{
+-  uint64 x = r_sstatus();
+-  return (x & SSTATUS_SIE) != 0;
+-}
+-
+-static inline uint64
+-r_sp()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, sp" : "=r" (x) );
+-  return x;
+-}
+-
+-// read and write tp, the thread pointer, which xv6 uses to hold
+-// this core's hartid (core number), the index into cpus[].
+-static inline uint64
+-r_tp()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, tp" : "=r" (x) );
+-  return x;
+-}
+-
+-static inline void 
+-w_tp(uint64 x)
+-{
+-  asm volatile("mv tp, %0" : : "r" (x));
+-}
+-
+-static inline uint64
+-r_ra()
+-{
+-  uint64 x;
+-  asm volatile("mv %0, ra" : "=r" (x) );
+-  return x;
+-}
+-
+-// flush the TLB.
+-static inline void
+-sfence_vma()
+-{
+-  // the zero, zero means flush all TLB entries.
+-  asm volatile("sfence.vma zero, zero");
+-}
+-
+-typedef uint64 pte_t;
+-typedef uint64 *pagetable_t; // 512 PTEs
+-
+-#endif // __ASSEMBLER__
+-
+-#define PGSIZE 4096 // bytes per page
+-#define PGSHIFT 12  // bits of offset within a page
+-
+-#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
+-#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
+-
+-#define PTE_V (1L << 0) // valid
+-#define PTE_R (1L << 1)
+-#define PTE_W (1L << 2)
+-#define PTE_X (1L << 3)
+-#define PTE_U (1L << 4) // user can access
+-
+-// shift a physical address to the right place for a PTE.
+-#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
+-
+-#define PTE2PA(pte) (((pte) >> 10) << 12)
+-
+-#define PTE_FLAGS(pte) ((pte) & 0x3FF)
+-
+-// extract the three 9-bit page table indices from a virtual address.
+-#define PXMASK          0x1FF // 9 bits
+-#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
+-#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
+-
+-// one beyond the highest possible virtual address.
+-// MAXVA is actually one bit less than the max allowed by
+-// Sv39, to avoid having to sign-extend virtual addresses
+-// that have the high bit set.
+-#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
++#ifndef __ASSEMBLER__
++
++// which hart (core) is this?
++static inline uint64
++r_mhartid()
++{
++  uint64 x;
++  asm volatile("csrr %0, mhartid" : "=r" (x) );
++  return x;
++}
++
++// Machine Status Register, mstatus
++
++#define MSTATUS_MPP_MASK (3L << 11) // previous mode.
++#define MSTATUS_MPP_M (3L << 11)
++#define MSTATUS_MPP_S (1L << 11)
++#define MSTATUS_MPP_U (0L << 11)
++#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
++
++static inline uint64
++r_mstatus()
++{
++  uint64 x;
++  asm volatile("csrr %0, mstatus" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mstatus(uint64 x)
++{
++  asm volatile("csrw mstatus, %0" : : "r" (x));
++}
++
++// machine exception program counter, holds the
++// instruction address to which a return from
++// exception will go.
++static inline void 
++w_mepc(uint64 x)
++{
++  asm volatile("csrw mepc, %0" : : "r" (x));
++}
++
++// Supervisor Status Register, sstatus
++
++#define SSTATUS_SPP (1L << 8)  // Previous mode, 1=Supervisor, 0=User
++#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
++#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
++#define SSTATUS_SIE (1L << 1)  // Supervisor Interrupt Enable
++#define SSTATUS_UIE (1L << 0)  // User Interrupt Enable
++
++static inline uint64
++r_sstatus()
++{
++  uint64 x;
++  asm volatile("csrr %0, sstatus" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sstatus(uint64 x)
++{
++  asm volatile("csrw sstatus, %0" : : "r" (x));
++}
++
++// Supervisor Interrupt Pending
++static inline uint64
++r_sip()
++{
++  uint64 x;
++  asm volatile("csrr %0, sip" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sip(uint64 x)
++{
++  asm volatile("csrw sip, %0" : : "r" (x));
++}
++
++// Supervisor Interrupt Enable
++#define SIE_SEIE (1L << 9) // external
++#define SIE_STIE (1L << 5) // timer
++#define SIE_SSIE (1L << 1) // software
++static inline uint64
++r_sie()
++{
++  uint64 x;
++  asm volatile("csrr %0, sie" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_sie(uint64 x)
++{
++  asm volatile("csrw sie, %0" : : "r" (x));
++}
++
++// Machine-mode Interrupt Enable
++#define MIE_MEIE (1L << 11) // external
++#define MIE_MTIE (1L << 7)  // timer
++#define MIE_MSIE (1L << 3)  // software
++static inline uint64
++r_mie()
++{
++  uint64 x;
++  asm volatile("csrr %0, mie" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mie(uint64 x)
++{
++  asm volatile("csrw mie, %0" : : "r" (x));
++}
++
++// supervisor exception program counter, holds the
++// instruction address to which a return from
++// exception will go.
++static inline void 
++w_sepc(uint64 x)
++{
++  asm volatile("csrw sepc, %0" : : "r" (x));
++}
++
++static inline uint64
++r_sepc()
++{
++  uint64 x;
++  asm volatile("csrr %0, sepc" : "=r" (x) );
++  return x;
++}
++
++// Machine Exception Delegation
++static inline uint64
++r_medeleg()
++{
++  uint64 x;
++  asm volatile("csrr %0, medeleg" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_medeleg(uint64 x)
++{
++  asm volatile("csrw medeleg, %0" : : "r" (x));
++}
++
++// Machine Interrupt Delegation
++static inline uint64
++r_mideleg()
++{
++  uint64 x;
++  asm volatile("csrr %0, mideleg" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mideleg(uint64 x)
++{
++  asm volatile("csrw mideleg, %0" : : "r" (x));
++}
++
++// Supervisor Trap-Vector Base Address
++// low two bits are mode.
++static inline void 
++w_stvec(uint64 x)
++{
++  asm volatile("csrw stvec, %0" : : "r" (x));
++}
++
++static inline uint64
++r_stvec()
++{
++  uint64 x;
++  asm volatile("csrr %0, stvec" : "=r" (x) );
++  return x;
++}
++
++// Machine-mode interrupt vector
++static inline void 
++w_mtvec(uint64 x)
++{
++  asm volatile("csrw mtvec, %0" : : "r" (x));
++}
++
++// Physical Memory Protection
++static inline void
++w_pmpcfg0(uint64 x)
++{
++  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
++}
++
++static inline void
++w_pmpaddr0(uint64 x)
++{
++  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
++}
++
++// use riscv's sv39 page table scheme.
++#define SATP_SV39 (8L << 60)
++
++#define MAKE_SATP(pagetable) (SATP_SV39 | (((uint64)pagetable) >> 12))
++
++// supervisor address translation and protection;
++// holds the address of the page table.
++static inline void 
++w_satp(uint64 x)
++{
++  asm volatile("csrw satp, %0" : : "r" (x));
++}
++
++static inline uint64
++r_satp()
++{
++  uint64 x;
++  asm volatile("csrr %0, satp" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_mscratch(uint64 x)
++{
++  asm volatile("csrw mscratch, %0" : : "r" (x));
++}
++
++// Supervisor Trap Cause
++static inline uint64
++r_scause()
++{
++  uint64 x;
++  asm volatile("csrr %0, scause" : "=r" (x) );
++  return x;
++}
++
++// Supervisor Trap Value
++static inline uint64
++r_stval()
++{
++  uint64 x;
++  asm volatile("csrr %0, stval" : "=r" (x) );
++  return x;
++}
++
++// Machine-mode Counter-Enable
++static inline void 
++w_mcounteren(uint64 x)
++{
++  asm volatile("csrw mcounteren, %0" : : "r" (x));
++}
++
++static inline uint64
++r_mcounteren()
++{
++  uint64 x;
++  asm volatile("csrr %0, mcounteren" : "=r" (x) );
++  return x;
++}
++
++// machine-mode cycle counter
++static inline uint64
++r_time()
++{
++  uint64 x;
++  asm volatile("csrr %0, time" : "=r" (x) );
++  return x;
++}
++
++// enable device interrupts
++static inline void
++intr_on()
++{
++  w_sstatus(r_sstatus() | SSTATUS_SIE);
++}
++
++// disable device interrupts
++static inline void
++intr_off()
++{
++  w_sstatus(r_sstatus() & ~SSTATUS_SIE);
++}
++
++// are device interrupts enabled?
++static inline int
++intr_get()
++{
++  uint64 x = r_sstatus();
++  return (x & SSTATUS_SIE) != 0;
++}
++
++static inline uint64
++r_sp()
++{
++  uint64 x;
++  asm volatile("mv %0, sp" : "=r" (x) );
++  return x;
++}
++
++// read and write tp, the thread pointer, which xv6 uses to hold
++// this core's hartid (core number), the index into cpus[].
++static inline uint64
++r_tp()
++{
++  uint64 x;
++  asm volatile("mv %0, tp" : "=r" (x) );
++  return x;
++}
++
++static inline void 
++w_tp(uint64 x)
++{
++  asm volatile("mv tp, %0" : : "r" (x));
++}
++
++static inline uint64
++r_ra()
++{
++  uint64 x;
++  asm volatile("mv %0, ra" : "=r" (x) );
++  return x;
++}
++
++// flush the TLB.
++static inline void
++sfence_vma()
++{
++  // the zero, zero means flush all TLB entries.
++  asm volatile("sfence.vma zero, zero");
++}
++
++typedef uint64 pte_t;
++typedef uint64 *pagetable_t; // 512 PTEs
++
++#endif // __ASSEMBLER__
++
++#define PGSIZE 4096 // bytes per page
++#define PGSHIFT 12  // bits of offset within a page
++
++#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
++#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
++
++#define PTE_V (1L << 0) // valid
++#define PTE_R (1L << 1)
++#define PTE_W (1L << 2)
++#define PTE_X (1L << 3)
++#define PTE_U (1L << 4) // user can access
++
++#define PTE_COW (1L << 8)
++#define PTE_SWAP (1L << 9)
++
++// shift a physical address to the right place for a PTE.
++#define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
++
++#define PTE2PA(pte) (((pte) >> 10) << 12)
++
++#define PTE_FLAGS(pte) ((pte) & 0x3FF)
++
++// extract the three 9-bit page table indices from a virtual address.
++#define PXMASK          0x1FF // 9 bits
++#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
++#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
++
++// one beyond the highest possible virtual address.
++// MAXVA is actually one bit less than the max allowed by
++// Sv39, to avoid having to sign-extend virtual addresses
++// that have the high bit set.
++#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
+diff --git a/kernel/swap.c b/kernel/swap.c
+new file mode 100644
+index 0000000..2122326
+--- /dev/null
++++ b/kernel/swap.c
+@@ -0,0 +1,155 @@
++#include "types.h"
++#include "riscv.h"
++#include "fs.h"
++#include "swap.h"
++#include "defs.h"
++#include "param.h"
++#include "proc.h"
++// #include "sleeplock.h"
++#include "buf.h"
++
++#define NBLOCKPERPAGE (PGSIZE / BSIZE)
++
++struct swapped_vpn {
++  uint64 vpn;
++};
++
++struct swap {
++  uint blocknos[NBLOCKPERPAGE];
++};
++
++struct swapped_pages {
++  struct swap swapped_block;
++  struct live page_info;
++  struct swapped_pages *next;
++};
++
++struct run {
++  struct run *next;
++};
++
++struct {
++  struct spinlock lock;
++  struct run *freelist;
++} swapmem;
++
++// Initialize swapmem
++void
++swapinit(void)
++{
++  initlock(&swapmem.lock, "swapmem");
++  swapmem.freelist = 0;
++}
++
++// Allocate one swap struct.
++// Returns a pointer to the swap struct.
++// Returns 0 if the memory cannot be allocated.
++struct swap *
++swapalloc(void)
++{
++  struct run *r;
++  struct swap *s;
++
++  acquire(&swapmem.lock);
++  r = swapmem.freelist;
++  if(!r){
++    release(&swapmem.lock);
++    char *mem = kalloc();
++    char *mem_end = mem + PGSIZE;
++    for(; mem + sizeof(struct swap) <= mem_end; mem += sizeof(struct swap)){
++      r = (struct run*)mem;
++
++      acquire(&swapmem.lock);
++      r->next = swapmem.freelist;
++      swapmem.freelist = r;
++      release(&swapmem.lock);
++    }
++    acquire(&swapmem.lock);
++    r = swapmem.freelist;
++  }
++  swapmem.freelist = r->next;
++  release(&swapmem.lock);
++  
++  s = (struct swap*)r;
++  if(s)
++    memset((char*)s->blocknos, 0, sizeof(s->blocknos)); // fill with zeros
++  
++  return s;
++}
++
++// Free the swap struct pointed by s, and the blocks
++// contained in s, which normally should have been returned
++// by a call to swapalloc() and swapout().
++void
++swapfree(struct swap *s)
++{
++  // printf("inside swapfree\n");
++  uint *blockno;
++  struct run *r;
++
++  if(!s)
++    panic("swapfree");
++  
++  begin_op();
++  for(blockno = s->blocknos; blockno < &s->blocknos[NBLOCKPERPAGE]; blockno++){
++    if(*blockno)
++      bfree(ROOTDEV, *blockno);
++  }
++  end_op();
++
++  r = (struct run*)s;
++
++  acquire(&swapmem.lock);
++  r->next = swapmem.freelist;
++  swapmem.freelist = r;
++  release(&swapmem.lock);
++  // printf("exiting swapfree\n");
++}
++
++// Swap out a given physical page src_pa to disk.
++// The metadata for retriving src_pa will be saved
++// to dst_pa which normally should have been returned
++// by a call to swapalloc().
++void
++swapout(struct swap *dst_sp, char *src_pa)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  begin_op();
++  // printf("crossed begin op\n");
++  for(blockno = dst_sp->blocknos; blockno < &dst_sp->blocknos[NBLOCKPERPAGE]; blockno++, src_pa += BSIZE){
++    // printf("before balloc %d\n", myproc()->pid);
++    *blockno = balloc(ROOTDEV);
++    if(*blockno == 0)
++      panic("swapout");
++    // printf("before bread\n");
++    bp = bread(ROOTDEV, *blockno);
++    // printf("before memmove\n");
++    memmove(bp->data, src_pa, BSIZE);
++    // printf("before log\n");
++    log_write(bp);
++    // printf("after log\n");
++    brelse(bp);
++    
++  }
++  end_op();
++}
++
++// Swap in a page into dst_pa from disk using src_sp.
++// src_sp should normally be updated with metadata
++// for retriving the page by a call to swapout().
++void
++swapin(char *dst_pa, struct swap *src_sp)
++{
++  uint *blockno;
++  struct buf *bp;
++  
++  if(!dst_pa)
++    panic("swapin");
++  for(blockno = src_sp->blocknos; blockno < &src_sp->blocknos[NBLOCKPERPAGE]; blockno++, dst_pa += BSIZE){
++    bp = bread(ROOTDEV, *blockno);
++    memmove(dst_pa, bp->data, BSIZE);
++    brelse(bp);
++  }
++}
+diff --git a/kernel/swap.h b/kernel/swap.h
+new file mode 100644
+index 0000000..8a18da2
+--- /dev/null
++++ b/kernel/swap.h
+@@ -0,0 +1,27 @@
++#ifndef _swap_h_
++#define _swap_h_
++
++#include "types.h"
++#include "spinlock.h"
++#include "sleeplock.h"
++#include "defs.h"
++
++#define MAXPHYPAGES 50
++
++struct live{
++  uint64 vpn;
++  uint64 pa;
++  pagetable_t pagetable;
++};
++
++struct live_page_list {
++  int size;
++  struct spinlock lock;
++  struct live elem[MAXPHYPAGES];
++  // int next_index[MAXPHYPAGES];
++  // int valid[MAXPHYPAGES];
++  // int head;
++  // int tail;
++};
++
++#endif
+\ No newline at end of file
+diff --git a/kernel/trap.c b/kernel/trap.c
+index 512c850..9c4d4cf 100644
+--- a/kernel/trap.c
++++ b/kernel/trap.c
+@@ -1,221 +1,262 @@
+-#include "types.h"
+-#include "param.h"
+-#include "memlayout.h"
+-#include "riscv.h"
+-#include "spinlock.h"
+-#include "proc.h"
+-#include "defs.h"
+-
+-struct spinlock tickslock;
+-uint ticks;
+-
+-extern char trampoline[], uservec[], userret[];
+-
+-// in kernelvec.S, calls kerneltrap().
+-void kernelvec();
+-
+-extern int devintr();
+-
+-void
+-trapinit(void)
+-{
+-  initlock(&tickslock, "time");
+-}
+-
+-// set up to take exceptions and traps while in the kernel.
+-void
+-trapinithart(void)
+-{
+-  w_stvec((uint64)kernelvec);
+-}
+-
+-//
+-// handle an interrupt, exception, or system call from user space.
+-// called from trampoline.S
+-//
+-void
+-usertrap(void)
+-{
+-  int which_dev = 0;
+-
+-  if((r_sstatus() & SSTATUS_SPP) != 0)
+-    panic("usertrap: not from user mode");
+-
+-  // send interrupts and exceptions to kerneltrap(),
+-  // since we're now in the kernel.
+-  w_stvec((uint64)kernelvec);
+-
+-  struct proc *p = myproc();
+-  
+-  // save user program counter.
+-  p->trapframe->epc = r_sepc();
+-  
+-  if(r_scause() == 8){
+-    // system call
+-
+-    if(killed(p))
+-      exit(-1);
+-
+-    // sepc points to the ecall instruction,
+-    // but we want to return to the next instruction.
+-    p->trapframe->epc += 4;
+-
+-    // an interrupt will change sepc, scause, and sstatus,
+-    // so enable only now that we're done with those registers.
+-    intr_on();
+-
+-    syscall();
+-  } else if((which_dev = devintr()) != 0){
+-    // ok
+-  } else {
+-    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
+-    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
+-    setkilled(p);
+-  }
+-
+-  if(killed(p))
+-    exit(-1);
+-
+-  // give up the CPU if this is a timer interrupt.
+-  if(which_dev == 2)
+-    yield();
+-
+-  usertrapret();
+-}
+-
+-//
+-// return to user space
+-//
+-void
+-usertrapret(void)
+-{
+-  struct proc *p = myproc();
+-
+-  // we're about to switch the destination of traps from
+-  // kerneltrap() to usertrap(), so turn off interrupts until
+-  // we're back in user space, where usertrap() is correct.
+-  intr_off();
+-
+-  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
+-  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
+-  w_stvec(trampoline_uservec);
+-
+-  // set up trapframe values that uservec will need when
+-  // the process next traps into the kernel.
+-  p->trapframe->kernel_satp = r_satp();         // kernel page table
+-  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
+-  p->trapframe->kernel_trap = (uint64)usertrap;
+-  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
+-
+-  // set up the registers that trampoline.S's sret will use
+-  // to get to user space.
+-  
+-  // set S Previous Privilege mode to User.
+-  unsigned long x = r_sstatus();
+-  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
+-  x |= SSTATUS_SPIE; // enable interrupts in user mode
+-  w_sstatus(x);
+-
+-  // set S Exception Program Counter to the saved user pc.
+-  w_sepc(p->trapframe->epc);
+-
+-  // tell trampoline.S the user page table to switch to.
+-  uint64 satp = MAKE_SATP(p->pagetable);
+-
+-  // jump to userret in trampoline.S at the top of memory, which 
+-  // switches to the user page table, restores user registers,
+-  // and switches to user mode with sret.
+-  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
+-  ((void (*)(uint64))trampoline_userret)(satp);
+-}
+-
+-// interrupts and exceptions from kernel code go here via kernelvec,
+-// on whatever the current kernel stack is.
+-void 
+-kerneltrap()
+-{
+-  int which_dev = 0;
+-  uint64 sepc = r_sepc();
+-  uint64 sstatus = r_sstatus();
+-  uint64 scause = r_scause();
+-  
+-  if((sstatus & SSTATUS_SPP) == 0)
+-    panic("kerneltrap: not from supervisor mode");
+-  if(intr_get() != 0)
+-    panic("kerneltrap: interrupts enabled");
+-
+-  if((which_dev = devintr()) == 0){
+-    printf("scause %p\n", scause);
+-    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
+-    panic("kerneltrap");
+-  }
+-
+-  // give up the CPU if this is a timer interrupt.
+-  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
+-    yield();
+-
+-  // the yield() may have caused some traps to occur,
+-  // so restore trap registers for use by kernelvec.S's sepc instruction.
+-  w_sepc(sepc);
+-  w_sstatus(sstatus);
+-}
+-
+-void
+-clockintr()
+-{
+-  acquire(&tickslock);
+-  ticks++;
+-  wakeup(&ticks);
+-  release(&tickslock);
+-}
+-
+-// check if it's an external interrupt or software interrupt,
+-// and handle it.
+-// returns 2 if timer interrupt,
+-// 1 if other device,
+-// 0 if not recognized.
+-int
+-devintr()
+-{
+-  uint64 scause = r_scause();
+-
+-  if((scause & 0x8000000000000000L) &&
+-     (scause & 0xff) == 9){
+-    // this is a supervisor external interrupt, via PLIC.
+-
+-    // irq indicates which device interrupted.
+-    int irq = plic_claim();
+-
+-    if(irq == UART0_IRQ){
+-      uartintr();
+-    } else if(irq == VIRTIO0_IRQ){
+-      virtio_disk_intr();
+-    } else if(irq){
+-      printf("unexpected interrupt irq=%d\n", irq);
+-    }
+-
+-    // the PLIC allows each device to raise at most one
+-    // interrupt at a time; tell the PLIC the device is
+-    // now allowed to interrupt again.
+-    if(irq)
+-      plic_complete(irq);
+-
+-    return 1;
+-  } else if(scause == 0x8000000000000001L){
+-    // software interrupt from a machine-mode timer interrupt,
+-    // forwarded by timervec in kernelvec.S.
+-
+-    if(cpuid() == 0){
+-      clockintr();
+-    }
+-    
+-    // acknowledge the software interrupt by clearing
+-    // the SSIP bit in sip.
+-    w_sip(r_sip() & ~2);
+-
+-    return 2;
+-  } else {
+-    return 0;
+-  }
+-}
+-
++#include "types.h"
++#include "param.h"
++#include "memlayout.h"
++#include "riscv.h"
++#include "swap.h"
++#include "proc.h"
++#include "defs.h"
++
++struct spinlock tickslock;
++uint ticks;
++
++extern struct live_page_list live_list;
++
++extern char trampoline[], uservec[], userret[];
++
++// in kernelvec.S, calls kerneltrap().
++void kernelvec();
++
++extern int devintr();
++
++void
++trapinit(void)
++{
++  initlock(&tickslock, "time");
++}
++
++// set up to take exceptions and traps while in the kernel.
++void
++trapinithart(void)
++{
++  w_stvec((uint64)kernelvec);
++}
++
++//
++// handle an interrupt, exception, or system call from user space.
++// called from trampoline.S
++//
++void
++usertrap(void)
++{
++  int which_dev = 0;
++
++  if((r_sstatus() & SSTATUS_SPP) != 0)
++    panic("usertrap: not from user mode");
++
++  // send interrupts and exceptions to kerneltrap(),
++  // since we're now in the kernel.
++  w_stvec((uint64)kernelvec);
++
++  struct proc *p = myproc();
++  
++  // save user program counter.
++  p->trapframe->epc = r_sepc();
++  
++  if(r_scause() == 8){
++    // system call
++
++    if(killed(p))
++      exit(-1);
++
++    // sepc points to the ecall instruction,
++    // but we want to return to the next instruction.
++    p->trapframe->epc += 4;
++
++    // an interrupt will change sepc, scause, and sstatus,
++    // so enable only now that we're done with those registers.
++    intr_on();
++
++    syscall();
++  } else if (r_scause() == 15 || r_scause() == 13) {
++      // printf("yessir got it for %d\n", r_stval());
++      struct proc *p = myproc();
++      uint flags;
++      uint64 va = PGROUNDDOWN(r_stval());
++      uint64 toSwap;
++      pte_t *pte;
++      char *mem;
++
++      if((pte = walk(p->pagetable, va, 0)) == 0) {
++        printf("No such page\n");
++        return ;
++      }
++      flags = PTE_FLAGS(*pte);
++      if(flags & PTE_SWAP) {
++        flags &= (~PTE_SWAP);
++        flags |= (PTE_V);
++        toSwap = (*pte >> 10);
++        if (swap_out_wrapper() == 0) {
++          panic("in trap, swap out error\n");
++        }
++        if((mem = kalloc()) == 0) {
++          panic("in trap, memory allocation error\n");
++        }
++        // swap address unmapping
++        uvmunmap(p->pagetable, va, 1, 0);
++
++        // printf("uvmcopy: before releasing %d\n", p->pid);
++        // release(&p->lock);
++        // printf("uvmcopy: after releasing %d\n", p->pid);
++        swapin(mem, (struct swap *)toSwap);
++        // acquire(&p->lock);
++
++        if((mappages(p->pagetable, va, PGSIZE, (uint64)mem, flags)) != 0) {
++          panic("in trap, mapping failed\n");
++        }
++        swapfree((struct swap *)toSwap);
++        // printf("Exiting Trap\n");
++      }
++  } else if((which_dev = devintr()) != 0){
++     // ok
++  } else {
++    // printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
++    // printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
++    setkilled(p);
++  }
++
++  if(killed(p))
++    exit(-1);
++
++  // give up the CPU if this is a timer interrupt.
++  if(which_dev == 2)
++    yield();
++
++  usertrapret();
++}
++
++//
++// return to user space
++//
++void
++usertrapret(void)
++{
++  struct proc *p = myproc();
++
++  // we're about to switch the destination of traps from
++  // kerneltrap() to usertrap(), so turn off interrupts until
++  // we're back in user space, where usertrap() is correct.
++  intr_off();
++
++  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
++  uint64 trampoline_uservec = TRAMPOLINE + (uservec - trampoline);
++  w_stvec(trampoline_uservec);
++
++  // set up trapframe values that uservec will need when
++  // the process next traps into the kernel.
++  p->trapframe->kernel_satp = r_satp();         // kernel page table
++  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
++  p->trapframe->kernel_trap = (uint64)usertrap;
++  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
++
++  // set up the registers that trampoline.S's sret will use
++  // to get to user space.
++  
++  // set S Previous Privilege mode to User.
++  unsigned long x = r_sstatus();
++  x &= ~SSTATUS_SPP; // clear SPP to 0 for user mode
++  x |= SSTATUS_SPIE; // enable interrupts in user mode
++  w_sstatus(x);
++
++  // set S Exception Program Counter to the saved user pc.
++  w_sepc(p->trapframe->epc);
++
++  // tell trampoline.S the user page table to switch to.
++  uint64 satp = MAKE_SATP(p->pagetable);
++
++  // jump to userret in trampoline.S at the top of memory, which 
++  // switches to the user page table, restores user registers,
++  // and switches to user mode with sret.
++  uint64 trampoline_userret = TRAMPOLINE + (userret - trampoline);
++  ((void (*)(uint64))trampoline_userret)(satp);
++}
++
++// interrupts and exceptions from kernel code go here via kernelvec,
++// on whatever the current kernel stack is.
++void 
++kerneltrap()
++{
++  int which_dev = 0;
++  uint64 sepc = r_sepc();
++  uint64 sstatus = r_sstatus();
++  uint64 scause = r_scause();
++  
++  if((sstatus & SSTATUS_SPP) == 0)
++    panic("kerneltrap: not from supervisor mode");
++  if(intr_get() != 0)
++    panic("kerneltrap: interrupts enabled");
++
++  if((which_dev = devintr()) == 0){
++    printf("scause %p\n", scause);
++    printf("sepc=%p stval=%p\n", r_sepc(), r_stval());
++    panic("kerneltrap");
++  }
++
++  // give up the CPU if this is a timer interrupt.
++  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
++    yield();
++
++  // the yield() may have caused some traps to occur,
++  // so restore trap registers for use by kernelvec.S's sepc instruction.
++  w_sepc(sepc);
++  w_sstatus(sstatus);
++}
++
++void
++clockintr()
++{
++  acquire(&tickslock);
++  ticks++;
++  wakeup(&ticks);
++  release(&tickslock);
++}
++
++// check if it's an external interrupt or software interrupt,
++// and handle it.
++// returns 2 if timer interrupt,
++// 1 if other device,
++// 0 if not recognized.
++int
++devintr()
++{
++  uint64 scause = r_scause();
++
++  if((scause & 0x8000000000000000L) &&
++     (scause & 0xff) == 9){
++    // this is a supervisor external interrupt, via PLIC.
++
++    // irq indicates which device interrupted.
++    int irq = plic_claim();
++
++    if(irq == UART0_IRQ){
++      uartintr();
++    } else if(irq == VIRTIO0_IRQ){
++      virtio_disk_intr();
++    } else if(irq){
++      printf("unexpected interrupt irq=%d\n", irq);
++    }
++
++    // the PLIC allows each device to raise at most one
++    // interrupt at a time; tell the PLIC the device is
++    // now allowed to interrupt again.
++    if(irq)
++      plic_complete(irq);
++
++    return 1;
++  } else if(scause == 0x8000000000000001L){
++    // software interrupt from a machine-mode timer interrupt,
++    // forwarded by timervec in kernelvec.S.
++
++    if(cpuid() == 0){
++      clockintr();
++    }
++    
++    // acknowledge the software interrupt by clearing
++    // the SSIP bit in sip.
++    w_sip(r_sip() & ~2);
++
++    return 2;
++  } else {
++    return 0;
++  }
++}
++
+diff --git a/kernel/vm.c b/kernel/vm.c
+index 9f69783..f75e7b5 100644
+--- a/kernel/vm.c
++++ b/kernel/vm.c
+@@ -1,439 +1,676 @@
+-#include "param.h"
+-#include "types.h"
+-#include "memlayout.h"
+-#include "elf.h"
+-#include "riscv.h"
+-#include "defs.h"
+-#include "fs.h"
+-
+-/*
+- * the kernel's page table.
+- */
+-pagetable_t kernel_pagetable;
+-
+-extern char etext[];  // kernel.ld sets this to end of kernel code.
+-
+-extern char trampoline[]; // trampoline.S
+-
+-// Make a direct-map page table for the kernel.
+-pagetable_t
+-kvmmake(void)
+-{
+-  pagetable_t kpgtbl;
+-
+-  kpgtbl = (pagetable_t) kalloc();
+-  memset(kpgtbl, 0, PGSIZE);
+-
+-  // uart registers
+-  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
+-
+-  // virtio mmio disk interface
+-  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
+-
+-  // PLIC
+-  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
+-
+-  // map kernel text executable and read-only.
+-  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
+-
+-  // map kernel data and the physical RAM we'll make use of.
+-  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
+-
+-  // map the trampoline for trap entry/exit to
+-  // the highest virtual address in the kernel.
+-  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
+-
+-  // allocate and map a kernel stack for each process.
+-  proc_mapstacks(kpgtbl);
+-  
+-  return kpgtbl;
+-}
+-
+-// Initialize the one kernel_pagetable
+-void
+-kvminit(void)
+-{
+-  kernel_pagetable = kvmmake();
+-}
+-
+-// Switch h/w page table register to the kernel's page table,
+-// and enable paging.
+-void
+-kvminithart()
+-{
+-  // wait for any previous writes to the page table memory to finish.
+-  sfence_vma();
+-
+-  w_satp(MAKE_SATP(kernel_pagetable));
+-
+-  // flush stale entries from the TLB.
+-  sfence_vma();
+-}
+-
+-// Return the address of the PTE in page table pagetable
+-// that corresponds to virtual address va.  If alloc!=0,
+-// create any required page-table pages.
+-//
+-// The risc-v Sv39 scheme has three levels of page-table
+-// pages. A page-table page contains 512 64-bit PTEs.
+-// A 64-bit virtual address is split into five fields:
+-//   39..63 -- must be zero.
+-//   30..38 -- 9 bits of level-2 index.
+-//   21..29 -- 9 bits of level-1 index.
+-//   12..20 -- 9 bits of level-0 index.
+-//    0..11 -- 12 bits of byte offset within the page.
+-pte_t *
+-walk(pagetable_t pagetable, uint64 va, int alloc)
+-{
+-  if(va >= MAXVA)
+-    panic("walk");
+-
+-  for(int level = 2; level > 0; level--) {
+-    pte_t *pte = &pagetable[PX(level, va)];
+-    if(*pte & PTE_V) {
+-      pagetable = (pagetable_t)PTE2PA(*pte);
+-    } else {
+-      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
+-        return 0;
+-      memset(pagetable, 0, PGSIZE);
+-      *pte = PA2PTE(pagetable) | PTE_V;
+-    }
+-  }
+-  return &pagetable[PX(0, va)];
+-}
+-
+-// Look up a virtual address, return the physical address,
+-// or 0 if not mapped.
+-// Can only be used to look up user pages.
+-uint64
+-walkaddr(pagetable_t pagetable, uint64 va)
+-{
+-  pte_t *pte;
+-  uint64 pa;
+-
+-  if(va >= MAXVA)
+-    return 0;
+-
+-  pte = walk(pagetable, va, 0);
+-  if(pte == 0)
+-    return 0;
+-  if((*pte & PTE_V) == 0)
+-    return 0;
+-  if((*pte & PTE_U) == 0)
+-    return 0;
+-  pa = PTE2PA(*pte);
+-  return pa;
+-}
+-
+-// add a mapping to the kernel page table.
+-// only used when booting.
+-// does not flush TLB or enable paging.
+-void
+-kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
+-{
+-  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
+-    panic("kvmmap");
+-}
+-
+-// Create PTEs for virtual addresses starting at va that refer to
+-// physical addresses starting at pa. va and size might not
+-// be page-aligned. Returns 0 on success, -1 if walk() couldn't
+-// allocate a needed page-table page.
+-int
+-mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
+-{
+-  uint64 a, last;
+-  pte_t *pte;
+-
+-  if(size == 0)
+-    panic("mappages: size");
+-  
+-  a = PGROUNDDOWN(va);
+-  last = PGROUNDDOWN(va + size - 1);
+-  for(;;){
+-    if((pte = walk(pagetable, a, 1)) == 0)
+-      return -1;
+-    if(*pte & PTE_V)
+-      panic("mappages: remap");
+-    *pte = PA2PTE(pa) | perm | PTE_V;
+-    if(a == last)
+-      break;
+-    a += PGSIZE;
+-    pa += PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Remove npages of mappings starting from va. va must be
+-// page-aligned. The mappings must exist.
+-// Optionally free the physical memory.
+-void
+-uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
+-{
+-  uint64 a;
+-  pte_t *pte;
+-
+-  if((va % PGSIZE) != 0)
+-    panic("uvmunmap: not aligned");
+-
+-  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
+-    if((pte = walk(pagetable, a, 0)) == 0)
+-      panic("uvmunmap: walk");
+-    if((*pte & PTE_V) == 0)
+-      panic("uvmunmap: not mapped");
+-    if(PTE_FLAGS(*pte) == PTE_V)
+-      panic("uvmunmap: not a leaf");
+-    if(do_free){
+-      uint64 pa = PTE2PA(*pte);
+-      kfree((void*)pa);
+-    }
+-    *pte = 0;
+-  }
+-}
+-
+-// create an empty user page table.
+-// returns 0 if out of memory.
+-pagetable_t
+-uvmcreate()
+-{
+-  pagetable_t pagetable;
+-  pagetable = (pagetable_t) kalloc();
+-  if(pagetable == 0)
+-    return 0;
+-  memset(pagetable, 0, PGSIZE);
+-  return pagetable;
+-}
+-
+-// Load the user initcode into address 0 of pagetable,
+-// for the very first process.
+-// sz must be less than a page.
+-void
+-uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
+-{
+-  char *mem;
+-
+-  if(sz >= PGSIZE)
+-    panic("uvmfirst: more than a page");
+-  mem = kalloc();
+-  memset(mem, 0, PGSIZE);
+-  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
+-  memmove(mem, src, sz);
+-}
+-
+-// Allocate PTEs and physical memory to grow process from oldsz to
+-// newsz, which need not be page aligned.  Returns new size or 0 on error.
+-uint64
+-uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
+-{
+-  char *mem;
+-  uint64 a;
+-
+-  if(newsz < oldsz)
+-    return oldsz;
+-
+-  oldsz = PGROUNDUP(oldsz);
+-  for(a = oldsz; a < newsz; a += PGSIZE){
+-    mem = kalloc();
+-    if(mem == 0){
+-      uvmdealloc(pagetable, a, oldsz);
+-      return 0;
+-    }
+-    memset(mem, 0, PGSIZE);
+-    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
+-      kfree(mem);
+-      uvmdealloc(pagetable, a, oldsz);
+-      return 0;
+-    }
+-  }
+-  return newsz;
+-}
+-
+-// Deallocate user pages to bring the process size from oldsz to
+-// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
+-// need to be less than oldsz.  oldsz can be larger than the actual
+-// process size.  Returns the new process size.
+-uint64
+-uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+-{
+-  if(newsz >= oldsz)
+-    return oldsz;
+-
+-  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+-    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+-    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
+-  }
+-
+-  return newsz;
+-}
+-
+-// Recursively free page-table pages.
+-// All leaf mappings must already have been removed.
+-void
+-freewalk(pagetable_t pagetable)
+-{
+-  // there are 2^9 = 512 PTEs in a page table.
+-  for(int i = 0; i < 512; i++){
+-    pte_t pte = pagetable[i];
+-    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
+-      // this PTE points to a lower-level page table.
+-      uint64 child = PTE2PA(pte);
+-      freewalk((pagetable_t)child);
+-      pagetable[i] = 0;
+-    } else if(pte & PTE_V){
+-      panic("freewalk: leaf");
+-    }
+-  }
+-  kfree((void*)pagetable);
+-}
+-
+-// Free user memory pages,
+-// then free page-table pages.
+-void
+-uvmfree(pagetable_t pagetable, uint64 sz)
+-{
+-  if(sz > 0)
+-    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
+-  freewalk(pagetable);
+-}
+-
+-// Given a parent process's page table, copy
+-// its memory into a child's page table.
+-// Copies both the page table and the
+-// physical memory.
+-// returns 0 on success, -1 on failure.
+-// frees any allocated pages on failure.
+-int
+-uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
+-{
+-  pte_t *pte;
+-  uint64 pa, i;
+-  uint flags;
+-  char *mem;
+-
+-  for(i = 0; i < sz; i += PGSIZE){
+-    if((pte = walk(old, i, 0)) == 0)
+-      panic("uvmcopy: pte should exist");
+-    if((*pte & PTE_V) == 0)
+-      panic("uvmcopy: page not present");
+-    pa = PTE2PA(*pte);
+-    flags = PTE_FLAGS(*pte);
+-    if((mem = kalloc()) == 0)
+-      goto err;
+-    memmove(mem, (char*)pa, PGSIZE);
+-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+-      kfree(mem);
+-      goto err;
+-    }
+-  }
+-  return 0;
+-
+- err:
+-  uvmunmap(new, 0, i / PGSIZE, 1);
+-  return -1;
+-}
+-
+-// mark a PTE invalid for user access.
+-// used by exec for the user stack guard page.
+-void
+-uvmclear(pagetable_t pagetable, uint64 va)
+-{
+-  pte_t *pte;
+-  
+-  pte = walk(pagetable, va, 0);
+-  if(pte == 0)
+-    panic("uvmclear");
+-  *pte &= ~PTE_U;
+-}
+-
+-// Copy from kernel to user.
+-// Copy len bytes from src to virtual address dstva in a given page table.
+-// Return 0 on success, -1 on error.
+-int
+-copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+-{
+-  uint64 n, va0, pa0;
+-
+-  while(len > 0){
+-    va0 = PGROUNDDOWN(dstva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (dstva - va0);
+-    if(n > len)
+-      n = len;
+-    memmove((void *)(pa0 + (dstva - va0)), src, n);
+-
+-    len -= n;
+-    src += n;
+-    dstva = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Copy from user to kernel.
+-// Copy len bytes to dst from virtual address srcva in a given page table.
+-// Return 0 on success, -1 on error.
+-int
+-copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
+-{
+-  uint64 n, va0, pa0;
+-
+-  while(len > 0){
+-    va0 = PGROUNDDOWN(srcva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (srcva - va0);
+-    if(n > len)
+-      n = len;
+-    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
+-
+-    len -= n;
+-    dst += n;
+-    srcva = va0 + PGSIZE;
+-  }
+-  return 0;
+-}
+-
+-// Copy a null-terminated string from user to kernel.
+-// Copy bytes to dst from virtual address srcva in a given page table,
+-// until a '\0', or max.
+-// Return 0 on success, -1 on error.
+-int
+-copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
+-{
+-  uint64 n, va0, pa0;
+-  int got_null = 0;
+-
+-  while(got_null == 0 && max > 0){
+-    va0 = PGROUNDDOWN(srcva);
+-    pa0 = walkaddr(pagetable, va0);
+-    if(pa0 == 0)
+-      return -1;
+-    n = PGSIZE - (srcva - va0);
+-    if(n > max)
+-      n = max;
+-
+-    char *p = (char *) (pa0 + (srcva - va0));
+-    while(n > 0){
+-      if(*p == '\0'){
+-        *dst = '\0';
+-        got_null = 1;
+-        break;
+-      } else {
+-        *dst = *p;
+-      }
+-      --n;
+-      --max;
+-      p++;
+-      dst++;
+-    }
+-
+-    srcva = va0 + PGSIZE;
+-  }
+-  if(got_null){
+-    return 0;
+-  } else {
+-    return -1;
+-  }
+-}
++#include "param.h"
++#include "types.h"
++#include "memlayout.h"
++#include "elf.h"
++#include "riscv.h"
++#include "defs.h"
++#include "fs.h"
++
++#include "swap.h"
++#include "proc.h"
++
++extern int global_swap_flag;
++
++struct live_page_list live_list;
++struct swapped_pages *swapped_list;
++
++void print_live_count() {
++  printf("Live Pages: %d\n", live_list.size);
++}
++
++
++/*
++ * the kernel's page table.
++ */
++pagetable_t kernel_pagetable;
++
++
++extern char etext[];  // kernel.ld sets this to end of kernel code.
++
++extern char trampoline[]; // trampoline.S
++
++// Make a direct-map page table for the kernel.
++pagetable_t
++kvmmake(void)
++{
++  pagetable_t kpgtbl;
++
++  kpgtbl = (pagetable_t) kalloc();
++  memset(kpgtbl, 0, PGSIZE);
++
++  // printf("In kvmmake\n");
++  // uart registers
++  kvmmap(kpgtbl, UART0, UART0, PGSIZE, PTE_R | PTE_W);
++
++  // printf("In kvmmake 2\n");
++
++  // virtio mmio disk interface
++  kvmmap(kpgtbl, VIRTIO0, VIRTIO0, PGSIZE, PTE_R | PTE_W);
++
++  // printf("In kvmmake 3\n");
++
++  // PLIC
++  kvmmap(kpgtbl, PLIC, PLIC, 0x400000, PTE_R | PTE_W);
++
++  // map kernel text executable and read-only.
++  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
++
++  // map kernel data and the physical RAM we'll make use of.
++  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
++
++  // map the trampoline for trap entry/exit to
++  // the highest virtual address in the kernel.
++  kvmmap(kpgtbl, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X);
++
++  // allocate and map a kernel stack for each process.
++  proc_mapstacks(kpgtbl);
++  
++  return kpgtbl;
++}
++
++// void init_live_pages() {
++//   //printf("yess\n");
++//   // acquiresleep(&live_list.lock);
++//   // printf("yessir\n");
++//   for (int i = 0; i < MAXPHYPAGES; i++) {
++//     live_list.valid[i] = 0;
++//     // live_list.next_index[i] = -1;
++//     live_list.elem[i].pagetable = 0;
++//     live_list.elem[i].vpn = 0;
++//     live_list.elem[i].pa = 0;
++//   }
++//   live_list.head = 0;
++//   live_list.tail = 0;
++//   live_list.size = 0;
++//   // releasesleep(&live_list.lock);
++// }
++
++void init_live_pages() {
++  live_list.size = 0;
++}
++
++// Initialize the one kernel_pagetable
++void
++kvminit(void)
++{
++  global_swap_flag = 0;
++  kernel_pagetable = kvmmake();
++  // initsleeplock(&live_list.lock, "live_list");
++  init_live_pages();
++}
++
++// Switch h/w page table register to the kernel's page table,
++// and enable paging.
++void
++kvminithart()
++{
++  // wait for any previous writes to the page table memory to finish.
++  sfence_vma();
++
++  w_satp(MAKE_SATP(kernel_pagetable));
++
++  // flush stale entries from the TLB.
++  sfence_vma();
++}
++
++// Return the address of the PTE in page table pagetable
++// that corresponds to virtual address va.  If alloc!=0,
++// create any required page-table pages.
++//
++// The risc-v Sv39 scheme has three levels of page-table
++// pages. A page-table page contains 512 64-bit PTEs.
++// A 64-bit virtual address is split into five fields:
++//   39..63 -- must be zero.
++//   30..38 -- 9 bits of level-2 index.
++//   21..29 -- 9 bits of level-1 index.
++//   12..20 -- 9 bits of level-0 index.
++//    0..11 -- 12 bits of byte offset within the page.
++pte_t *
++walk(pagetable_t pagetable, uint64 va, int alloc)
++{
++  if(va >= MAXVA)
++    panic("walk");
++
++  for(int level = 2; level > 0; level--) {
++    // sfence_vma();
++    pte_t *pte = &pagetable[PX(level, va)];
++    // printf("pte: %d\n", PTE_FLAGS(*pte));
++    if ((*pte & PTE_SWAP)) {
++      // printf("Yessir found page %d\n", (int)*pte & 0x3ff);
++      return pte;
++    }
++    // printf("passed swap check in walk\n");
++    if(*pte & PTE_V) {
++      // printf("matched valid bit\n");
++      pagetable = (pagetable_t)PTE2PA(*pte);
++    } else {
++      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
++        return 0;
++      memset(pagetable, 0, PGSIZE);
++      *pte = PA2PTE(pagetable) | PTE_V;
++    }
++  }
++  return &pagetable[PX(0, va)];
++}
++
++// Look up a virtual address, return the physical address,
++// or 0 if not mapped.
++// Can only be used to look up user pages.
++uint64
++walkaddr(pagetable_t pagetable, uint64 va)
++{
++  pte_t *pte;
++  uint64 pa;
++
++  if(va >= MAXVA)
++    return 0;
++
++  pte = walk(pagetable, va, 0);
++  if(pte == 0)
++    return 0;
++  if((*pte & PTE_V) == 0)
++    return 0;
++  if((*pte & PTE_U) == 0)
++    return 0;
++  pa = PTE2PA(*pte);
++  return pa;
++}
++
++void
++print_live_list() {
++  printf("va\tpagetable\n");
++  for(int i=0; i < live_list.size; i++) {
++    printf("%d\t%p\n", live_list.elem[i].vpn, live_list.elem[i].pagetable);
++  }
++}
++
++// add a mapping to the kernel page table.
++// only used when booting.
++// does not flush TLB or enable paging.
++void
++kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
++{
++  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
++    panic("kvmmap");
++}
++
++// Create PTEs for virtual addresses starting at va that refer to
++// physical addresses starting at pa. va and size might not
++// be page-aligned. Returns 0 on success, -1 if walk() couldn't
++// allocate a needed page-table page.
++int
++mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
++{
++  uint64 a, last;
++  pte_t *pte;
++
++  if(size == 0)
++    panic("mappages: size");
++  
++  a = PGROUNDDOWN(va);
++  last = PGROUNDDOWN(va + size - 1);
++  for(;;){
++    if((pte = walk(pagetable, a, 1)) == 0) {
++      // printf("lengra\n");
++      return -1;
++    }
++    if(*pte & PTE_V)
++      panic("mappages: remap");
++    *pte = PA2PTE(pa) | perm | PTE_V;
++    if(a == last)
++      break;
++    a += PGSIZE;
++    pa += PGSIZE;
++  }
++  return 0;
++}
++
++// Remove npages of mappings starting from va. va must be
++// page-aligned. The mappings must exist.
++// Optionally free the physical memory.
++void
++uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
++{
++  // printf("entering uvmunmap\n");
++  uint64 a;
++  pte_t *pte;
++
++  if((va % PGSIZE) != 0)
++    panic("uvmunmap: not aligned");
++
++  for(a = va; a < va + npages*PGSIZE; a += PGSIZE){
++    if((pte = walk(pagetable, a, 0)) == 0)
++      panic("uvmunmap: walk");
++    // if(((*pte & PTE_V) == 0))
++    //   panic("uvmunmap: not mapped");
++    if (((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0)
++        panic("uvmunmap: not mapped");
++    if (PTE_FLAGS(*pte) == PTE_V)
++      panic("uvmunmap: not a leaf");
++    if(do_free){
++      if (*pte & PTE_SWAP) {
++        // printf("inside uvmunmap->swap\n");
++        // pte contains swap address
++        struct swap *swapAddress = (struct swap *)((*pte) >> 10);
++        swapfree(swapAddress);
++        // printf("swap free done\n");
++      } else {
++        uint64 pa = PTE2PA(*pte);
++
++        // acquire(&live_list.lock);
++        // printf("trying to look_up %d\n", (unsigned int) pa);
++        int idx = list_lookup(pa);
++
++        if (idx >= 0) {
++          // printf("removing live page\n");
++          remove_live_page(idx);
++        }
++        // release(&live_list.lock);
++        kfree((void*)pa);
++      }
++    }
++    *pte = 0;
++  }
++  // printf("Exiting uvmunmap\n");
++  // printf("after deallocation: ");
++  // print_live_count();
++}
++
++// create an empty user page table.
++// returns 0 if out of memory.
++pagetable_t
++uvmcreate()
++{
++  pagetable_t pagetable;
++  pagetable = (pagetable_t) kalloc();
++  if(pagetable == 0)
++    return 0;
++  memset(pagetable, 0, PGSIZE);
++  return pagetable;
++}
++
++// Load the user initcode into address 0 of pagetable,
++// for the very first process.
++// sz must be less than a page.
++void
++uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
++{
++  char *mem;
++
++  if(sz >= PGSIZE)
++    panic("uvmfirst: more than a page");
++  mem = kalloc();
++  memset(mem, 0, PGSIZE);
++  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
++  memmove(mem, src, sz);
++}
++
++void
++add_live_page(pagetable_t pagetable, uint64 va, uint64 pa) {
++  if(live_list.size >= 50) {
++    panic ("Live page full\n");
++  }
++  live_list.elem[live_list.size].pagetable = pagetable;
++  live_list.elem[live_list.size].vpn = va;
++  live_list.elem[live_list.size].pa = pa;
++  live_list.size++;
++}
++
++int
++list_lookup(uint64 pa) {
++  // acquiresleep(&live_list.lock);
++  for (int i = 0; i < live_list.size; i++) {
++      if (pa == live_list.elem[i].pa) {
++        return i;
++      }
++  }
++
++  return -1;
++}
++
++struct live
++remove_live_page(int idx) {
++  if(live_list.size <= idx) {
++    panic ("Empty live_list\n");
++  }
++  struct live temp = live_list.elem[idx];
++  for(int i = idx; i < live_list.size-1; i++) {
++    live_list.elem[i] = live_list.elem[i+1];
++  }
++  live_list.size--;
++  return temp;
++}
++
++
++
++// returns 0 if not successful
++uint
++swap_out_wrapper() {
++  // printf("Entering swap_out_wrapper\n");
++  pte_t *pte;
++  uint64 pa;
++  uint flags;
++
++  // acquire(&live_list.lock);
++  if (live_list.size >= 50) {
++    // print_live_list();
++    struct live live_to_remove = remove_live_page(0);
++    pagetable_t pagetable = live_to_remove.pagetable;
++    uint64 va = live_to_remove.vpn;
++    pa = live_to_remove.pa;
++    
++    // printf("actually swapping out\n");
++    // allocate a swap
++    struct swap* toSwap;
++    if((toSwap = swapalloc()) == 0) {
++      printf("Memory Full\n");
++      // release(&live_list.lock);
++      return 0;
++    } 
++
++    swapout(toSwap, (char *)pa);
++
++    // get a live page to swap
++    
++
++    /*
++      walk inconsistency bug modification
++    */
++
++    if((pte = walk(pagetable, va, 0)) == 0) {
++      printf("Unable to walk\n");
++      // release(&live_list.lock);
++      return 0;
++    }
++    flags = PTE_FLAGS(*pte);
++    flags |= PTE_SWAP; 
++    flags &= (~PTE_V);
++    
++    kfree((void *)PGROUNDDOWN(pa));    
++    *pte = ((uint64)toSwap << 10) | flags;
++  }
++
++  return 1;
++}
++
++// Allocate PTEs and physical memory to grow process from oldsz to
++// newsz, which need not be page aligned.  Returns new size or 0 on error.
++uint64
++uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
++{
++  char *mem;
++  uint64 a;
++  // printf("Entering uvmalloc\n");
++  if(newsz < oldsz)
++    return oldsz;
++
++  oldsz = PGROUNDUP(oldsz);
++  for(a = oldsz; a < newsz; a += PGSIZE) {
++    mem = kalloc();
++    if(mem == 0){
++      goto err;
++    }
++    memset(mem, 0, PGSIZE);
++    if(mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
++      kfree(mem);
++      uvmdealloc(pagetable, a, oldsz);
++      return 0;
++    }
++    // only swap the non executables. 
++    if(global_swap_flag) {
++      if (swap_out_wrapper() == 0)
++        goto err;
++    
++      add_live_page(pagetable, a, (uint64)mem);
++    }
++    // print_live_count();
++  }
++  global_swap_flag = 0;
++  return newsz;
++
++  err:
++    uvmdealloc(pagetable, a, oldsz);
++    global_swap_flag = 0;
++    return 0;
++}
++
++// Deallocate user pages to bring the process size from oldsz to
++// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
++// need to be less than oldsz.  oldsz can be larger than the actual
++// process size.  Returns the new process size.
++uint64
++uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
++{
++  if(newsz >= oldsz)
++    return oldsz;
++
++  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
++    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
++    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
++  }
++
++  return newsz;
++}
++
++// Recursively free page-table pages.
++// All leaf mappings must already have been removed.
++void
++freewalk(pagetable_t pagetable)
++{
++  // there are 2^9 = 512 PTEs in a page table.
++  for(int i = 0; i < 512; i++){
++    pte_t pte = pagetable[i];
++    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
++      // this PTE points to a lower-level page table.
++      uint64 child = PTE2PA(pte);
++      freewalk((pagetable_t)child);
++      pagetable[i] = 0;
++    } else if(pte & PTE_V){
++      panic("freewalk: leaf");
++    }
++  }
++  kfree((void*)pagetable);
++}
++
++// Free user memory pages,
++// then free page-table pages.
++void
++uvmfree(pagetable_t pagetable, uint64 sz)
++{
++  if(sz > 0)
++    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
++  freewalk(pagetable);
++}
++
++// Given a parent process's page table, copy
++// its memory into a child's page table.
++// Copies both the page table and the
++// physical memory.
++// returns 0 on success, -1 on failure.
++// frees any allocated pages on failure.
++int
++uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
++{
++  pte_t *pte;
++  uint64 pa, i;
++  uint flags;
++  char *mem;
++  // printf("Entering UVMcopy\n");
++  for(i = 0; i < sz; i += PGSIZE){
++    if((pte = walk(old, i, 0)) == 0)
++      panic("uvmcopy: pte should exist");
++    // not valid and not swapped
++    if(((*pte & PTE_V) == 0) && (*pte & PTE_SWAP) == 0)
++      panic("uvmcopy: page not present");
++    //either valid or swapped
++    pa = PTE2PA(*pte);
++    flags = PTE_FLAGS(*pte);
++    if(flags & PTE_SWAP) {
++      // swapped memory for parent
++      // printf("in parent process: swap page found\n");
++      if(swap_out_wrapper() == 0) {
++        // printf("Error in uvmcopy->swap_out_wrapper\n");
++        goto err;
++      }
++
++      // printf("swapout finished\n");
++      char *mem2;
++      struct swap* toSwap = (struct swap*)(*pte >> 10);
++      flags &= (~PTE_SWAP);
++      flags |= (PTE_V);
++
++      if ((mem2 = kalloc()) == 0) {
++        goto err;
++      }
++
++      swapin((char *)mem2, toSwap);
++      // printf("swapin done\n");
++      // acquire(&p->lock);
++      add_live_page(old, i, (uint64)mem2);
++
++      if(mappages(old, i, PGSIZE, (uint64)mem2, flags) != 0){
++        kfree(mem2);
++        goto err;
++      }
++      pa = (uint64)mem2;
++      swapfree(toSwap);
++    }
++    // all parent pages are either live or not swappable
++    // for child, memory alloc
++    if((mem = kalloc()) == 0){
++      goto err;
++    }
++    memmove(mem, (char*)pa, PGSIZE);
++    
++    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
++      kfree(mem);
++      goto err;
++    }
++
++    int parent_livepage_idx = list_lookup(pa);
++    
++    if (parent_livepage_idx == -1) {
++      // not live page. so directly map
++    } else {
++      // parent is a live page. So,
++      // child should be kept in live
++      if (swap_out_wrapper() == 0){
++        goto err;
++      }
++
++      add_live_page(new, i, (uint64)mem);
++    }
++  }
++
++  return 0;
++
++ err:
++  uvmunmap(new, 0, i / PGSIZE, 1);
++  return -1;
++}
++
++// mark a PTE invalid for user access.
++// used by exec for the user stack guard page.
++void
++uvmclear(pagetable_t pagetable, uint64 va)
++{
++  pte_t *pte;
++  
++  pte = walk(pagetable, va, 0);
++  if(pte == 0)
++    panic("uvmclear");
++  *pte &= ~PTE_U;
++}
++
++// Copy from kernel to user.
++// Copy len bytes from src to virtual address dstva in a given page table.
++// Return 0 on success, -1 on error.
++int
++copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
++{
++  uint64 n, va0, pa0;
++
++  while(len > 0){
++    va0 = PGROUNDDOWN(dstva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (dstva - va0);
++    if(n > len)
++      n = len;
++    memmove((void *)(pa0 + (dstva - va0)), src, n);
++
++    len -= n;
++    src += n;
++    dstva = va0 + PGSIZE;
++  }
++  return 0;
++}
++
++// Copy from user to kernel.
++// Copy len bytes to dst from virtual address srcva in a given page table.
++// Return 0 on success, -1 on error.
++int
++copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
++{
++  uint64 n, va0, pa0;
++
++  while(len > 0){
++    va0 = PGROUNDDOWN(srcva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (srcva - va0);
++    if(n > len)
++      n = len;
++    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
++
++    len -= n;
++    dst += n;
++    srcva = va0 + PGSIZE;
++  }
++  return 0;
++}
++
++// Copy a null-terminated string from user to kernel.
++// Copy bytes to dst from virtual address srcva in a given page table,
++// until a '\0', or max.
++// Return 0 on success, -1 on error.
++int
++copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
++{
++  uint64 n, va0, pa0;
++  int got_null = 0;
++
++  while(got_null == 0 && max > 0){
++    va0 = PGROUNDDOWN(srcva);
++    pa0 = walkaddr(pagetable, va0);
++    if(pa0 == 0)
++      return -1;
++    n = PGSIZE - (srcva - va0);
++    if(n > max)
++      n = max;
++
++    char *p = (char *) (pa0 + (srcva - va0));
++    while(n > 0){
++      if(*p == '\0'){
++        *dst = '\0';
++        got_null = 1;
++        break;
++      } else {
++        *dst = *p;
++      }
++      --n;
++      --max;
++      p++;
++      dst++;
++    }
++
++    srcva = va0 + PGSIZE;
++  }
++  if(got_null){
++    return 0;
++  } else {
++    return -1;
++  }
++}
+diff --git a/user/usertest.c b/user/usertest.c
+new file mode 100644
+index 0000000..d1845d7
+--- /dev/null
++++ b/user/usertest.c
+@@ -0,0 +1,33 @@
++#include "kernel/param.h"
++#include "kernel/types.h"
++#include "kernel/stat.h"
++#include "user/user.h"
++
++void main(int argc, char *argv[])
++{
++    int n = atoi(argv[1]);
++    printf("%d\n", n);
++    char *i = sbrk(4096 * n);
++    // printf("pointer: %p\n", i);
++    *((int *)i) = 7;
++    printf("Hello %d\n", *i);
++    // char *j = sbrk(4096 * 10);
++    // *((int *)j) = 13;
++    // printf("Hello %d\n", *i);
++    // printf("hello 2 %d\n", *j);
++    int pid = fork();
++    if (pid == 0)
++    {
++        printf("in child process: previous i = %d\n", *i);
++        *i = 10;
++        printf("in child process: new i = %d\n", *i);
++        exit(0);
++    } else {
++        wait(0);
++        printf("in parent: i = %d\n", *i);
++    }
++
++    if (*i == 7)
++        printf("Fork done. OK\n");
++    exit(0);
++}
+\ No newline at end of file
diff --git a/user/testlivepage.c b/user/testlivepage.c
new file mode 100644
index 0000000..5bfd8a6
--- /dev/null
+++ b/user/testlivepage.c
@@ -0,0 +1,36 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "kernel/riscv.h"
+#include "user/user.h"
+
+void main(int argc, char *argv[])
+{
+    if (argc < 2)
+    {
+        printf("Usage: testlivepage <number of pages>\n");
+        exit(1);
+    }
+
+    int n = atoi(argv[1]);
+
+    sbrk(PGSIZE * n);
+    
+    livepagestat();
+    // printf("Hello %d\n", *i);
+    // int pid = fork();
+    // if (pid == 0)
+    // {
+    //     printf("in child process: previous i = %d\n", *i);
+    //     *i = 10;
+    //     printf("in child process: new i = %d\n", *i);
+    //     exit(0);
+    // } else {
+    //     wait(0);
+    //     printf("in parent: i = %d\n", *i);
+    // }
+
+    // if (*i == 7)
+    //     printf("Fork done. OK\n");
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/testpagefork.c b/user/testpagefork.c
new file mode 100644
index 0000000..449252c
--- /dev/null
+++ b/user/testpagefork.c
@@ -0,0 +1,32 @@
+#include "kernel/param.h"
+#include "kernel/types.h"
+#include "kernel/riscv.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+void main(int argc, char *argv[]) {
+  int num_pages_to_allocate = MAXPHYPAGES + 5;
+  int *n = (int *)sbrk(PGSIZE * num_pages_to_allocate);
+
+  int val = 10;
+  printf("setting %d in first address\n", val);
+  *n = val;
+
+  printf("allocated %d pages\n", num_pages_to_allocate);
+  printf("forking...\n");
+  
+  int pid = fork();
+  if (pid == 0)
+  {
+    printf("in child process: value of first address = %d\n", *n);
+    exit(0);
+  } else {
+    wait(0);
+    printf("in parent: value in first address: %d\n", *n);
+  }
+
+  if (*n == val)
+    printf("OK\n");
+
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..e915fa9 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int livepagestat(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..8b98846 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("livepagestat");
