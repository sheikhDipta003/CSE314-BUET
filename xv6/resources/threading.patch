diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..aa48e88
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,5 @@
+{
+    "files.associations": {
+        "assert.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/Makefile b/Makefile
index 39a99d7..151b273 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,7 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_threads\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..9397577 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -106,6 +106,7 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+int             thread_create(void(*fcn)(void*), void *arg, void *stack);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
diff --git a/kernel/exec.c b/kernel/exec.c
index e18bbb6..e51831a 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -19,120 +19,198 @@ int flags2perm(int flags)
     return perm;
 }
 
+//completes the work of the sys_exec() syscall
+//path -> executable file path: /usr/bin/cat
+//argv -> pointer to the argument strings needed for main() of that file [null terminated]
+//returns -1 if something goes wrong
+//but if all ok, then it begins executing that executable file in the new virtual address space of kernel
 int
 exec(char *path, char **argv)
 {
   char *s, *last;
   int i, off;
   uint64 argc, sz = 0, sp, ustack[MAXARG], stackbase;
+  //sz = 0 -> load the program segments into a new virtual address space (created later in this function) starting from virtual address 0
   struct elfhdr elf;
+
+  //an inode (short for "index node") is a fundamental data structure used to represent files. It contains metadata about a file, such as its type, permissions, size, and pointers to the data blocks that hold the file's content. Each inode is identified by a unique inode number, which is often used to reference the inode within the file system. Inodes are typically organized in an inode table or similar structure within the file system. This table allows the operating system to quickly look up and access inodes.
   struct inode *ip;
-  struct proghdr ph;
+  struct proghdr ph;    //program header data structure
   pagetable_t pagetable = 0, oldpagetable;
   struct proc *p = myproc();
 
-  begin_op();
+  begin_op();   //begin transaction
 
+  //namei() -> Look up and return the pointer to the inode for given path name of an executable file.
   if((ip = namei(path)) == 0){
-    end_op();
+    end_op();   //end transaction
     return -1;
   }
   ilock(ip);
 
-  // Check ELF header
-  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))
+  // Read data from inode.
+  // Caller must hold ip->lock.
+  // If user_dst==1, then dst is a user virtual address;
+  // otherwise, dst is a kernel address.
+  // int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)
+  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf)) // Check ELF header
     goto bad;
+  
+  //we read in from offset 0 [of the ipnode 'ip'] the elf header into local variable elf that points to a location in kernel-address-space
 
   if(elf.magic != ELF_MAGIC)
     goto bad;
 
+  //Now, this code is executing within a process, and that process has a virtual address space. If anything goes wrong, we have to return -1 and return to executing the code that is in that virt addr space. 
+  //But if all ok, we are going to create a new user virtual address space, and load the executable file into that address space. So, now we are going to create that second virtual address space. The local variable pagetable will point to the newly created pagetable.
+  //The function proc_pagetable() needs to add a trapframe to the top of the new virtual address space and it needs to know which physical page to use for that particular page in the virtual address space.
+  //The executable file must be loaded into the 'code segment' of this new virtual address space
+
+  //proc_pagetable() -> Create a user page table for a given process, with no user memory, but with trampoline and trapframe pages.
   if((pagetable = proc_pagetable(p)) == 0)
     goto bad;
 
-  // Load program into memory.
+  //Load executable file into memory segment-by-segment. Each program segment may cover many pages.
+  //elf.phoff -> offset of the first program header
+  //elf.phnum -> total number of program headers
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
+    //from 'off' offset of ipnode, read-in the program-segment of size 'sizeof(ph)' bytes into the local variable 'ph'
     if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
       goto bad;
     if(ph.type != ELF_PROG_LOAD)
       continue;
+    
+    //when the program is loaded into memory, it will be allocated a memory of size memsz which is at least as large as filesz
     if(ph.memsz < ph.filesz)
       goto bad;
+    
+    //check overflow, vaddr and memsz are unsigned integers
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
+    
+    //check if the virtual address we will be loading the executable file into is page-aligned
     if(ph.vaddr % PGSIZE != 0)
       goto bad;
+    
     uint64 sz1;
+
+    //Allocate PTEs and physical memory to grow virtual address space  from oldsz to
+    //newsz, which need not be page aligned. Returns new size or 0 on error. The newly created virtual address space must be at least large enough to hold the program segment
+    // uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
     if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)
       goto bad;
+    
+    //flags2perm()
+    //Each user-page is by default user-accessible and readable. With this helper function, we can specify whether this new virtual address space will be writable and/or executable.
+    
+    //update local variable sz. why??
+    //Because we are executing A SINGLE PROGRAM DIVIDED INTO MANY PROGRAM SEGMENTS and we have created A SINGLE 'pagetable'/virtual-address-space for the whole program. So, each time this virt addr space grows, we must update its current size, because this will be the oldsize for the next program segment.
     sz = sz1;
+
+    //now we have created space for the current program segment in the new virtual address space. Next, load the bytes from the file to the virtual address space.
+    //ph.off -> where in the elf file, the bytes of current segment begin
+    //move the segment at location 'ph.vaddr' in virt addr space and update PTEs in 'pagetable'
     if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)
       goto bad;
   }
+
+  //we are done loading the executable file in new virt addr space corresponding to 'pagetable'
   iunlockput(ip);
   end_op();
   ip = 0;
 
   p = myproc();
-  uint64 oldsz = p->sz;
+  uint64 oldsz = p->sz;   //size of the virtual address space of current process
+
+  // now we have, in our new virtual address space, trampoline and trapframe, located at the top and all the program segments located at the bottom. But the final location of the ending position of the loaded segments ['sz'] may not be page aligned.
 
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible as a stack guard.
   // Use the second as the user stack.
+  // From now on, 'the stack'/'stack' will refer to this user stack.
   sz = PGROUNDUP(sz);
   uint64 sz1;
   if((sz1 = uvmalloc(pagetable, sz, sz + 2*PGSIZE, PTE_W)) == 0)
     goto bad;
   sz = sz1;
-  uvmclear(pagetable, sz-2*PGSIZE);
-  sp = sz;
-  stackbase = sp - PGSIZE;
 
+  //the guard page must be inaccessible to user, so make sure that stack never grows below stackbase
+  uvmclear(pagetable, sz-2*PGSIZE);
+  sp = sz;                  //top of the stack
+  stackbase = sp - PGSIZE;  //bottom of the stack
+  
+  //this function is called from syscall sys_exec(), which passes an array, argv, of string pointers that point to the argument strings [originally provided by user] located at seaprate pages in kernel space
   // Push argument strings, prepare rest of stack in ustack.
+  //STACK GROWS DOWNWARD, THAT IS, FROM A HIGHER ADDRESS TO A LOWER ADDRESS
+  //this loop fetches all argument strings from argv array and pushes them onto the stack
   for(argc = 0; argv[argc]; argc++) {
     if(argc >= MAXARG)
       goto bad;
     sp -= strlen(argv[argc]) + 1;
     sp -= sp % 16; // riscv sp must be 16-byte aligned
+
+    //if stack grows below stackbase, that is, overflows, error
     if(sp < stackbase)
       goto bad;
+    
+    //copy strings from argv[argc] to sp and update pagetable
     if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
       goto bad;
+    
+    //we want to save a pointer to the string just pushed onto the stack, hence the local variable ustack
     ustack[argc] = sp;
   }
   ustack[argc] = 0;
 
   // push the array of argv[] pointers.
-  sp -= (argc+1) * sizeof(uint64);
+  sp -= (argc+1) * sizeof(uint64);  //+1 for the null string in ustack
   sp -= sp % 16;
+
+  //if stack grows below stackbase, that is, overflows, error
   if(sp < stackbase)
     goto bad;
+  
+  //copy strings from array ustack to sp and update pagetable
   if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
     goto bad;
 
+  //now, sp points to the starting position of ustack array. Thus, when we will call the main() function for the executable file/program, we will pass argc in a0 and sp in a1
+
   // arguments to user main(argc, argv)
   // argc is returned via the system call return
   // value, which goes in a0.
   p->trapframe->a1 = sp;
 
   // Save program name for debugging.
+  //path-> usr/bin/echo
+  //               |
+  //              \|/
+  //              last
   for(last=s=path; *s; s++)
     if(*s == '/')
       last = s+1;
   safestrcpy(p->name, last, sizeof(p->name));
+
+  //now we are ready to switch from the old virtual address space where this code is running to the new virtual address space created previously for the program and make sure we start at the beginning of the new program
     
   // Commit to the user image.
   oldpagetable = p->pagetable;
   p->pagetable = pagetable;
   p->sz = sz;
   p->trapframe->epc = elf.entry;  // initial program counter = main
-  p->trapframe->sp = sp; // initial stack pointer
+  p->trapframe->sp = sp;          // initial stack pointer
   proc_freepagetable(oldpagetable, oldsz);
 
   return argc; // this ends up in a0, the first argument to main(argc, argv)
+  //even after return of the sys_exec(), this user program continues execution starting from elf.entry
+  //the new program executes with all the files that were open in the previous program still open and in the same cwd since the fields ofile and cwd of myproc() is unchanged
 
  bad:
+  //since we don't know at which point we got a 'bad' result, check if we have reached far enough to allocate a pagetable. If yes, free that pagetable as well as the data pages of total size 'sz'
   if(pagetable)
     proc_freepagetable(pagetable, sz);
+  
+  //if inode for the executable file still open
   if(ip){
     iunlockput(ip);
     end_op();
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..23edded 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -106,6 +106,7 @@ allocpid()
 // If found, initialize state required to run in the kernel,
 // and return with p->lock held.
 // If there are no free procs, or a memory allocation fails, return 0.
+// allocates a new address space for any free proc structure that it can find. allocates trapframe, trampoline and user stack pages in that new address space. updates proc structure fields as necessary and returns the updated proc structure.
 static struct proc*
 allocproc(void)
 {
@@ -131,9 +132,12 @@ found:
     release(&p->lock);
     return 0;
   }
+  //p->trapframe -> physcial address of the trapframe [in the actual physical ram of the system xv6 is running on]
 
   // An empty user page table.
   p->pagetable = proc_pagetable(p);
+  //we have the physical address of p->trapframe, but we don't have a pagetable for p. Thus, we will call proc_pagetable(p). This function will allocate an empty pagetable by calling kalloc(). Fill the pagetable with 0. Finally, update corresponding PTEs of p->trapframe and trampoline page with their va[in the address space of 'p']-->pa[in actual physical memory, which corresponds to kernel address space] mapping.
+
   if(p->pagetable == 0){
     freeproc(p);
     release(&p->lock);
@@ -142,7 +146,11 @@ found:
 
   // Set up new context to start executing at forkret,
   // which returns to user space.
+  //void* memset(void *dst, int c, uint n)
+  //fill 'n' bytes of the location starting from 'dst' with 'c'
   memset(&p->context, 0, sizeof(p->context));
+  //this clears all the registers in process 'p'
+
   p->context.ra = (uint64)forkret;
   p->context.sp = p->kstack + PGSIZE;
 
@@ -287,8 +295,12 @@ fork(void)
   if((np = allocproc()) == 0){
     return -1;
   }
+  //by calling allocproc(), we have created a new virtual address space and a new empty pagetable, we have allocated space for trampoline and trapframe page and added both of their va<-->pa maping into the empty pagetable and finally we have created a user stack for 'np' as well as updated its sp to point to the top of the now empty stack.
+
+  //next we have to copy the parent's data pages [from heap memory] to the new virtual address space for the child. We can get the size of these data pages from p->sz
 
-  // Copy user memory from parent to child.
+  //Copy user memory from parent to child.
+  //every data page from the parent process 'p' is copied and added to the child's virtual address space
   if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
     freeproc(np);
     release(&np->lock);
@@ -297,6 +309,8 @@ fork(void)
   np->sz = p->sz;
 
   // copy saved user registers.
+  // when this function is called via syscall sys_fork(), which is called by the parent process, the parent process saves all user registers and epc to p->trapframe. Now, since we used kalloc() for allocating np->trapframe, np->trapframe and p->trapframe point to different locations in the actual physical memory. Thus, we have to copy the VALUES of user registers and epc to the location pointed to by np->trapframe. Copy epc so that the child process starts from the same line number that the parent process resumes after the syscall.
+  // Keep in mind that previously, when we called np = allocproc(), allocproc() only ALLOCATED PHYSICAL MEM for np->trapframe and added va<-->pa mapping to np->pagetable; that is, np->trapframe has been empty until now
   *(np->trapframe) = *(p->trapframe);
 
   // Cause fork to return 0 in the child.
@@ -325,6 +339,94 @@ fork(void)
   return pid;
 }
 
+int
+thread_create(void (*fcn)(void*), void *arg, void *stack)
+{
+  printf("proc.c/clone() : just entered this function\n");
+
+  int i, pid;
+  struct proc *np;
+  struct proc *mp = myproc();
+  uint64 sp;  // Stack pointer
+  uint64 ustack[2];  // For setting up stack as in exec.c
+
+  printf("proc.c/clone() : before 1st sanity check\n");
+  // Make sure stack is page aligned
+  if(((uint64)stack % PGSIZE) != 0) {
+    return -1;
+  }
+
+  printf("proc.c/clone() : before 2nd sanity check\n");
+  // Checking if stack is not less than a page
+  if((mp->sz - (uint64)stack) < PGSIZE) {
+    return -1;
+  }
+
+  printf("proc.c/clone() : before 3rd sanity check\n");
+  // Allocate process as in fork
+  if((np = allocproc()) == 0) {
+    return -1;
+  }
+
+  printf("proc.c/clone() : before setting up process state\n");
+  // Set up process state
+  np->stack = stack;  // The thread's stack
+  // np->stack_addr_to_free = ((uint64*)stack)[0];
+  printf("proc.c/clone() : after setting up process state\n");
+  // printf("addr to free in clone: %d : %p\n", ((uint*)stack)[0], stack);
+  printf("proc.c/clone() : before setting up pagetable\n");
+  np->pagetable = mp->pagetable;  // Thread should have same addr space
+  np->sz = (uint64)stack + PGSIZE;  //Stack is one page
+  np->parent = mp;
+  *np->trapframe = *mp->trapframe;
+  np->is_thread = 1;
+
+  // Clear a0 so that fork returns 0 in the child.
+  np->trapframe->a0 = 0;
+
+  // Set up the thread's stack
+  sp = (uint64)stack + PGSIZE;
+  ustack[0] = 0xffffffff;  // The fake return PC
+  ustack[1] = (uint64)arg;	// Store arg for fnc
+  sp -= 2 * sizeof(uint64);
+
+  printf("proc.c/clone() : before copyout()\n");
+  // Copy from kernel to user.
+  // Copy len bytes from src to virtual address dstva in a given page table.
+  // Return 0 on success, -1 on error.
+  // int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
+  if(copyout(np->pagetable, sp, (char*)ustack, sizeof(ustack)) < 0)
+    return -1;
+
+  // Set thread's stack pointer to the stack
+  np->trapframe->sp = sp;
+
+  // Set thread's instruction pointer to the function
+  np->trapframe->epc = (uint64)fcn;
+
+  // Same as in fork:
+  for(i = 0; i < NOFILE; i++)
+    if(mp->ofile[i])
+      np->ofile[i] = filedup(mp->ofile[i]);
+  np->cwd = idup(mp->cwd);
+
+  safestrcpy(np->name, mp->name, sizeof(mp->name));
+
+  pid = np->pid;
+
+  release(&np->lock);
+
+  acquire(&wait_lock);
+  np->parent = mp;
+  release(&wait_lock);
+
+  acquire(&np->lock);
+  np->state = RUNNABLE;
+  release(&np->lock);
+
+  return pid;
+}
+
 // Pass p's abandoned children to init.
 // Caller must hold wait_lock.
 void
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..90c236a 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,8 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int tid;
+  void* stack;                 // Beginning of stack
+  int is_thread;               // Whether or not this process is a thread
+  uint64 stack_addr_to_free;      // Stack address to free. May not be aligned
 };
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..79b3886 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_thread_create(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +127,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_thread_create]   sys_thread_create,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..ab588c5 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_thread_create  22
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 16b668c..a777333 100644
--- a/kernel/sysfile.c
+++ b/kernel/sysfile.c
@@ -431,36 +431,51 @@ sys_chdir(void)
   return 0;
 }
 
+// gets all the arguments[passed as an array of strings] from the address-space of the process that invokes this syscall
 uint64
 sys_exec(void)
 {
   char path[MAXPATH], *argv[MAXARG];
+  //at this point, argv is just an empty array of size MAXARG; located in kernel-address-space.
+  //the goal of this function is to copy all the args currently residing in user-process-address-space to kernel-address-space, that is, gradually fillup argv array. And after filling it with the last user arg, set remaining slots in argv to null.
   int i;
   uint64 uargv, uarg;
 
-  argaddr(1, &uargv);
+  argaddr(1, &uargv);   //copy virtual address[user-space] of the argument array, provided as the second parameter to exec() syscall, to uargv. So, uargv now points to the starting position of the arguments array provided.
+
+  //copy maximum 'MAXPATH' characters into 'path' from the first argument provided.
   if(argstr(0, path, MAXPATH) < 0) {
     return -1;
   }
-  memset(argv, 0, sizeof(argv));
-  for(i=0;; i++){
-    if(i >= NELEM(argv)){
+  memset(argv, 0, sizeof(argv));  //sets all entries of argv to null
+  for(i=0;; i++){              //loop through all the args
+    if(i >= NELEM(argv)){     //'bad' if we have gone past the number of args that can be accommodated
       goto bad;
     }
+
+    //goto the argument at i-th offset from the starting position of uargv and store the location in uarg
     if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
       goto bad;
     }
-    if(uarg == 0){
+    if(uarg == 0){    //if we got the last argument provided by the user, set the argv element to null and break the loop
       argv[i] = 0;
       break;
     }
+
+    //as mentioned earlier, the location pointed to by uarg is a virtual address of user process. We need to move them to kernel memory. So, allocate an entire page for storing the current argument pointed to by uarg.
     argv[i] = kalloc();
     if(argv[i] == 0)
       goto bad;
+    
+    //now we are done allocating a page in kernel-address-space for argv[i], but the page is empty, we haven't fetched the argument yet. That's what we are doing next.
+
+    //int fetchstr(uint64 addr, char *buf, int max)
+    //There is a string located at virtual adrress addr in current user-proces. Fetch 'max' number of characters from that string into 'buf'
     if(fetchstr(uarg, argv[i], PGSIZE) < 0)
       goto bad;
   }
 
+  //now we have fetched both the path to run the requested executable file and the arguments needed to run that file's main() function. Next, execute the file by calling exec() function. The number of arguments needed for main() function of the program will be returned from exec()
   int ret = exec(path, argv);
 
   for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
@@ -469,6 +484,7 @@ sys_exec(void)
   return ret;
 
  bad:
+  //in case of unexpected errors, free all the pages created for storing the user-provided arguments
   for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
     kfree(argv[i]);
   return -1;
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..775a274 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -89,3 +89,19 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_thread_create(void) {
+  uint64 fcn;
+  uint64 arg;
+  uint64 stack;
+
+  argaddr(0, &fcn);
+  argaddr(1, &arg);
+  argaddr(2, &stack);
+
+  printf("sysproc.c/sys_clone() : before calling clone()\n");
+
+  return thread_create((void*)fcn, (void*)arg, (void*)stack);
+}
+
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..4fb42a8 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -302,6 +302,7 @@ uvmfree(pagetable_t pagetable, uint64 sz)
 // physical memory.
 // returns 0 on success, -1 on failure.
 // frees any allocated pages on failure.
+// sz -> size of the old virtual address space
 int
 uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
 {
diff --git a/user/threads.c b/user/threads.c
new file mode 100644
index 0000000..517bf5c
--- /dev/null
+++ b/user/threads.c
@@ -0,0 +1,68 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+struct balance {
+    char name[32];
+    int amount;
+};
+
+volatile int total_balance = 0;
+
+volatile unsigned int delay (unsigned int d) {
+   unsigned int i; 
+   for (i = 0; i < d; i++) {
+       __asm volatile( "nop" ::: );
+   }
+
+   return i;   
+}
+
+void do_work(void *arg){
+    int i; 
+    int old;
+   
+    struct balance *b = (struct balance*) arg; 
+    printf( "Starting do_work: s:%s\n", b->name);
+
+    for (i = 0; i < b->amount; i++) { 
+        // lock and mlock will be implemented by you.
+         // thread_spin_lock(&lock);
+         // thread_mutex_lock(&mlock);
+         old = total_balance;
+         delay(100000);
+	 // if(old != total_balance)  printf("we will miss an update. old: %d total_balance: %d\n", old, total_balance);
+         total_balance = old + 1;
+         //thread_spin_unlock(&lock);
+         // thread_mutex_lock(&mlock);
+
+    }
+  
+    printf( "Done s:%x\n", b->name);
+
+    // thread_exit();
+    return;
+}
+
+int main(int argc, char *argv[]) {
+
+  struct balance b1 = {"b1", 3200};
+  struct balance b2 = {"b2", 2800};
+ 
+  void *s1, *s2;
+  int thread1, thread2;
+  // int r1, r2;
+
+  s1 = malloc(4096); // 4096 is the PGSIZE defined in kernel/riscv.h
+  s2 = malloc(4096);
+
+  thread1 = thread_create(do_work, (void*)&b1, s1);
+  thread2 = thread_create(do_work, (void*)&b2, s2); 
+
+  // r1 = thread_join(thread1);
+  // r2 = thread_join(thread2);
+  
+  printf("Threads finished: <%d, %d>, shared balance:%d\n", thread1, thread2, total_balance);
+
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..8025131 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int thread_create(void(*fcn)(void*), void *arg, void *stack);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..da5ea2f 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("thread_create");
